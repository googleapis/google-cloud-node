[
  {
    "tags": [],
    "description": {
      "full": "<p>Copyright 2014 Google Inc. All Rights Reserved.</p><p>Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);<br />you may not use this file except in compliance with the License.<br />You may obtain a copy of the License at</p><pre><code> http://www.apache.org/licenses/LICENSE-2.0\n</code></pre><p>Unless required by applicable law or agreed to in writing, software<br />distributed under the License is distributed on an &quot;AS IS&quot; BASIS,<br />WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<br />See the License for the specific language governing permissions and<br />limitations under the License.</p>",
      "summary": "<p>Copyright 2014 Google Inc. All Rights Reserved.</p>",
      "body": "<p>Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);<br />you may not use this file except in compliance with the License.<br />You may obtain a copy of the License at</p><pre><code> http://www.apache.org/licenses/LICENSE-2.0\n</code></pre><p>Unless required by applicable law or agreed to in writing, software<br />distributed under the License is distributed on an &quot;AS IS&quot; BASIS,<br />WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<br />See the License for the specific language governing permissions and<br />limitations under the License.</p>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 1,
    "codeStart": 16
  },
  {
    "tags": [
      {
        "type": "module",
        "string": "bigquery/table",
        "html": "<p>bigquery/table</p>"
      }
    ],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 17,
    "codeStart": 21,
    "code": "'use strict';\n\nvar crypto = require('crypto');\nvar duplexify = require('duplexify');\nvar extend = require('extend');\nvar fs = require('fs');\nvar path = require('path');\nvar streamEvents = require('stream-events');\nvar through = require('through2');",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "type",
        "string": "{module:storage/file}",
        "types": [
          "module:storage/file"
        ],
        "typesDescription": "module:<a href=\"module%3Astorage%2Ffile.html\">storage/file</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{module:storage/file}</p>"
      },
      {
        "type": "private",
        "string": "",
        "visibility": "private",
        "html": ""
      }
    ],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 31,
    "codeStart": 35,
    "code": "var File = require('../storage/file');",
    "ctx": {
      "type": "declaration",
      "name": "File",
      "value": "require('../storage/file')",
      "string": "File"
    }
  },
  {
    "tags": [
      {
        "type": "type",
        "string": "{module:common/util}",
        "types": [
          "module:common/util"
        ],
        "typesDescription": "module:<a href=\"module%3Acommon%2Futil.html\">common/util</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{module:common/util}</p>"
      },
      {
        "type": "private",
        "string": "",
        "visibility": "private",
        "html": ""
      }
    ],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 37,
    "codeStart": 41,
    "code": "var util = require('../common/util');",
    "ctx": {
      "type": "declaration",
      "name": "util",
      "value": "require('../common/util')",
      "string": "util"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{module:bigquery/dataset} dataset - Dataset instance.",
        "name": "dataset",
        "description": "<ul>\n<li>Dataset instance.</li>\n</ul>\n",
        "types": [
          "module:bigquery/dataset"
        ],
        "typesDescription": "module:<a href=\"module%3Abigquery%2Fdataset.html\">bigquery/dataset</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{string} id - The ID of the table.\n",
        "name": "id",
        "description": "<ul>\n<li>The ID of the table. </li>\n</ul>\n",
        "types": [
          "string"
        ],
        "typesDescription": "<code>string</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "example",
        "string": "var bigquery = gcloud.bigquery({ projectId: 'grape-spaceship-123' });\nvar Dataset = require('gcloud/lib/bigquery/dataset');\nvar dataset = new Dataset(bigquery, 'dataset-id');\nvar Table = require('gcloud/lib/bigquery/table');\nvar table = new Table(dataset, 'table-id');",
        "html": "<p>var bigquery = gcloud.bigquery({ projectId: &#39;grape-spaceship-123&#39; });<br />var Dataset = require(&#39;gcloud/lib/bigquery/dataset&#39;);<br />var dataset = new Dataset(bigquery, &#39;dataset-id&#39;);<br />var Table = require(&#39;gcloud/lib/bigquery/table&#39;);<br />var table = new Table(dataset, &#39;table-id&#39;);</p>"
      }
    ],
    "description": {
      "full": "<p>Developer Documentation</p>",
      "summary": "<p>Developer Documentation</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 43,
    "codeStart": 55
  },
  {
    "tags": [
      {
        "type": "alias",
        "string": "module:bigquery/table",
        "html": "<p>module:bigquery/table</p>"
      },
      {
        "type": "constructor",
        "string": "",
        "html": ""
      },
      {
        "type": "example",
        "string": "var table = dataset.table('my-table');",
        "html": "<p>var table = dataset.table(&#39;my-table&#39;);</p>"
      }
    ],
    "description": {
      "full": "<p>Table objects are returned by methods such as<br />{module:bigquery/dataset#table}, {module:bigquery/dataset#createTable}, and<br />{module:bigquery/dataset#getTables}.</p>",
      "summary": "<p>Table objects are returned by methods such as<br />{module:bigquery/dataset#table}, {module:bigquery/dataset#createTable}, and<br />{module:bigquery/dataset#getTables}.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": true,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 55,
    "codeStart": 66,
    "code": "function Table(dataset, id) {\n  this.bigQuery = dataset.bigQuery;\n  this.dataset = dataset;\n  this.id = id;\n  this.metadata = {};\n}",
    "ctx": {
      "type": "constructor",
      "name": "Table",
      "string": "Table()"
    }
  },
  {
    "tags": [
      {
        "type": "static",
        "string": "",
        "html": ""
      },
      {
        "type": "private",
        "string": "\n",
        "visibility": "private",
        "html": ""
      },
      {
        "type": "param",
        "string": "{string} str - Comma-separated schema string.",
        "name": "str",
        "description": "<ul>\n<li>Comma-separated schema string.</li>\n</ul>\n",
        "types": [
          "string"
        ],
        "typesDescription": "<code>string</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "return",
        "string": "{object} Table schema in the format the API expects.",
        "types": [
          "object"
        ],
        "typesDescription": "<code>object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "<p>Table schema in the format the API expects.</p>"
      }
    ],
    "description": {
      "full": "<p>Convert a comma-separated name:type string to a table schema object.</p>",
      "summary": "<p>Convert a comma-separated name:type string to a table schema object.</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 73,
    "codeStart": 82,
    "code": "Table.createSchemaFromString_ = function(str) {\n  return str.split(/\\s*,\\s*/).reduce(function(acc, pair) {\n    acc.fields.push({\n      name: pair.split(':')[0],\n      type: pair.split(':')[1] || 'string'\n    });\n\n    return acc;\n  }, {\n    fields: []\n  });\n};",
    "ctx": {
      "type": "method",
      "receiver": "Table",
      "name": "createSchemaFromString_",
      "string": "Table.createSchemaFromString_()"
    }
  },
  {
    "tags": [
      {
        "type": "static",
        "string": "",
        "html": ""
      },
      {
        "type": "private",
        "string": "\n",
        "visibility": "private",
        "html": ""
      },
      {
        "type": "param",
        "string": "{object} schema",
        "name": "schema",
        "description": "",
        "types": [
          "object"
        ],
        "typesDescription": "<code>object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{object} schema</p>"
      },
      {
        "type": "param",
        "string": "{array} rows",
        "name": "rows",
        "description": "",
        "types": [
          "array"
        ],
        "typesDescription": "<code>array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{array} rows</p>"
      },
      {
        "type": "return",
        "string": "{array} Fields using their matching names from the table's schema.",
        "types": [
          "array"
        ],
        "typesDescription": "<code>array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "<p>Fields using their matching names from the table&#39;s schema.</p>"
      }
    ],
    "description": {
      "full": "<p>Merge a rowset returned from the API with a table schema.</p>",
      "summary": "<p>Merge a rowset returned from the API with a table schema.</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 95,
    "codeStart": 105,
    "code": "Table.mergeSchemaWithRows_ = function(schema, rows) {\n  return rows.map(mergeSchema).map(flattenRows);\n\n  function mergeSchema(row) {\n    return row.f.map(function(field, index) {\n      var fieldObject = {};\n      fieldObject[schema.fields[index].name] = field.v;\n      return fieldObject;\n    });\n  }\n\n  function flattenRows(rows) {\n    return rows.reduce(function(acc, row) {\n      var key = Object.keys(row)[0];\n      acc[key] = row[key];\n      return acc;\n    }, {});\n  }\n};",
    "ctx": {
      "type": "method",
      "receiver": "Table",
      "name": "mergeSchemaWithRows_",
      "string": "Table.mergeSchemaWithRows_()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{module:bigquery/table} destination - The destination table.",
        "name": "destination",
        "description": "<ul>\n<li>The destination table.</li>\n</ul>\n",
        "types": [
          "module:bigquery/table"
        ],
        "typesDescription": "module:<a href=\"module%3Abigquery%2Ftable.html\">bigquery/table</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{object=} metadata - Metadata to set with the copy operation. The\n    metadata object should be in the format of the\n    [`configuration.copy`](http://goo.gl/dKWIyS) property of a Jobs resource.",
        "name": "metadata",
        "description": "<ul>\n<li>Metadata to set with the copy operation. The     metadata object should be in the format of the<br />  <a href=\"http://goo.gl/dKWIyS\"><code>configuration.copy</code></a> property of a Jobs resource.</li>\n</ul>\n",
        "types": [
          "object"
        ],
        "typesDescription": "<code>object</code>|<code>undefined</code>",
        "optional": true,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{function} callback - The callback function.\n",
        "name": "callback",
        "description": "<ul>\n<li>The callback function. </li>\n</ul>\n",
        "types": [
          "function"
        ],
        "typesDescription": "<code>function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "throws",
        "string": "{Error} If a destination other than a Table object is provided.\n",
        "types": [
          "Error"
        ],
        "description": "<p>If a destination other than a Table object is provided. </p>"
      },
      {
        "type": "example",
        "string": "var yourTable = dataset.table('your-table');\ntable.copy(yourTable, function(err, job, apiResponse) {});\n\n//-\n// See the [`configuration.copy`](http://goo.gl/dKWIyS) object for all\n// available options.\n//-\nvar metadata = {\n  createDisposition: 'CREATE_NEVER',\n  writeDisposition: 'WRITE_TRUNCATE'\n};\n\ntable.copy(yourTable, metadata, function(err, job, apiResponse) {});",
        "html": "<p>var yourTable = dataset.table(&#39;your-table&#39;);<br />table.copy(yourTable, function(err, job, apiResponse) {});</p><p>//-<br />// See the <a href=\"http://goo.gl/dKWIyS\"><code>configuration.copy</code></a> object for all<br />// available options.<br />//-<br />var metadata = {<br />  createDisposition: &#39;CREATE_NEVER&#39;,<br />  writeDisposition: &#39;WRITE_TRUNCATE&#39;<br />};</p><p>table.copy(yourTable, metadata, function(err, job, apiResponse) {});</p>"
      }
    ],
    "description": {
      "full": "<p>Copy data from one table to another, optionally creating that table.</p>",
      "summary": "<p>Copy data from one table to another, optionally creating that table.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 125,
    "codeStart": 151,
    "code": "Table.prototype.copy = function(destination, metadata, callback) {\n  var that = this;\n\n  if (!(destination instanceof Table)) {\n    throw new Error('Destination must be a Table object.');\n  }\n\n  if (util.is(metadata, 'function')) {\n    callback = metadata;\n    metadata = {};\n  }\n\n  var body = {\n    configuration: {\n      copy: extend(true, metadata || {}, {\n        destinationTable: {\n          datasetId: destination.dataset.id,\n          projectId: destination.bigQuery.projectId,\n          tableId: destination.id\n        },\n        sourceTable: {\n          datasetId: this.dataset.id,\n          projectId: this.bigQuery.projectId,\n          tableId: this.id\n        }\n      })\n    }\n  };\n\n  this.bigQuery.makeReq_('POST', '/jobs', null, body, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var job = that.bigQuery.job(resp.jobReference.jobId);\n    job.metadata = resp;\n\n    callback(null, job, resp);\n  });\n};",
    "ctx": {
      "type": "method",
      "constructor": "Table",
      "cons": "Table",
      "name": "copy",
      "string": "Table.prototype.copy()"
    }
  },
  {
    "tags": [
      {
        "type": "return",
        "string": "{ReadStream}\n",
        "types": [
          "ReadStream"
        ],
        "typesDescription": "<a href=\"ReadStream.html\">ReadStream</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "",
        "html": "<p>{ReadStream}</p>"
      },
      {
        "type": "example",
        "string": "var through2 = require('through2');\nvar fs = require('fs');\n\ntable.createReadStream()\n  .pipe(through2.obj(function(row, enc, next) {\n    this.push(JSON.stringify(row) + '\\n');\n  }))\n  .pipe(fs.createWriteStream('./test/testdata/testfile.json'));",
        "html": "<p>var through2 = require(&#39;through2&#39;);<br />var fs = require(&#39;fs&#39;);</p><p>table.createReadStream()<br />  .pipe(through2.obj(function(row, enc, next) {<br />    this.push(JSON.stringify(row) + &#39;\\n&#39;);<br />  }))<br />  .pipe(fs.createWriteStream(&#39;./test/testdata/testfile.json&#39;));</p>"
      }
    ],
    "description": {
      "full": "<p>Create a readable stream of the rows of data in your table.</p>",
      "summary": "<p>Create a readable stream of the rows of data in your table.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 193,
    "codeStart": 208,
    "code": "Table.prototype.createReadStream = function() {\n  var that = this;\n\n  var stream = streamEvents(through.obj());\n  stream.once('reading', function() {\n    that.getRows(handleResponse);\n  });\n  return stream;\n\n  function handleResponse(err, rows, nextQuery) {\n    if (err) {\n      stream.emit('error', err);\n      stream.end();\n      return;\n    }\n\n    rows.forEach(function(row) {\n      stream.push(row);\n    });\n\n    if (nextQuery) {\n      that.getRows(nextQuery, handleResponse);\n    } else {\n      stream.end();\n    }\n  }\n};",
    "ctx": {
      "type": "method",
      "constructor": "Table",
      "cons": "Table",
      "name": "createReadStream",
      "string": "Table.prototype.createReadStream()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{string|object=} metadata - Metadata to set with the load operation.\n    The metadata object should be in the format of the\n    [`configuration.load`](http://goo.gl/BVcXk4) property of a Jobs resource.\n    If a string is given, it will be used as the filetype.",
        "name": "metadata",
        "description": "<ul>\n<li>Metadata to set with the load operation.     The metadata object should be in the format of the<br />  <a href=\"http://goo.gl/BVcXk4\"><code>configuration.load</code></a> property of a Jobs resource.<br />  If a string is given, it will be used as the filetype.</li>\n</ul>\n",
        "types": [
          "string",
          "object"
        ],
        "typesDescription": "<code>string</code>|<code>object</code>|<code>undefined</code>",
        "optional": true,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "return",
        "string": "{WriteStream}\n",
        "types": [
          "WriteStream"
        ],
        "typesDescription": "<a href=\"WriteStream.html\">WriteStream</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "description": "",
        "html": "<p>{WriteStream}</p>"
      },
      {
        "type": "throws",
        "string": "{Error} If source format isn't recognized.\n",
        "types": [
          "Error"
        ],
        "description": "<p>If source format isn&#39;t recognized. </p>"
      },
      {
        "type": "example",
        "string": "//-\n// Load data from a CSV file.\n//-\nvar request = require('request');\n\nvar csvUrl = 'http://goo.gl/kSE7z6';\n\nvar metadata = {\n  allowJaggedRows: true,\n  skipLeadingRows: 1\n};\n\nrequest.get(csvUrl)\n  .pipe(table.createWriteStream(metadata))\n  .on('complete', function(job) {\n    // job is a Job object, which you can use to check the status of the load\n    // operation.\n    job.getMetadata(function(err, metadata) {\n      // metadata.status\n    });\n  });\n\n//-\n// Load data from a JSON file.\n//-\nvar fs = require('fs');\n\nfs.createReadStream('./test/testdata/testfile.json')\n  .pipe(table.createWriteStream('json'))\n  .on('complete', function(job) {});",
        "html": "<p>//-<br />// Load data from a CSV file.<br />//-<br />var request = require(&#39;request&#39;);</p><p>var csvUrl = &#39;<a href=\"http://goo.gl/kSE7z6\">http://goo.gl/kSE7z6</a>&#39;;</p><p>var metadata = {<br />  allowJaggedRows: true,<br />  skipLeadingRows: 1<br />};</p><p>request.get(csvUrl)<br />  .pipe(table.createWriteStream(metadata))<br />  .on(&#39;complete&#39;, function(job) {<br />    // job is a Job object, which you can use to check the status of the load<br />    // operation.<br />    job.getMetadata(function(err, metadata) {<br />      // metadata.status<br />    });<br />  });</p><p>//-<br />// Load data from a JSON file.<br />//-<br />var fs = require(&#39;fs&#39;);</p><p>fs.createReadStream(&#39;./test/testdata/testfile.json&#39;)<br />  .pipe(table.createWriteStream(&#39;json&#39;))<br />  .on(&#39;complete&#39;, function(job) {});</p>"
      }
    ],
    "description": {
      "full": "<p>Load data into your table from a readable stream of JSON or CSV-formatted<br />data.</p>",
      "summary": "<p>Load data into your table from a readable stream of JSON or CSV-formatted<br />data.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 236,
    "codeStart": 280,
    "code": "Table.prototype.createWriteStream = function(metadata) {\n  var that = this;\n\n  metadata = metadata || {};\n\n  var fileTypeMap = {\n    csv: 'CSV',\n    json: 'NEWLINE_DELIMITED_JSON'\n  };\n  var fileTypes = Object.keys(fileTypeMap).map(function(key) {\n    return fileTypeMap[key];\n  });\n\n  if (util.is(metadata, 'string')) {\n    metadata = {\n      sourceFormat: fileTypeMap[metadata.toLowerCase()]\n    };\n  }\n\n  if (util.is(metadata.schema, 'string')) {\n    metadata.schema = Table.createSchemaFromString_(metadata.schema);\n  }\n\n  extend(true, metadata, {\n    destinationTable: {\n      projectId: that.bigQuery.projectId,\n      datasetId: that.dataset.id,\n      tableId: that.id\n    }\n  });\n\n  if (metadata.hasOwnProperty('sourceFormat') &&\n      fileTypes.indexOf(metadata.sourceFormat) < 0) {\n    throw new Error('Source format not recognized: ' + metadata.sourceFormat);\n  }\n\n  var dup = streamEvents(duplexify());\n\n  dup.once('writing', function() {\n    util.makeWritableStream(dup, {\n      makeAuthorizedRequest: that.bigQuery.makeAuthorizedRequest_,\n      metadata: {\n        configuration: {\n          load: metadata\n        }\n      },\n      request: {\n        uri: util.format('{base}/{projectId}/jobs', {\n          base: 'https://www.googleapis.com/upload/bigquery/v2/projects',\n          projectId: that.bigQuery.projectId\n        })\n      }\n    }, function(data) {\n      var job = that.bigQuery.job(data.jobReference.jobId);\n      job.metadata = data;\n\n      dup.emit('complete', job);\n      dup.end();\n    });\n  });\n\n  return dup;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Table",
      "cons": "Table",
      "name": "createWriteStream",
      "string": "Table.prototype.createWriteStream()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{function} callback - The callback function.\n",
        "name": "callback",
        "description": "<ul>\n<li>The callback function. </li>\n</ul>\n",
        "types": [
          "function"
        ],
        "typesDescription": "<code>function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "example",
        "string": "table.delete(function(err, apiResponse) {});",
        "html": "<p>table.delete(function(err, apiResponse) {});</p>"
      }
    ],
    "description": {
      "full": "<p>Delete a table and all its data.</p>",
      "summary": "<p>Delete a table and all its data.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 344,
    "codeStart": 352,
    "code": "Table.prototype.delete = function(callback) {\n  this.makeReq_('DELETE', '', null, null, callback);\n};",
    "ctx": {
      "type": "method",
      "constructor": "Table",
      "cons": "Table",
      "name": "delete",
      "string": "Table.prototype.delete()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{module:storage/file} destination - Where the file should be exported\n    to.",
        "name": "destination",
        "description": "<ul>\n<li>Where the file should be exported     to.</li>\n</ul>\n",
        "types": [
          "module:storage/file"
        ],
        "typesDescription": "module:<a href=\"module%3Astorage%2Ffile.html\">storage/file</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{object=} options - The configuration object.",
        "name": "options",
        "description": "<ul>\n<li>The configuration object.</li>\n</ul>\n",
        "types": [
          "object"
        ],
        "typesDescription": "<code>object</code>|<code>undefined</code>",
        "optional": true,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{string} options.format - The format to export the data in. Allowed\n    options are \"CSV\", \"JSON\", or \"AVRO\". Default: \"CSV\".",
        "name": "options.format",
        "description": "<ul>\n<li>The format to export the data in. Allowed     options are &quot;CSV&quot;, &quot;JSON&quot;, or &quot;AVRO&quot;. Default: &quot;CSV&quot;.</li>\n</ul>\n",
        "types": [
          "string"
        ],
        "typesDescription": "<code>string</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{boolean} options.gzip - Specify if you would like the file compressed\n    with GZIP. Default: false.",
        "name": "options.gzip",
        "description": "<ul>\n<li>Specify if you would like the file compressed     with GZIP. Default: false.</li>\n</ul>\n",
        "types": [
          "boolean"
        ],
        "typesDescription": "<code>boolean</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{function} callback - The callback function.\n",
        "name": "callback",
        "description": "<ul>\n<li>The callback function. </li>\n</ul>\n",
        "types": [
          "function"
        ],
        "typesDescription": "<code>function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "throws",
        "string": "{Error} If destination isn't a File object.",
        "types": [
          "Error"
        ],
        "description": "<p>If destination isn&#39;t a File object.</p>"
      },
      {
        "type": "throws",
        "string": "{Error} If destination format isn't recongized.\n",
        "types": [
          "Error"
        ],
        "description": "<p>If destination format isn&#39;t recongized. </p>"
      },
      {
        "type": "example",
        "string": "var gcs = gcloud.storage({\n  projectId: 'grape-spaceship-123'\n});\nvar exportedFile = gcs.bucket('institutions').file('2014.csv');\n\n//-\n// To use the default options, just pass a {module:storage/file} object.\n//\n// Note: The exported format type will be inferred by the file's extension.\n// If you wish to override this, or provide an array of destination files,\n// you must provide an `options` object.\n//-\ntable.export(exportedFile, function(err, job, apiResponse) {});\n\n//-\n// If you need more customization, pass an `options` object.\n//-\nvar options = {\n  format: 'json',\n  gzip: true\n};\n\ntable.export(exportedFile, options, function(err, job, apiResponse) {});\n\n//-\n// You can also specify multiple destination files.\n//-\ntable.export([\n  gcs.bucket('institutions').file('2014.json'),\n  gcs.bucket('institutions-copy').file('2014.json')\n], options, function(err, job, apiResponse) {});",
        "html": "<p>var gcs = gcloud.storage({<br />  projectId: &#39;grape-spaceship-123&#39;<br />});<br />var exportedFile = gcs.bucket(&#39;institutions&#39;).file(&#39;2014.csv&#39;);</p><p>//-<br />// To use the default options, just pass a {module:storage/file} object.<br />//<br />// Note: The exported format type will be inferred by the file&#39;s extension.<br />// If you wish to override this, or provide an array of destination files,<br />// you must provide an <code>options</code> object.<br />//-<br />table.export(exportedFile, function(err, job, apiResponse) {});</p><p>//-<br />// If you need more customization, pass an <code>options</code> object.<br />//-<br />var options = {<br />  format: &#39;json&#39;,<br />  gzip: true<br />};</p><p>table.export(exportedFile, options, function(err, job, apiResponse) {});</p><p>//-<br />// You can also specify multiple destination files.<br />//-<br />table.export([<br />  gcs.bucket(&#39;institutions&#39;).file(&#39;2014.json&#39;),<br />  gcs.bucket(&#39;institutions-copy&#39;).file(&#39;2014.json&#39;)<br />], options, function(err, job, apiResponse) {});</p>"
      }
    ],
    "description": {
      "full": "<p>Export table to Google Cloud Storage.</p>",
      "summary": "<p>Export table to Google Cloud Storage.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 356,
    "codeStart": 404,
    "code": "Table.prototype.export = function(destination, options, callback) {\n  var that = this;\n\n  if (util.is(options, 'function')) {\n    callback = options;\n    options = {};\n  }\n\n  var formats = {\n    avro: 'AVRO',\n    csv: 'CSV',\n    json: 'NEWLINE_DELIMITED_JSON'\n  };\n\n  extend(true, options, {\n    destinationUris: util.arrayize(destination).map(function(dest) {\n      if (!(dest instanceof File)) {\n        throw new Error('Destination must be a File object.');\n      }\n\n      // If no explicit format was provided, attempt to find a match from the\n      // file's extension. If no match, don't set, and default upstream to CSV.\n      var format = path.extname(dest.name).substr(1).toLowerCase();\n      if (!options.destinationFormat && !options.format && formats[format]) {\n        options.destinationFormat = formats[format];\n      }\n\n      return 'gs://' + dest.bucket.name + '/' + dest.name;\n    })\n  });\n\n  if (options.format) {\n    options.format = options.format.toLowerCase();\n\n    if (formats[options.format]) {\n      options.destinationFormat = formats[options.format];\n      delete options.format;\n    } else {\n      throw new Error('Destination format not recognized: ' + options.format);\n    }\n  }\n\n  if (options.gzip) {\n    options.compression = 'GZIP';\n    delete options.gzip;\n  }\n\n  var body = {\n    configuration: {\n      extract: extend(true, options, {\n        sourceTable: {\n          datasetId: this.dataset.id,\n          projectId: this.bigQuery.projectId,\n          tableId: this.id\n        }\n      })\n    }\n  };\n\n  this.bigQuery.makeReq_('POST', '/jobs', null, body, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var job = that.bigQuery.job(resp.jobReference.jobId);\n    job.metadata = resp;\n\n    callback(null, job, resp);\n  });\n};",
    "ctx": {
      "type": "method",
      "constructor": "Table",
      "cons": "Table",
      "name": "export",
      "string": "Table.prototype.export()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{function} callback - The callback function.\n",
        "name": "callback",
        "description": "<ul>\n<li>The callback function. </li>\n</ul>\n",
        "types": [
          "function"
        ],
        "typesDescription": "<code>function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "example",
        "string": "table.getMetadata(function(err, metadata, apiResponse) {});",
        "html": "<p>table.getMetadata(function(err, metadata, apiResponse) {});</p>"
      }
    ],
    "description": {
      "full": "<p>Return the metadata associated with the Table.</p>",
      "summary": "<p>Return the metadata associated with the Table.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 476,
    "codeStart": 484,
    "code": "Table.prototype.getMetadata = function(callback) {\n  var that = this;\n\n  this.makeReq_('GET', '', null, null, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    that.metadata = resp;\n\n    callback(null, that.metadata, resp);\n  });\n};",
    "ctx": {
      "type": "method",
      "constructor": "Table",
      "cons": "Table",
      "name": "getMetadata",
      "string": "Table.prototype.getMetadata()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{object=} options - The configuration object.",
        "name": "options",
        "description": "<ul>\n<li>The configuration object.</li>\n</ul>\n",
        "types": [
          "object"
        ],
        "typesDescription": "<code>object</code>|<code>undefined</code>",
        "optional": true,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{number} options.maxResults - Maximum number of results to return.",
        "name": "options.maxResults",
        "description": "<ul>\n<li>Maximum number of results to return.</li>\n</ul>\n",
        "types": [
          "number"
        ],
        "typesDescription": "<code>number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{function} callback - The callback function.\n",
        "name": "callback",
        "description": "<ul>\n<li>The callback function. </li>\n</ul>\n",
        "types": [
          "function"
        ],
        "typesDescription": "<code>function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "example",
        "string": "var options = {\n  maxResults: 100\n};\n\ntable.getRows(options, function(err, rows, nextQuery, apiResponse) {\n  // If `nextQuery` is non-null, there are more results to fetch.\n  if (nextQuery) {\n    table.getRows(nextQuery, function(err, rows, nextQuery, apiResponse) {});\n  }\n});",
        "html": "<p>var options = {<br />  maxResults: 100<br />};</p><p>table.getRows(options, function(err, rows, nextQuery, apiResponse) {<br />  // If <code>nextQuery</code> is non-null, there are more results to fetch.<br />  if (nextQuery) {<br />    table.getRows(nextQuery, function(err, rows, nextQuery, apiResponse) {});<br />  }<br />});</p>"
      }
    ],
    "description": {
      "full": "<p>Retrieves table data from a specified set of rows. The rows are returned to<br />your callback as an array of objects matching your table&#39;s schema.</p>",
      "summary": "<p>Retrieves table data from a specified set of rows. The rows are returned to<br />your callback as an array of objects matching your table&#39;s schema.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 499,
    "codeStart": 519,
    "code": "Table.prototype.getRows = function(options, callback) {\n  var that = this;\n\n  if (util.is(options, 'function')) {\n    callback = options;\n    options = {};\n  }\n\n  callback = callback || util.noop;\n\n  this.makeReq_('GET', '/data', options, null, function(err, resp) {\n    if (err) {\n      onComplete(err, null, null, resp);\n      return;\n    }\n\n    var nextQuery = null;\n\n    if (resp.pageToken) {\n      nextQuery = extend({}, options, {\n        pageToken: resp.pageToken\n      });\n    }\n\n    if (resp.rows && resp.rows.length > 0 && !that.metadata.schema) {\n      // We don't know the schema for this table yet. Do a quick stat.\n      that.getMetadata(function(err) {\n        if (err) {\n          onComplete(err);\n          return;\n        }\n\n        onComplete(null, resp.rows, nextQuery, resp);\n      });\n\n      return;\n    }\n\n    onComplete(null, resp.rows, nextQuery, resp);\n  });\n\n  function onComplete(err, rows, nextQuery, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    rows = Table.mergeSchemaWithRows_(that.metadata.schema, rows || []);\n\n    callback(null, rows, nextQuery, resp);\n  }\n};",
    "ctx": {
      "type": "method",
      "constructor": "Table",
      "cons": "Table",
      "name": "getRows",
      "string": "Table.prototype.getRows()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{string|module:storage/file} source - The source file to import.",
        "name": "source",
        "description": "<ul>\n<li>The source file to import.</li>\n</ul>\n",
        "types": [
          "string",
          "module:storage/file"
        ],
        "typesDescription": "<code>string</code>|module:<a href=\"module%3Astorage%2Ffile.html\">storage/file</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{object=} metadata - Metadata to set with the load operation. The\n    metadata object should be in the format of the\n    [`configuration.load`](http://goo.gl/BVcXk4) property of a Jobs resource.",
        "name": "metadata",
        "description": "<ul>\n<li>Metadata to set with the load operation. The     metadata object should be in the format of the<br />  <a href=\"http://goo.gl/BVcXk4\"><code>configuration.load</code></a> property of a Jobs resource.</li>\n</ul>\n",
        "types": [
          "object"
        ],
        "typesDescription": "<code>object</code>|<code>undefined</code>",
        "optional": true,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{function} callback - The callback function.\n",
        "name": "callback",
        "description": "<ul>\n<li>The callback function. </li>\n</ul>\n",
        "types": [
          "function"
        ],
        "typesDescription": "<code>function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "throws",
        "string": "{Error} If the source isn't a string file name or a File instance.\n",
        "types": [
          "Error"
        ],
        "description": "<p>If the source isn&#39;t a string file name or a File instance. </p>"
      },
      {
        "type": "example",
        "string": "//-\n// Load data from a local file.\n//-\ntable.import('./institutions.csv', function(err, job, apiResponse) {});\n\n//-\n// You may also pass in metadata in the format of a Jobs resource. See\n// (http://goo.gl/BVcXk4) for a full list of supported values.\n//-\nvar metadata = {\n  encoding: 'ISO-8859-1',\n  sourceFormat: 'NEWLINE_DELIMITED_JSON'\n};\n\ntable.import('./my-data.csv', metadata, function(err, job, apiResponse) {});\n\n//-\n// Load data from a file in your Cloud Storage bucket.\n//-\nvar data = gcs.bucket('institutions').file('data.csv');\ntable.import(data, function(err, job, apiResponse) {});\n\n//-\n// Load data from multiple files in your Cloud Storage bucket(s).\n//-\ntable.import([\n  gcs.bucket('institutions').file('2011.csv'),\n  gcs.bucket('institutions').file('2012.csv')\n], function(err, job, apiResponse) {});",
        "html": "<p>//-<br />// Load data from a local file.<br />//-<br />table.import(&#39;./institutions.csv&#39;, function(err, job, apiResponse) {});</p><p>//-<br />// You may also pass in metadata in the format of a Jobs resource. See<br />// (<a href=\"http://goo.gl/BVcXk4\">http://goo.gl/BVcXk4</a>) for a full list of supported values.<br />//-<br />var metadata = {<br />  encoding: &#39;ISO-8859-1&#39;,<br />  sourceFormat: &#39;NEWLINE_DELIMITED_JSON&#39;<br />};</p><p>table.import(&#39;./my-data.csv&#39;, metadata, function(err, job, apiResponse) {});</p><p>//-<br />// Load data from a file in your Cloud Storage bucket.<br />//-<br />var data = gcs.bucket(&#39;institutions&#39;).file(&#39;data.csv&#39;);<br />table.import(data, function(err, job, apiResponse) {});</p><p>//-<br />// Load data from multiple files in your Cloud Storage bucket(s).<br />//-<br />table.import([<br />  gcs.bucket(&#39;institutions&#39;).file(&#39;2011.csv&#39;),<br />  gcs.bucket(&#39;institutions&#39;).file(&#39;2012.csv&#39;)<br />], function(err, job, apiResponse) {});</p>"
      }
    ],
    "description": {
      "full": "<p>Load data from a local file or Storage file ({module:storage/file}).</p><p>By loading data this way, you create a load job that will run your data load<br />asynchronously. If you would like instantaneous access to your data, insert<br />it using {module:bigquery/table#insert}.</p><p>Note: Only JSON and CSV source files are supported. The file type will be<br />inferred by the given file&#39;s extension. If you wish to override this, you<br />must provide a <code>metadata</code> object.</p>",
      "summary": "<p>Load data from a local file or Storage file ({module:storage/file}).</p>",
      "body": "<p>By loading data this way, you create a load job that will run your data load<br />asynchronously. If you would like instantaneous access to your data, insert<br />it using {module:bigquery/table#insert}.</p><p>Note: Only JSON and CSV source files are supported. The file type will be<br />inferred by the given file&#39;s extension. If you wish to override this, you<br />must provide a <code>metadata</code> object.</p>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 572,
    "codeStart": 622,
    "code": "Table.prototype.import = function(source, metadata, callback) {\n  var that = this;\n\n  if (util.is(metadata, 'function')) {\n    callback = metadata;\n    metadata = {};\n  }\n\n  callback = callback || util.noop;\n  metadata = metadata || {};\n\n  var formats = {\n    csv: 'CSV',\n    json: 'NEWLINE_DELIMITED_JSON'\n  };\n\n  if (util.is(source, 'string')) {\n    // A path to a file was given. If a sourceFormat wasn't specified, try to\n    // find a match from the file's extension.\n    var format = formats[path.extname(source).substr(1).toLowerCase()];\n    if (!metadata.sourceFormat && format) {\n      metadata.sourceFormat = format;\n    }\n\n    // Read the file into a new write stream.\n    return fs.createReadStream(source)\n      .pipe(this.createWriteStream(metadata))\n      .on('error', function(err, resp) {\n        callback(err, null, resp);\n      })\n      .on('complete', function(resp) {\n        // TODO(ryanseys): Does this have to create a job object?\n        callback(null, resp, resp);\n      });\n  }\n\n  var body = {\n    configuration: {\n      load: {\n        destinationTable: {\n          projectId: this.bigQuery.projectId,\n          datasetId: this.dataset.id,\n          tableId: this.id\n        }\n      }\n    }\n  };\n\n  extend(true, body.configuration.load, metadata, {\n    sourceUris: util.arrayize(source).map(function(src) {\n      if (!(src instanceof File)) {\n        throw new Error('Source must be a File object.');\n      }\n\n      // If no explicit format was provided, attempt to find a match from\n      // the file's extension. If no match, don't set, and default upstream\n      // to CSV.\n      var format = formats[path.extname(src.name).substr(1).toLowerCase()];\n      if (!metadata.sourceFormat && format) {\n        body.configuration.load.sourceFormat = format;\n      }\n\n      return 'gs://' + src.bucket.name + '/' + src.name;\n    })\n  });\n\n  this.bigQuery.makeReq_('POST', '/jobs', null, body, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var job = that.bigQuery.job(resp.jobReference.jobId);\n    job.metadata = resp;\n\n    callback(null, job, resp);\n  });\n};",
    "ctx": {
      "type": "method",
      "constructor": "Table",
      "cons": "Table",
      "name": "import",
      "string": "Table.prototype.import()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{object|object[]} rows - The rows to insert into the table.",
        "name": "rows",
        "description": "<ul>\n<li>The rows to insert into the table.</li>\n</ul>\n",
        "types": [
          "object",
          "Array.<object>"
        ],
        "typesDescription": "<code>object</code>|<code>Array</code>.&lt;<code>object</code>&gt;",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{function} callback - The callback function.\n",
        "name": "callback",
        "description": "<ul>\n<li>The callback function. </li>\n</ul>\n",
        "types": [
          "function"
        ],
        "typesDescription": "<code>function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "example",
        "string": "//-\n// Insert a single row.\n//-\ntable.insert({\n  INSTNM: 'Motion Picture Institute of Michigan',\n  CITY: 'Troy',\n  STABBR: 'MI'\n}, insertHandler);\n\n//-\n// Insert multiple rows at a time.\n//-\nvar rows = [\n  {\n    INSTNM: 'Motion Picture Institute of Michigan',\n    CITY: 'Troy',\n    STABBR: 'MI'\n  },\n  // ...\n];\n\ntable.insert(rows, insertHandler);\n\n//-\n// Handling the response.\n//-\nfunction insertHandler(err, insertErrors, apiResponse) {\n  // err (object):\n  //   An API error occurred.\n\n  // insertErrors (object[]):\n  //   If populated, some rows failed to insert, while others may have\n  //   succeeded.\n  //\n  // insertErrors[].row (original individual row object passed to `insert`)\n  // insertErrors[].errors[].reason\n  // insertErrors[].errors[].message\n\n  // See https://developers.google.com/bigquery/troubleshooting-errors for\n  // recommendations on handling errors.\n}",
        "html": "<p>//-<br />// Insert a single row.<br />//-<br />table.insert({<br />  INSTNM: &#39;Motion Picture Institute of Michigan&#39;,<br />  CITY: &#39;Troy&#39;,<br />  STABBR: &#39;MI&#39;<br />}, insertHandler);</p><p>//-<br />// Insert multiple rows at a time.<br />//-<br />var rows = [<br />  {<br />    INSTNM: &#39;Motion Picture Institute of Michigan&#39;,<br />    CITY: &#39;Troy&#39;,<br />    STABBR: &#39;MI&#39;<br />  },<br />  // ...<br />];</p><p>table.insert(rows, insertHandler);</p><p>//-<br />// Handling the response.<br />//-<br />function insertHandler(err, insertErrors, apiResponse) {<br />  // err (object):<br />  //   An API error occurred.</p><p>  // insertErrors (object[]):<br />  //   If populated, some rows failed to insert, while others may have<br />  //   succeeded.<br />  //<br />  // insertErrors[].row (original individual row object passed to <code>insert</code>)<br />  // insertErrors[].errors[].reason<br />  // insertErrors[].errors[].message</p><p>  // See <a href=\"https://developers.google.com/bigquery/troubleshooting-errors\">https://developers.google.com/bigquery/troubleshooting-errors</a> for<br />  // recommendations on handling errors.<br />}</p>"
      }
    ],
    "description": {
      "full": "<p>Stream data into BigQuery one record at a time without running a load job.</p><p>There are more strict quota limits using this method so it is highly<br />recommended that you load data into BigQuery using<br />{module:bigquery/table#import} instead.</p>",
      "summary": "<p>Stream data into BigQuery one record at a time without running a load job.</p>",
      "body": "<p>There are more strict quota limits using this method so it is highly<br />recommended that you load data into BigQuery using<br />{module:bigquery/table#import} instead.</p>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 701,
    "codeStart": 754,
    "code": "Table.prototype.insert = function(rows, callback) {\n  var body = {\n    rows: util.arrayize(rows || []).map(function(row) {\n      var rowObject = {};\n      // Use the stringified contents of the row as a unique insert ID.\n      var md5 = crypto.createHash('md5');\n      md5.update(JSON.stringify(row));\n      rowObject.insertId = md5.digest('hex');\n      rowObject.json = row;\n      return rowObject;\n    })\n  };\n\n  this.makeReq_('POST', '/insertAll', null, body, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var failedToInsert = (resp.insertErrors || []).map(function(insertError) {\n      return {\n        errors: insertError.errors.map(function(error) {\n          return {\n            message: error.message,\n            reason: error.reason\n          };\n        }),\n        row: body.rows[insertError.index].json\n      };\n    });\n\n    callback(null, failedToInsert, resp);\n  });\n};",
    "ctx": {
      "type": "method",
      "constructor": "Table",
      "cons": "Table",
      "name": "insert",
      "string": "Table.prototype.insert()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Run a query scoped to your dataset.</p><p>See {module:bigquery#query} for full documentation of this method.</p>",
      "summary": "<p>Run a query scoped to your dataset.</p>",
      "body": "<p>See {module:bigquery#query} for full documentation of this method.</p>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 789,
    "codeStart": 794,
    "code": "Table.prototype.query = function(query, callback) {\n  return this.dataset.query(query, callback);\n};",
    "ctx": {
      "type": "method",
      "constructor": "Table",
      "cons": "Table",
      "name": "query",
      "string": "Table.prototype.query()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{object} metadata - The metadata key/value object to set.",
        "name": "metadata",
        "description": "<ul>\n<li>The metadata key/value object to set.</li>\n</ul>\n",
        "types": [
          "object"
        ],
        "typesDescription": "<code>object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{string} metadata.description - A user-friendly description of the\n    table.",
        "name": "metadata.description",
        "description": "<ul>\n<li>A user-friendly description of the     table.</li>\n</ul>\n",
        "types": [
          "string"
        ],
        "typesDescription": "<code>string</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{string} metadata.name - A descriptive name for the table.",
        "name": "metadata.name",
        "description": "<ul>\n<li>A descriptive name for the table.</li>\n</ul>\n",
        "types": [
          "string"
        ],
        "typesDescription": "<code>string</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{string|object} metadata.schema - A comma-separated list of name:type\n    pairs. Valid types are \"string\", \"integer\", \"float\", \"boolean\", and\n    \"timestamp\". If the type is omitted, it is assumed to be \"string\".\n    Example: \"name:string, age:integer\". Schemas can also be specified as a\n    JSON array of fields, which allows for nested and repeated fields. See\n    a [Table resource](http://goo.gl/sl8Dmg) for more detailed information.",
        "name": "metadata.schema",
        "description": "<ul>\n<li>A comma-separated list of name:type     pairs. Valid types are &quot;string&quot;, &quot;integer&quot;, &quot;float&quot;, &quot;boolean&quot;, and<br />  &quot;timestamp&quot;. If the type is omitted, it is assumed to be &quot;string&quot;.<br />  Example: &quot;name:string, age:integer&quot;. Schemas can also be specified as a<br />  JSON array of fields, which allows for nested and repeated fields. See<br />  a <a href=\"http://goo.gl/sl8Dmg\">Table resource</a> for more detailed information.</li>\n</ul>\n",
        "types": [
          "string",
          "object"
        ],
        "typesDescription": "<code>string</code>|<code>object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{function} callback - The callback function.\n",
        "name": "callback",
        "description": "<ul>\n<li>The callback function. </li>\n</ul>\n",
        "types": [
          "function"
        ],
        "typesDescription": "<code>function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "example",
        "string": "var metadata = {\n  name: 'My recipes',\n  description: 'A table for storing my recipes.',\n  schema: 'name:string, servings:integer, cookingTime:float, quick:boolean'\n};\ntable.setMetadata(metadata, function(err, metadata, apiResponse) {});",
        "html": "<p>var metadata = {<br />  name: &#39;My recipes&#39;,<br />  description: &#39;A table for storing my recipes.&#39;,<br />  schema: &#39;name:string, servings:integer, cookingTime:float, quick:boolean&#39;<br />};<br />table.setMetadata(metadata, function(err, metadata, apiResponse) {});</p>"
      }
    ],
    "description": {
      "full": "<p>Set the metadata on the table.</p>",
      "summary": "<p>Set the metadata on the table.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 798,
    "codeStart": 821,
    "code": "Table.prototype.setMetadata = function(metadata, callback) {\n  var that = this;\n\n  if (metadata.name) {\n    metadata.friendlyName = metadata.name;\n    delete metadata.name;\n  }\n\n  if (util.is(metadata.schema, 'string')) {\n    metadata.schema = Table.createSchemaFromString_(metadata.schema);\n  }\n\n  this.makeReq_('PUT', '', null, metadata, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    that.metadata = resp;\n\n    callback(null, that.metadata, resp);\n  });\n};",
    "ctx": {
      "type": "method",
      "constructor": "Table",
      "cons": "Table",
      "name": "setMetadata",
      "string": "Table.prototype.setMetadata()"
    }
  },
  {
    "tags": [
      {
        "type": "private",
        "string": "\n",
        "visibility": "private",
        "html": ""
      },
      {
        "type": "param",
        "string": "{string} method - Action.",
        "name": "method",
        "description": "<ul>\n<li>Action.</li>\n</ul>\n",
        "types": [
          "string"
        ],
        "typesDescription": "<code>string</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{string} path - Request path.",
        "name": "path",
        "description": "<ul>\n<li>Request path.</li>\n</ul>\n",
        "types": [
          "string"
        ],
        "typesDescription": "<code>string</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{*} query - Request query object.",
        "name": "query",
        "description": "<ul>\n<li>Request query object.</li>\n</ul>\n",
        "types": [],
        "typesDescription": "<code>*</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{*} body - Request body contents.",
        "name": "body",
        "description": "<ul>\n<li>Request body contents.</li>\n</ul>\n",
        "types": [],
        "typesDescription": "<code>*</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{function} callback - The callback function.",
        "name": "callback",
        "description": "<ul>\n<li>The callback function.</li>\n</ul>\n",
        "types": [
          "function"
        ],
        "typesDescription": "<code>function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      }
    ],
    "description": {
      "full": "<p>Pass through this request to BigQuery&#39;s request handler, first prepending the<br />path with the dataset.</p>",
      "summary": "<p>Pass through this request to BigQuery&#39;s request handler, first prepending the<br />path with the dataset.</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 845,
    "codeStart": 857,
    "code": "Table.prototype.makeReq_ = function(method, path, query, body, callback) {\n  path = '/tables/' + this.id + path;\n  this.dataset.makeReq_(method, path, query, body, callback);\n};\n\nmodule.exports = Table;",
    "ctx": {
      "type": "method",
      "constructor": "Table",
      "cons": "Table",
      "name": "makeReq_",
      "string": "Table.prototype.makeReq_()"
    }
  }
]