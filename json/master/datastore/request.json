[
  {
    "tags": [],
    "description": {
      "full": "<p>Copyright 2014 Google Inc. All Rights Reserved.</p><p>Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);<br />you may not use this file except in compliance with the License.<br />You may obtain a copy of the License at</p><pre><code> http://www.apache.org/licenses/LICENSE-2.0\n</code></pre><p>Unless required by applicable law or agreed to in writing, software<br />distributed under the License is distributed on an &quot;AS IS&quot; BASIS,<br />WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<br />See the License for the specific language governing permissions and<br />limitations under the License.</p>",
      "summary": "<p>Copyright 2014 Google Inc. All Rights Reserved.</p>",
      "body": "<p>Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);<br />you may not use this file except in compliance with the License.<br />You may obtain a copy of the License at</p><pre><code> http://www.apache.org/licenses/LICENSE-2.0\n</code></pre><p>Unless required by applicable law or agreed to in writing, software<br />distributed under the License is distributed on an &quot;AS IS&quot; BASIS,<br />WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<br />See the License for the specific language governing permissions and<br />limitations under the License.</p>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 1,
    "codeStart": 16
  },
  {
    "tags": [
      {
        "type": "module",
        "string": "datastore/request",
        "html": "<p>datastore/request</p>"
      }
    ],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 17,
    "codeStart": 21,
    "code": "'use strict';\n\nvar arrify = require('arrify');\nvar concat = require('concat-stream');\nvar format = require('string-format-obj');\nvar is = require('is');\nvar propAssign = require('prop-assign');\nvar request = require('request').defaults({\n  pool: {\n    maxSockets: Infinity\n  }\n});\nvar split = require('split-array-stream');\nvar through = require('through2');\nvar extend = require('extend');",
    "ctx": false
  },
  {
    "tags": [
      {
        "type": "type",
        "string": "{module:datastore/entity}",
        "types": [
          "module:datastore/entity"
        ],
        "typesDescription": "module:<a href=\"module%3Adatastore%2Fentity.html\">datastore/entity</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{module:datastore/entity}</p>"
      },
      {
        "type": "private",
        "string": "",
        "visibility": "private",
        "html": ""
      }
    ],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 37,
    "codeStart": 41,
    "code": "var entity = require('./entity.js');",
    "ctx": {
      "type": "declaration",
      "name": "entity",
      "value": "require('./entity.js')",
      "string": "entity"
    }
  },
  {
    "tags": [
      {
        "type": "type",
        "string": "{module:datastore/pb}",
        "types": [
          "module:datastore/pb"
        ],
        "typesDescription": "module:<a href=\"module%3Adatastore%2Fpb.html\">datastore/pb</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{module:datastore/pb}</p>"
      },
      {
        "type": "private",
        "string": "",
        "visibility": "private",
        "html": ""
      }
    ],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 43,
    "codeStart": 47,
    "code": "var pb = require('./pb.js');",
    "ctx": {
      "type": "declaration",
      "name": "pb",
      "value": "require('./pb.js')",
      "string": "pb"
    }
  },
  {
    "tags": [
      {
        "type": "type",
        "string": "{module:datastore/query}",
        "types": [
          "module:datastore/query"
        ],
        "typesDescription": "module:<a href=\"module%3Adatastore%2Fquery.html\">datastore/query</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{module:datastore/query}</p>"
      },
      {
        "type": "private",
        "string": "",
        "visibility": "private",
        "html": ""
      }
    ],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 49,
    "codeStart": 53,
    "code": "var Query = require('./query');",
    "ctx": {
      "type": "declaration",
      "name": "Query",
      "value": "require('./query')",
      "string": "Query"
    }
  },
  {
    "tags": [
      {
        "type": "type",
        "string": "{module:common/streamrouter}",
        "types": [
          "module:common/streamrouter"
        ],
        "typesDescription": "module:<a href=\"module%3Acommon%2Fstreamrouter.html\">common/streamrouter</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{module:common/streamrouter}</p>"
      },
      {
        "type": "private",
        "string": "",
        "visibility": "private",
        "html": ""
      }
    ],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 55,
    "codeStart": 59,
    "code": "var streamRouter = require('../common/stream-router.js');",
    "ctx": {
      "type": "declaration",
      "name": "streamRouter",
      "value": "require('../common/stream-router.js')",
      "string": "streamRouter"
    }
  },
  {
    "tags": [
      {
        "type": "type",
        "string": "{module:common/util}",
        "types": [
          "module:common/util"
        ],
        "typesDescription": "module:<a href=\"module%3Acommon%2Futil.html\">common/util</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false,
        "html": "<p>{module:common/util}</p>"
      },
      {
        "type": "private",
        "string": "",
        "visibility": "private",
        "html": ""
      }
    ],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 61,
    "codeStart": 65,
    "code": "var util = require('../common/util.js');",
    "ctx": {
      "type": "declaration",
      "name": "util",
      "value": "require('../common/util.js')",
      "string": "util"
    }
  },
  {
    "tags": [
      {
        "type": "const",
        "string": "{string} Non-transaction mode key.",
        "html": "<p>{string} Non-transaction mode key.</p>"
      },
      {
        "type": "private",
        "string": "",
        "visibility": "private",
        "html": ""
      }
    ],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 67,
    "codeStart": 71,
    "code": "var MODE_NON_TRANSACTIONAL = 'NON_TRANSACTIONAL';",
    "ctx": {
      "type": "declaration",
      "name": "MODE_NON_TRANSACTIONAL",
      "value": "'NON_TRANSACTIONAL'",
      "string": "MODE_NON_TRANSACTIONAL"
    }
  },
  {
    "tags": [
      {
        "type": "const",
        "string": "{string} Transaction mode key.",
        "html": "<p>{string} Transaction mode key.</p>"
      },
      {
        "type": "private",
        "string": "",
        "visibility": "private",
        "html": ""
      }
    ],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 73,
    "codeStart": 77,
    "code": "var MODE_TRANSACTIONAL = 'TRANSACTIONAL';",
    "ctx": {
      "type": "declaration",
      "name": "MODE_TRANSACTIONAL",
      "value": "'TRANSACTIONAL'",
      "string": "MODE_TRANSACTIONAL"
    }
  },
  {
    "tags": [
      {
        "type": "example",
        "string": "// This is how to create a transaction object directly using this Transaction\n// class. The following transaction object is created for use in the examples\n// in this file below.\nvar dataset = gcloud.datastore.dataset({ projectId: 'project-id' });\nvar Transaction = require('gcloud/lib/datastore/transaction');\nvar transaction = new Transaction(dataset, 'my-project-id');\ntransaction.id = '1234'; // Give the transaction an ID.",
        "html": "<p>// This is how to create a transaction object directly using this Transaction<br />// class. The following transaction object is created for use in the examples<br />// in this file below.<br />var dataset = gcloud.datastore.dataset({ projectId: &#39;project-id&#39; });<br />var Transaction = require(&#39;gcloud/lib/datastore/transaction&#39;);<br />var transaction = new Transaction(dataset, &#39;my-project-id&#39;);<br />transaction.id = &#39;1234&#39;; // Give the transaction an ID.</p>"
      }
    ],
    "description": {
      "full": "<p>Developer Documentation</p><p>Handles request logic for Datastore.</p><p>Creates requests to the Dataset endpoint. Designed to be inherited by<br />datastore.Dataset and datastore.Transaction objects.</p>",
      "summary": "<p>Developer Documentation</p>",
      "body": "<p>Handles request logic for Datastore.</p><p>Creates requests to the Dataset endpoint. Designed to be inherited by<br />datastore.Dataset and datastore.Transaction objects.</p>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 79,
    "codeStart": 95
  },
  {
    "tags": [
      {
        "type": "constructor",
        "string": "",
        "html": ""
      },
      {
        "type": "alias",
        "string": "module:datastore/request",
        "html": "<p>module:datastore/request</p>"
      },
      {
        "type": "mixin",
        "string": "",
        "html": ""
      }
    ],
    "description": {
      "full": "<p>Handle logic for Datastore API operations.</p>",
      "summary": "<p>Handle logic for Datastore API operations.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": true,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 95,
    "codeStart": 102,
    "code": "function DatastoreRequest() {}",
    "ctx": {
      "type": "constructor",
      "name": "DatastoreRequest",
      "string": "DatastoreRequest()"
    }
  },
  {
    "tags": [
      {
        "type": "resource",
        "string": "[Datasets: lookup API Documentation]{@link https://cloud.google.com/datastore/docs/apis/v1beta2/datasets/lookup}",
        "html": "<p>[Datasets: lookup API Documentation]{@link <a href=\"https://cloud.google.com/datastore/docs/apis/v1beta2/datasets/lookup}\">https://cloud.google.com/datastore/docs/apis/v1beta2/datasets/lookup}</a></p>"
      },
      {
        "type": "throws",
        "string": "{Error} If at least one Key object is not provided.",
        "types": [
          "Error"
        ],
        "description": "<p>If at least one Key object is not provided.</p>"
      },
      {
        "type": "param",
        "string": "{Key|Key[]} keys - Datastore key object(s).",
        "name": "keys",
        "description": "<ul>\n<li>Datastore key object(s).</li>\n</ul>\n",
        "types": [
          "Key",
          "Array.<Key>"
        ],
        "typesDescription": "<a href=\"Key.html\">Key</a>|<code>Array</code>.&lt;<a href=\"Key.html\">Key</a>&gt;",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{function} callback - The callback function.",
        "name": "callback",
        "description": "<ul>\n<li>The callback function.</li>\n</ul>\n",
        "types": [
          "function"
        ],
        "typesDescription": "<code>function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{?error} callback.err - An error returned while making this request",
        "name": "callback.err",
        "description": "<ul>\n<li>An error returned while making this request</li>\n</ul>\n",
        "types": [
          "error"
        ],
        "typesDescription": "<code>error</code>|<code>null</code>",
        "optional": false,
        "nullable": true,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{module:datastore/entity|module:datastore/entity[]} callback.entity -\n    Will return either a single Entity or a list of Entities.",
        "name": "callback.entity",
        "description": "<ul>\n<li>Will return either a single Entity or a list of Entities.</li>\n</ul>\n",
        "types": [
          "module:datastore/entity",
          "Array.<module:datastore/entity>"
        ],
        "typesDescription": "module:<a href=\"module%3Adatastore%2Fentity.html\">datastore/entity</a>|<code>Array</code>.&lt;module:<a href=\"module%3Adatastore%2Fentity.html\">datastore/entity</a>&gt;",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "example",
        "string": "//-\n// Get a single entity.\n//-\nvar key = dataset.key(['Company', 123]);\n\ndataset.get(key, function(err, entity) {});\n\n//-\n// Or, if you're using a transaction object.\n//-\n\ntransaction.get(key, function(err, entity) {});\n\n//-\n// Get multiple entities at once with a callback.\n//-\nvar keys = [\n  dataset.key(['Company', 123]),\n  dataset.key(['Product', 'Computer'])\n];\n\ndataset.get(keys, function(err, entities) {});\n\n//-\n// Or, get the entities as a readable object stream.\n//-\ndataset.get(keys)\n  .on('error', function(err) {})\n  .on('data', function(entity) {\n    // entity is an entity object.\n  })\n  .on('end', function() {\n    // All entities retrieved.\n  });\n\n//-\n// Here's how you would update the value of an entity with the help of the\n// `save` method.\n//-\ndataset.get(key, function(err, entity) {\n  if (err) {\n    // Error handling omitted.\n  }\n\n  entity.data.newValue = true;\n  dataset.save(entity, function(err) {});\n});",
        "html": "<p>//-<br />// Get a single entity.<br />//-<br />var key = dataset.key([&#39;Company&#39;, 123]);</p><p>dataset.get(key, function(err, entity) {});</p><p>//-<br />// Or, if you&#39;re using a transaction object.<br />//-</p><p>transaction.get(key, function(err, entity) {});</p><p>//-<br />// Get multiple entities at once with a callback.<br />//-<br />var keys = [<br />  dataset.key([&#39;Company&#39;, 123]),<br />  dataset.key([&#39;Product&#39;, &#39;Computer&#39;])<br />];</p><p>dataset.get(keys, function(err, entities) {});</p><p>//-<br />// Or, get the entities as a readable object stream.<br />//-<br />dataset.get(keys)<br />  .on(&#39;error&#39;, function(err) {})<br />  .on(&#39;data&#39;, function(entity) {<br />    // entity is an entity object.<br />  })<br />  .on(&#39;end&#39;, function() {<br />    // All entities retrieved.<br />  });</p><p>//-<br />// Here&#39;s how you would update the value of an entity with the help of the<br />// <code>save</code> method.<br />//-<br />dataset.get(key, function(err, entity) {<br />  if (err) {<br />    // Error handling omitted.<br />  }</p><p>  entity.data.newValue = true;<br />  dataset.save(entity, function(err) {});<br />});</p>"
      }
    ],
    "description": {
      "full": "<p>Retrieve the entities identified with the specified key(s) in the current<br />transaction. Get operations require a valid key to retrieve the<br />key-identified entity from Datastore.</p>",
      "summary": "<p>Retrieve the entities identified with the specified key(s) in the current<br />transaction. Get operations require a valid key to retrieve the<br />key-identified entity from Datastore.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 104,
    "codeStart": 168,
    "code": "DatastoreRequest.prototype.get = function(keys, callback) {\n  if (is.fn(callback)) {\n    // Run this method in stream mode and send the results back to the callback.\n    this.get(keys)\n      .on('error', callback)\n      .pipe(concat(function(results) {\n        var isSingleLookup = !is.array(keys);\n        callback(null, isSingleLookup ? results[0] : results);\n      }));\n    return;\n  }\n\n  keys = arrify(keys).map(entity.keyToKeyProto);\n\n  if (keys.length === 0) {\n    throw new Error('At least one Key object is required.');\n  }\n\n  var self = this;\n  var stream = through.obj();\n\n  function onApiResponse(err, resp) {\n    if (err) {\n      stream.destroy(err);\n      return;\n    }\n\n    var entities = entity.formatArray(resp.found);\n    var nextKeys = (resp.deferred || []).map(entity.keyFromKeyProto);\n\n    split(entities, stream, function(streamEnded) {\n      if (streamEnded) {\n        return;\n      }\n\n      if (nextKeys.length > 0) {\n        self.get(nextKeys, onApiResponse);\n        return;\n      }\n\n      stream.push(null);\n    });\n  }\n\n  this.makeReq_('lookup', { key: keys }, onApiResponse);\n\n  return stream;\n};",
    "ctx": {
      "type": "method",
      "constructor": "DatastoreRequest",
      "cons": "DatastoreRequest",
      "name": "get",
      "string": "DatastoreRequest.prototype.get()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Maps to {module:datastore/dataset#save}, forcing the method to be <code>insert</code>.</p>",
      "summary": "<p>Maps to {module:datastore/dataset#save}, forcing the method to be <code>insert</code>.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 217,
    "codeStart": 220,
    "code": "DatastoreRequest.prototype.insert = function(entities, callback) {\n  entities = arrify(entities).map(propAssign('method', 'insert'));\n  this.save(entities, callback);\n};",
    "ctx": {
      "type": "method",
      "constructor": "DatastoreRequest",
      "cons": "DatastoreRequest",
      "name": "insert",
      "string": "DatastoreRequest.prototype.insert()"
    }
  },
  {
    "tags": [
      {
        "type": "resource",
        "string": "[Datasets: commit API Documentation]{@link https://cloud.google.com/datastore/docs/apis/v1beta2/datasets/commit}",
        "html": "<p>[Datasets: commit API Documentation]{@link <a href=\"https://cloud.google.com/datastore/docs/apis/v1beta2/datasets/commit}\">https://cloud.google.com/datastore/docs/apis/v1beta2/datasets/commit}</a></p>"
      },
      {
        "type": "borrows",
        "string": "{module:datastore/transaction#save} as save",
        "otherMemberName": "{module:datastore/transaction#save}",
        "thisMemberName": "save",
        "html": "<p>{module:datastore/transaction#save} as save</p>"
      },
      {
        "type": "throws",
        "string": "{Error} If an unrecognized method is provided.",
        "types": [
          "Error"
        ],
        "description": "<p>If an unrecognized method is provided.</p>"
      },
      {
        "type": "param",
        "string": "{object|object[]} entities - Datastore key object(s).",
        "name": "entities",
        "description": "<ul>\n<li>Datastore key object(s).</li>\n</ul>\n",
        "types": [
          "object",
          "Array.<object>"
        ],
        "typesDescription": "<code>object</code>|<code>Array</code>.&lt;<code>object</code>&gt;",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{Key} entities.key - Datastore key object.",
        "name": "entities.key",
        "description": "<ul>\n<li>Datastore key object.</li>\n</ul>\n",
        "types": [
          "Key"
        ],
        "typesDescription": "<a href=\"Key.html\">Key</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{string=} entities.method - Optional method to explicity use for save.\n    The choices include 'insert', 'update', 'upsert' and 'insert_auto_id'.",
        "name": "entities.method",
        "description": "<ul>\n<li>Optional method to explicity use for save.     The choices include &#39;insert&#39;, &#39;update&#39;, &#39;upsert&#39; and &#39;insert_auto_id&#39;.</li>\n</ul>\n",
        "types": [
          "string"
        ],
        "typesDescription": "<code>string</code>|<code>undefined</code>",
        "optional": true,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{object|object[]} entities.data - Data to save with the provided key.\n    If you provide an array of objects, you must use the explicit syntax:\n    `name` for the name of the property and `value` for its value. You may\n    also specify an `excludeFromIndexes` property, set to `true` or `false`.",
        "name": "entities.data",
        "description": "<ul>\n<li>Data to save with the provided key.     If you provide an array of objects, you must use the explicit syntax:<br />  <code>name</code> for the name of the property and <code>value</code> for its value. You may<br />  also specify an <code>excludeFromIndexes</code> property, set to <code>true</code> or <code>false</code>.</li>\n</ul>\n",
        "types": [
          "object",
          "Array.<object>"
        ],
        "typesDescription": "<code>object</code>|<code>Array</code>.&lt;<code>object</code>&gt;",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{function} callback - The callback function.",
        "name": "callback",
        "description": "<ul>\n<li>The callback function.</li>\n</ul>\n",
        "types": [
          "function"
        ],
        "typesDescription": "<code>function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{?error} callback.err - An error returned while making this request",
        "name": "callback.err",
        "description": "<ul>\n<li>An error returned while making this request</li>\n</ul>\n",
        "types": [
          "error"
        ],
        "typesDescription": "<code>error</code>|<code>null</code>",
        "optional": false,
        "nullable": true,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{object} callback.apiResponse - The full API response.",
        "name": "callback.apiResponse",
        "description": "<ul>\n<li>The full API response.</li>\n</ul>\n",
        "types": [
          "object"
        ],
        "typesDescription": "<code>object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "example",
        "string": "//-\n// Save a single entity.\n//\n// Notice that we are providing an incomplete key. After saving, the original\n// Key object used to save will be updated to contain the path with its\n// generated ID.\n//-\nvar key = dataset.key('Company');\n\ndataset.save({\n  key: key,\n  data: {\n    rating: '10'\n  }\n}, function(err) {\n  console.log(key.path); // [ 'Company', 5669468231434240 ]\n  console.log(key.namespace); // undefined\n});\n\n//-\n// Save a single entity using a provided name instead of auto-generated ID.\n//\n// Here we are providing a key with name instead of an ID. After saving, the\n// original Key object used to save will be updated to contain the path with\n// the name instead of a generated ID.\n//-\nvar key = dataset.key(['Company', 'donutshack']);\n\ndataset.save({\n  key: key,\n  data: {\n    name: 'DonutShack',\n    rating: 8\n  }\n}, function(err) {\n  console.log(key.path); // ['Company', 'donutshack']\n  console.log(key.namespace); // undefined\n});\n\n//-\n// Save a single entity with a provided namespace. Namespaces allow for\n// multitenancy. To read more about this, see\n// [the Datastore docs on key concepts](https://goo.gl/M1LUAu).\n//\n// Here we are providing a key with namespace.\n//-\nvar key = dataset.key({\n  namespace: 'my-namespace',\n  path: ['Company', 'donutshack']\n});\n\ndataset.save({\n  key: key,\n  data: {\n    name: 'DonutShack',\n    rating: 8\n  }\n}, function(err) {\n  console.log(key.path); // ['Company', 'donutshack']\n  console.log(key.namespace); // 'my-namespace'\n});\n\n//-\n// Save different types of data, including ints, doubles, dates, booleans,\n// blobs, and lists.\n//\n// Notice that we are providing an incomplete key. After saving, the original\n// Key object used to save will be updated to contain the path with its\n// generated ID.\n//-\nvar key = dataset.key('Company');\n\ndataset.save({\n  key: key,\n  data: {\n    name: 'DonutShack', // strings\n    rating: gcloud.datastore.int(8), // ints\n    worth: gcloud.datastore.double(123456.78), // doubles\n    numDonutsServed: 45, // detect number type (int or double)\n    founded: new Date('Tue May 12 2015 15:30:00 GMT-0400 (EDT)'), // dates\n    isStartup: true, // booleans\n    donutEmoji: new Buffer('\\uD83C\\uDF69'), // buffers\n    keywords: [ 'donut', 'coffee', 'yum' ] // lists of objects\n  }\n}, function(err) {});\n\n//-\n// To specify an `excludeFromIndexes` value for a Datastore entity, pass in\n// an array for the key's data. The above example would then look like:\n//-\ndataset.save({\n  key: dataset.key('Company'),\n  data: [\n    {\n      name: 'rating',\n      value: '10',\n      excludeFromIndexes: false\n    }\n  ]\n}, function(err) {});\n\n//-\n// Save multiple entities at once.\n//-\nvar companyKey = dataset.key(['Company', 123]);\nvar productKey = dataset.key(['Product', 'Computer']);\n\ndataset.save([\n  {\n    key: companyKey,\n    data: {\n      HQ: 'Dallas, TX'\n    }\n  },\n  {\n    key: productKey,\n    data: {\n      vendor: 'Dell'\n    }\n  }\n], function(err) {});\n\n//-\n// Explicitly attempt to 'insert' a specific entity.\n//-\nvar userKey = dataset.key(['User', 'chilts']);\n\ndataset.save([\n  {\n    key: userKey,\n    method: 'insert', // force the method to 'insert'\n    data: {\n      fullName: 'Andrew Chilton'\n    }\n  }\n], function(err, apiResponse) {});",
        "html": "<p>//-<br />// Save a single entity.<br />//<br />// Notice that we are providing an incomplete key. After saving, the original<br />// Key object used to save will be updated to contain the path with its<br />// generated ID.<br />//-<br />var key = dataset.key(&#39;Company&#39;);</p><p>dataset.save({<br />  key: key,<br />  data: {<br />    rating: &#39;10&#39;<br />  }<br />}, function(err) {<br />  console.log(key.path); // [ &#39;Company&#39;, 5669468231434240 ]<br />  console.log(key.namespace); // undefined<br />});</p><p>//-<br />// Save a single entity using a provided name instead of auto-generated ID.<br />//<br />// Here we are providing a key with name instead of an ID. After saving, the<br />// original Key object used to save will be updated to contain the path with<br />// the name instead of a generated ID.<br />//-<br />var key = dataset.key([&#39;Company&#39;, &#39;donutshack&#39;]);</p><p>dataset.save({<br />  key: key,<br />  data: {<br />    name: &#39;DonutShack&#39;,<br />    rating: 8<br />  }<br />}, function(err) {<br />  console.log(key.path); // [&#39;Company&#39;, &#39;donutshack&#39;]<br />  console.log(key.namespace); // undefined<br />});</p><p>//-<br />// Save a single entity with a provided namespace. Namespaces allow for<br />// multitenancy. To read more about this, see<br />// <a href=\"https://goo.gl/M1LUAu\">the Datastore docs on key concepts</a>.<br />//<br />// Here we are providing a key with namespace.<br />//-<br />var key = dataset.key({<br />  namespace: &#39;my-namespace&#39;,<br />  path: [&#39;Company&#39;, &#39;donutshack&#39;]<br />});</p><p>dataset.save({<br />  key: key,<br />  data: {<br />    name: &#39;DonutShack&#39;,<br />    rating: 8<br />  }<br />}, function(err) {<br />  console.log(key.path); // [&#39;Company&#39;, &#39;donutshack&#39;]<br />  console.log(key.namespace); // &#39;my-namespace&#39;<br />});</p><p>//-<br />// Save different types of data, including ints, doubles, dates, booleans,<br />// blobs, and lists.<br />//<br />// Notice that we are providing an incomplete key. After saving, the original<br />// Key object used to save will be updated to contain the path with its<br />// generated ID.<br />//-<br />var key = dataset.key(&#39;Company&#39;);</p><p>dataset.save({<br />  key: key,<br />  data: {<br />    name: &#39;DonutShack&#39;, // strings<br />    rating: gcloud.datastore.int(8), // ints<br />    worth: gcloud.datastore.double(123456.78), // doubles<br />    numDonutsServed: 45, // detect number type (int or double)<br />    founded: new Date(&#39;Tue May 12 2015 15:30:00 GMT-0400 (EDT)&#39;), // dates<br />    isStartup: true, // booleans<br />    donutEmoji: new Buffer(&#39;\\uD83C\\uDF69&#39;), // buffers<br />    keywords: [ &#39;donut&#39;, &#39;coffee&#39;, &#39;yum&#39; ] // lists of objects<br />  }<br />}, function(err) {});</p><p>//-<br />// To specify an <code>excludeFromIndexes</code> value for a Datastore entity, pass in<br />// an array for the key&#39;s data. The above example would then look like:<br />//-<br />dataset.save({<br />  key: dataset.key(&#39;Company&#39;),<br />  data: [<br />    {<br />      name: &#39;rating&#39;,<br />      value: &#39;10&#39;,<br />      excludeFromIndexes: false<br />    }<br />  ]<br />}, function(err) {});</p><p>//-<br />// Save multiple entities at once.<br />//-<br />var companyKey = dataset.key([&#39;Company&#39;, 123]);<br />var productKey = dataset.key([&#39;Product&#39;, &#39;Computer&#39;]);</p><p>dataset.save([<br />  {<br />    key: companyKey,<br />    data: {<br />      HQ: &#39;Dallas, TX&#39;<br />    }<br />  },<br />  {<br />    key: productKey,<br />    data: {<br />      vendor: &#39;Dell&#39;<br />    }<br />  }<br />], function(err) {});</p><p>//-<br />// Explicitly attempt to &#39;insert&#39; a specific entity.<br />//-<br />var userKey = dataset.key([&#39;User&#39;, &#39;chilts&#39;]);</p><p>dataset.save([<br />  {<br />    key: userKey,<br />    method: &#39;insert&#39;, // force the method to &#39;insert&#39;<br />    data: {<br />      fullName: &#39;Andrew Chilton&#39;<br />    }<br />  }<br />], function(err, apiResponse) {});</p>"
      }
    ],
    "description": {
      "full": "<p>Insert or update the specified object(s). If a key is incomplete, its<br />associated object is inserted and the original Key object is updated to<br />contain the generated ID.</p><p>This method will determine the correct Datastore method to execute (<code>upsert</code>,<br /><code>insert</code>, <code>update</code>, and <code>insertAutoId</code>) by using the key(s) provided. For<br />example, if you provide an incomplete key (one without an ID), the request<br />will create a new entity and have its ID automatically assigned. If you<br />provide a complete key, the entity will be updated with the data specified.</p><p>By default, all properties are indexed. To prevent a property from being<br />included in <em>all</em> indexes, you must supply an entity&#39;s <code>data</code> property as an<br />array. See below for an example.</p>",
      "summary": "<p>Insert or update the specified object(s). If a key is incomplete, its<br />associated object is inserted and the original Key object is updated to<br />contain the generated ID.</p>",
      "body": "<p>This method will determine the correct Datastore method to execute (<code>upsert</code>,<br /><code>insert</code>, <code>update</code>, and <code>insertAutoId</code>) by using the key(s) provided. For<br />example, if you provide an incomplete key (one without an ID), the request<br />will create a new entity and have its ID automatically assigned. If you<br />provide a complete key, the entity will be updated with the data specified.</p><p>By default, all properties are indexed. To prevent a property from being<br />included in <em>all</em> indexes, you must supply an entity&#39;s <code>data</code> property as an<br />array. See below for an example.</p>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 225,
    "codeStart": 396,
    "code": "DatastoreRequest.prototype.save = function(entities, callback) {\n  entities = arrify(entities);\n\n  var insertIndexes = [];\n\n  var mutation = {\n    insert: [],\n    update: [],\n    upsert: [],\n    insert_auto_id: []\n  };\n\n  // Iterate over the entity objects, build a proto from all keys and values,\n  // then place in the correct mutation array (insert, update, etc).\n  entities.forEach(function(entityObject, index) {\n    entityObject = extend(true, {}, entityObject);\n\n    var entityProto = {};\n    var method = entityObject.method;\n\n    if (is.array(entityObject.data)) {\n      entityProto.property = entityObject.data.map(function(data) {\n        data.value = entity.valueToProperty(data.value);\n\n        if (is.boolean(data.excludeFromIndexes)) {\n          var indexed = !data.excludeFromIndexes;\n\n          if (is.array(data.value.list_value)) {\n            data.value.list_value =\n              data.value.list_value.map(propAssign('indexed', indexed));\n          } else {\n            data.value.indexed = indexed;\n          }\n\n          delete data.excludeFromIndexes;\n        }\n\n        return data;\n      });\n    } else {\n      entityProto = entity.entityToEntityProto(entityObject.data);\n    }\n\n    entityProto.key = entity.keyToKeyProto(entityObject.key);\n\n    if (method) {\n      if (mutation[method]) {\n        mutation[method].push(entityProto);\n\n        if (method === 'insert_auto_id') {\n          insertIndexes.push(index);\n        }\n      } else {\n        throw new Error('Method ' + method + ' not recognized.');\n      }\n    } else {\n      if (entity.isKeyComplete(entityObject.key)) {\n        mutation.upsert.push(entityProto);\n      } else {\n        insertIndexes.push(index);\n        mutation.insert_auto_id.push(entityProto);\n      }\n    }\n  });\n\n  var req = {\n    mutation: mutation\n  };\n\n  if (this.id) {\n    this.requests_.push(req);\n    this.requestCallbacks_.push(onCommit);\n    return;\n  } else {\n    this.makeReq_('commit', req, onCommit);\n  }\n\n  function onCommit(err, resp) {\n    if (err || !resp) {\n      callback(err, resp);\n      return;\n    }\n\n    var autoInserted = (resp.mutation_result.insert_auto_id_key || []);\n    autoInserted.forEach(function(key, index) {\n      var path = entity.keyFromKeyProto(key).path;\n      entities[insertIndexes[index]].key.path = path;\n    });\n\n    callback(null, resp);\n  }\n};",
    "ctx": {
      "type": "method",
      "constructor": "DatastoreRequest",
      "cons": "DatastoreRequest",
      "name": "save",
      "string": "DatastoreRequest.prototype.save()"
    }
  },
  {
    "tags": [
      {
        "type": "resource",
        "string": "[Datasets: commit API Documentation]{@link https://cloud.google.com/datastore/docs/apis/v1beta2/datasets/commit#mutation.delete}",
        "html": "<p>[Datasets: commit API Documentation]{@link <a href=\"https://cloud.google.com/datastore/docs/apis/v1beta2/datasets/commit#mutation.delete}\">https://cloud.google.com/datastore/docs/apis/v1beta2/datasets/commit#mutation.delete}</a></p>"
      },
      {
        "type": "param",
        "string": "{Key|Key[]} key - Datastore key object(s).",
        "name": "key",
        "description": "<ul>\n<li>Datastore key object(s).</li>\n</ul>\n",
        "types": [
          "Key",
          "Array.<Key>"
        ],
        "typesDescription": "<a href=\"Key.html\">Key</a>|<code>Array</code>.&lt;<a href=\"Key.html\">Key</a>&gt;",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{function} callback - The callback function.",
        "name": "callback",
        "description": "<ul>\n<li>The callback function.</li>\n</ul>\n",
        "types": [
          "function"
        ],
        "typesDescription": "<code>function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{?error} callback.err - An error returned while making this request",
        "name": "callback.err",
        "description": "<ul>\n<li>An error returned while making this request</li>\n</ul>\n",
        "types": [
          "error"
        ],
        "typesDescription": "<code>error</code>|<code>null</code>",
        "optional": false,
        "nullable": true,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{object} callback.apiResponse - The full API response.",
        "name": "callback.apiResponse",
        "description": "<ul>\n<li>The full API response.</li>\n</ul>\n",
        "types": [
          "object"
        ],
        "typesDescription": "<code>object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "example",
        "string": "dataset.delete(dataset.key(['Company', 123]), function(err, apiResp) {});\n\n//-\n// Or, if you're using a transaction object.\n//-\n\ntransaction.delete(dataset.key(['Company', 123]), function(err, apiResp) {});\n\n//-\n// Delete multiple entities at once.\n//-\ndataset.delete([\n  dataset.key(['Company', 123]),\n  dataset.key(['Product', 'Computer'])\n], function(err, apiResponse) {});",
        "html": "<p>dataset.delete(dataset.key([&#39;Company&#39;, 123]), function(err, apiResp) {});</p><p>//-<br />// Or, if you&#39;re using a transaction object.<br />//-</p><p>transaction.delete(dataset.key([&#39;Company&#39;, 123]), function(err, apiResp) {});</p><p>//-<br />// Delete multiple entities at once.<br />//-<br />dataset.delete([<br />  dataset.key([&#39;Company&#39;, 123]),<br />  dataset.key([&#39;Product&#39;, &#39;Computer&#39;])<br />], function(err, apiResponse) {});</p>"
      }
    ],
    "description": {
      "full": "<p>Delete all entities identified with the specified key(s).</p>",
      "summary": "<p>Delete all entities identified with the specified key(s).</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 489,
    "codeStart": 516,
    "code": "DatastoreRequest.prototype.delete = function(keys, callback) {\n  callback = callback || util.noop;\n\n  var req = {\n    mutation: {\n      delete: arrify(keys).map(entity.keyToKeyProto)\n    }\n  };\n\n  if (this.id) {\n    this.requests_.push(req);\n    return;\n  }\n\n  this.makeReq_('commit', req, callback);\n};",
    "ctx": {
      "type": "method",
      "constructor": "DatastoreRequest",
      "cons": "DatastoreRequest",
      "name": "delete",
      "string": "DatastoreRequest.prototype.delete()"
    }
  },
  {
    "tags": [
      {
        "type": "resource",
        "string": "[Datasets: runQuery API Documentation]{@link https://cloud.google.com/datastore/docs/apis/v1beta2/datasets/runQuery}",
        "html": "<p>[Datasets: runQuery API Documentation]{@link <a href=\"https://cloud.google.com/datastore/docs/apis/v1beta2/datasets/runQuery}\">https://cloud.google.com/datastore/docs/apis/v1beta2/datasets/runQuery}</a></p>"
      },
      {
        "type": "param",
        "string": "{module:datastore/query} q - Query object.",
        "name": "q",
        "description": "<ul>\n<li>Query object.</li>\n</ul>\n",
        "types": [
          "module:datastore/query"
        ],
        "typesDescription": "module:<a href=\"module%3Adatastore%2Fquery.html\">datastore/query</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{function=} callback - The callback function. If omitted, a readable\n    stream instance is returned.",
        "name": "callback",
        "description": "<ul>\n<li>The callback function. If omitted, a readable     stream instance is returned.</li>\n</ul>\n",
        "types": [
          "function"
        ],
        "typesDescription": "<code>function</code>|<code>undefined</code>",
        "optional": true,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{?error} callback.err - An error returned while making this request\n    (may be null).",
        "name": "callback.err",
        "description": "<ul>\n<li>An error returned while making this request     (may be null).</li>\n</ul>\n",
        "types": [
          "error"
        ],
        "typesDescription": "<code>error</code>|<code>null</code>",
        "optional": false,
        "nullable": true,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{array} callback.entities - The list of entities returned by this\n    query. Note that this is a single page of entities, not necessarily\n    all of the entities.",
        "name": "callback.entities",
        "description": "<ul>\n<li>The list of entities returned by this     query. Note that this is a single page of entities, not necessarily<br />  all of the entities.</li>\n</ul>\n",
        "types": [
          "array"
        ],
        "typesDescription": "<code>array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{?module:datastore/query} callback.nextQuery - If present, run another\n    query with this object to check for more results.",
        "name": "callback.nextQuery",
        "description": "<ul>\n<li>If present, run another     query with this object to check for more results.</li>\n</ul>\n",
        "types": [
          "module:datastore/query"
        ],
        "typesDescription": "module:<a href=\"module%3Adatastore%2Fquery.html\">datastore/query</a>|<code>null</code>",
        "optional": false,
        "nullable": true,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{object} callback.apiResponse - The full API response.",
        "name": "callback.apiResponse",
        "description": "<ul>\n<li>The full API response.</li>\n</ul>\n",
        "types": [
          "object"
        ],
        "typesDescription": "<code>object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{?error} callback.err - An error returned while making this request",
        "name": "callback.err",
        "description": "<ul>\n<li>An error returned while making this request</li>\n</ul>\n",
        "types": [
          "error"
        ],
        "typesDescription": "<code>error</code>|<code>null</code>",
        "optional": false,
        "nullable": true,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{module:datastore/entity[]} callback.entities - A list of Entities",
        "name": "callback.entities",
        "description": "<ul>\n<li>A list of Entities</li>\n</ul>\n",
        "types": [
          "Array.<module:datastore/entity>"
        ],
        "typesDescription": "<code>Array</code>.&lt;module:<a href=\"module%3Adatastore%2Fentity.html\">datastore/entity</a>&gt;",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{?object} callback.nextQuery - If present, query with this object to\n    check for more results.",
        "name": "callback.nextQuery",
        "description": "<ul>\n<li>If present, query with this object to     check for more results.</li>\n</ul>\n",
        "types": [
          "object"
        ],
        "typesDescription": "<code>object</code>|<code>null</code>",
        "optional": false,
        "nullable": true,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{object} callback.apiResponse - The full API response.",
        "name": "callback.apiResponse",
        "description": "<ul>\n<li>The full API response.</li>\n</ul>\n",
        "types": [
          "object"
        ],
        "typesDescription": "<code>object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "example",
        "string": "//-\n// Where you see `transaction`, assume this is the context that's relevant to\n// your use, whether that be a Dataset or a Transaction object.\n//-\nvar query = dataset.createQuery('Lion');\n\ndataset.runQuery(query, function(err, entities) {});\n\n//-\n// Or, if you're using a transaction object.\n//-\n\ntransaction.runQuery(query, function(err, entities) {});\n\n//-\n// To control how many API requests are made and page through the results\n// manually, call `autoPaginate(false)` on your query.\n//-\nvar manualPageQuery = dataset.createQuery('Lion').autoPaginate(false);\n\nvar callback = function(err, entities, nextQuery, apiResponse) {\n  if (nextQuery) {\n    // More results might exist.\n    transaction.runQuery(nextQuery, callback);\n  }\n};\n\ndataset.runQuery(manualPageQuery, callback);\n\n//-\n// If you omit the callback, runQuery will automatically call subsequent\n// queries until no results remain. Entity objects will be pushed as they are\n// found.\n//-\ndataset.runQuery(query)\n  .on('error', console.error)\n  .on('data', function (entity) {})\n  .on('end', function() {\n    // All entities retrieved.\n  });\n\n//-\n// A keys-only query returns just the keys of the result entities instead of\n// the entities themselves, at lower latency and cost.\n//-\nvar keysOnlyQuery = dataset.createQuery('Lion').select('__key__');\n\ndataset.runQuery(keysOnlyQuery, function(err, entities) {\n  // entities[].key = Key object\n  // entities[].data = Empty object\n});",
        "html": "<p>//-<br />// Where you see <code>transaction</code>, assume this is the context that&#39;s relevant to<br />// your use, whether that be a Dataset or a Transaction object.<br />//-<br />var query = dataset.createQuery(&#39;Lion&#39;);</p><p>dataset.runQuery(query, function(err, entities) {});</p><p>//-<br />// Or, if you&#39;re using a transaction object.<br />//-</p><p>transaction.runQuery(query, function(err, entities) {});</p><p>//-<br />// To control how many API requests are made and page through the results<br />// manually, call <code>autoPaginate(false)</code> on your query.<br />//-<br />var manualPageQuery = dataset.createQuery(&#39;Lion&#39;).autoPaginate(false);</p><p>var callback = function(err, entities, nextQuery, apiResponse) {<br />  if (nextQuery) {<br />    // More results might exist.<br />    transaction.runQuery(nextQuery, callback);<br />  }<br />};</p><p>dataset.runQuery(manualPageQuery, callback);</p><p>//-<br />// If you omit the callback, runQuery will automatically call subsequent<br />// queries until no results remain. Entity objects will be pushed as they are<br />// found.<br />//-<br />dataset.runQuery(query)<br />  .on(&#39;error&#39;, console.error)<br />  .on(&#39;data&#39;, function (entity) {})<br />  .on(&#39;end&#39;, function() {<br />    // All entities retrieved.<br />  });</p><p>//-<br />// A keys-only query returns just the keys of the result entities instead of<br />// the entities themselves, at lower latency and cost.<br />//-<br />var keysOnlyQuery = dataset.createQuery(&#39;Lion&#39;).select(&#39;<strong>key</strong>&#39;);</p><p>dataset.runQuery(keysOnlyQuery, function(err, entities) {<br />  // entities[].key = Key object<br />  // entities[].data = Empty object<br />});</p>"
      }
    ],
    "description": {
      "full": "<p>Datastore allows you to query entities by kind, filter them by property<br />filters, and sort them by a property name. Projection and pagination are also<br />supported.</p><p>If you provide a callback, the query is run, and the results are returned as<br />the second argument to your callback. A third argument may also exist, which<br />is a query object that uses the end cursor from the previous query as the<br />starting cursor for the next query. You can pass that object back to this<br />method to see if more results exist.</p><p>You may also omit the callback to this function to trigger streaming mode.</p><p>See below for examples of both approaches.</p>",
      "summary": "<p>Datastore allows you to query entities by kind, filter them by property<br />filters, and sort them by a property name. Projection and pagination are also<br />supported.</p>",
      "body": "<p>If you provide a callback, the query is run, and the results are returned as<br />the second argument to your callback. A third argument may also exist, which<br />is a query object that uses the end cursor from the previous query as the<br />starting cursor for the next query. You can pass that object back to this<br />method to see if more results exist.</p><p>You may also omit the callback to this function to trigger streaming mode.</p><p>See below for examples of both approaches.</p>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 533,
    "codeStart": 620,
    "code": "DatastoreRequest.prototype.runQuery = function(query, callback) {\n  var req = {\n    read_options: {},\n    query: entity.queryToQueryProto(query)\n  };\n\n  if (query.namespace) {\n    req.partition_id = {\n      namespace: query.namespace\n    };\n  }\n\n  this.makeReq_('runQuery', req, function(err, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    var entities = entity.formatArray(resp.batch.entity_result);\n    var nextQuery = null;\n\n    if (resp.batch.end_cursor && entities.length > 0) {\n      var endCursor = resp.batch.end_cursor.toBase64();\n\n      nextQuery = extend(true, new Query(), query);\n      nextQuery.start(endCursor).offset(0);\n    }\n\n    callback(null, entities, nextQuery, resp);\n  });\n};",
    "ctx": {
      "type": "method",
      "constructor": "DatastoreRequest",
      "cons": "DatastoreRequest",
      "name": "runQuery",
      "string": "DatastoreRequest.prototype.runQuery()"
    }
  },
  {
    "tags": [
      {
        "type": "resource",
        "string": "[Datasets: allocateIds API Documentation]{@link https://cloud.google.com/datastore/docs/apis/v1beta2/datasets/allocateIds}",
        "html": "<p>[Datasets: allocateIds API Documentation]{@link <a href=\"https://cloud.google.com/datastore/docs/apis/v1beta2/datasets/allocateIds}\">https://cloud.google.com/datastore/docs/apis/v1beta2/datasets/allocateIds}</a></p>"
      },
      {
        "type": "param",
        "string": "{Key} incompleteKey - The key object to complete.",
        "name": "incompleteKey",
        "description": "<ul>\n<li>The key object to complete.</li>\n</ul>\n",
        "types": [
          "Key"
        ],
        "typesDescription": "<a href=\"Key.html\">Key</a>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{number} n - How many IDs to generate.",
        "name": "n",
        "description": "<ul>\n<li>How many IDs to generate.</li>\n</ul>\n",
        "types": [
          "number"
        ],
        "typesDescription": "<code>number</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{function} callback - The callback function.",
        "name": "callback",
        "description": "<ul>\n<li>The callback function.</li>\n</ul>\n",
        "types": [
          "function"
        ],
        "typesDescription": "<code>function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{?error} callback.err - An error returned while making this request",
        "name": "callback.err",
        "description": "<ul>\n<li>An error returned while making this request</li>\n</ul>\n",
        "types": [
          "error"
        ],
        "typesDescription": "<code>error</code>|<code>null</code>",
        "optional": false,
        "nullable": true,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{array} callback.keys - The generated IDs",
        "name": "callback.keys",
        "description": "<ul>\n<li>The generated IDs</li>\n</ul>\n",
        "types": [
          "array"
        ],
        "typesDescription": "<code>array</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{object} callback.apiResponse - The full API response.",
        "name": "callback.apiResponse",
        "description": "<ul>\n<li>The full API response.</li>\n</ul>\n",
        "types": [
          "object"
        ],
        "typesDescription": "<code>object</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "example",
        "string": "var incompleteKey = dataset.key(['Company']);\n\n// The following call will create 100 new IDs from the Company kind, which\n// exists under the default namespace.\ndataset.allocateIds(incompleteKey, 100, function(err, keys) {});\n\n//-\n// Or, if you're using a transaction object.\n//-\n\ntransaction.allocateIds(incompleteKey, 100, function(err, keys) {});\n\n// You may prefer to create IDs from a non-default namespace by providing an\n// incomplete key with a namespace. Similar to the previous example, the call\n// below will create 100 new IDs, but from the Company kind that exists under\n// the \"ns-test\" namespace.\nvar incompleteKey = dataset.key({\n  namespace: 'ns-test',\n  path: ['Company']\n});\nvar callback = function(err, keys, apiResponse) {};\ndataset.allocateIds(incompleteKey, 100, callback);",
        "html": "<p>var incompleteKey = dataset.key([&#39;Company&#39;]);</p><p>// The following call will create 100 new IDs from the Company kind, which<br />// exists under the default namespace.<br />dataset.allocateIds(incompleteKey, 100, function(err, keys) {});</p><p>//-<br />// Or, if you&#39;re using a transaction object.<br />//-</p><p>transaction.allocateIds(incompleteKey, 100, function(err, keys) {});</p><p>// You may prefer to create IDs from a non-default namespace by providing an<br />// incomplete key with a namespace. Similar to the previous example, the call<br />// below will create 100 new IDs, but from the Company kind that exists under<br />// the &quot;ns-test&quot; namespace.<br />var incompleteKey = dataset.key({<br />  namespace: &#39;ns-test&#39;,<br />  path: [&#39;Company&#39;]<br />});<br />var callback = function(err, keys, apiResponse) {};<br />dataset.allocateIds(incompleteKey, 100, callback);</p>"
      }
    ],
    "description": {
      "full": "<p>Generate IDs without creating entities.</p>",
      "summary": "<p>Generate IDs without creating entities.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 652,
    "codeStart": 688,
    "code": "DatastoreRequest.prototype.allocateIds = function(incompleteKey, n, callback) {\n  if (entity.isKeyComplete(incompleteKey)) {\n    throw new Error('An incomplete key should be provided.');\n  }\n\n  var incompleteKeys = [];\n  for (var i = 0; i < n; i++) {\n    incompleteKeys.push(entity.keyToKeyProto(incompleteKey));\n  }\n\n  var req = {\n    key: incompleteKeys\n  };\n\n  this.makeReq_('allocateIds', req, function(err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var keys = (resp.key || []).map(entity.keyFromKeyProto);\n\n    callback(null, keys, resp);\n  });\n};",
    "ctx": {
      "type": "method",
      "constructor": "DatastoreRequest",
      "cons": "DatastoreRequest",
      "name": "allocateIds",
      "string": "DatastoreRequest.prototype.allocateIds()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Maps to {module:datastore/dataset#save}, forcing the method to be <code>update</code>.</p>",
      "summary": "<p>Maps to {module:datastore/dataset#save}, forcing the method to be <code>update</code>.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 714,
    "codeStart": 717,
    "code": "DatastoreRequest.prototype.update = function(entities, callback) {\n  entities = arrify(entities).map(propAssign('method', 'update'));\n  this.save(entities, callback);\n};",
    "ctx": {
      "type": "method",
      "constructor": "DatastoreRequest",
      "cons": "DatastoreRequest",
      "name": "update",
      "string": "DatastoreRequest.prototype.update()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Maps to {module:datastore/dataset#save}, forcing the method to be <code>upsert</code>.</p>",
      "summary": "<p>Maps to {module:datastore/dataset#save}, forcing the method to be <code>upsert</code>.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 722,
    "codeStart": 725,
    "code": "DatastoreRequest.prototype.upsert = function(entities, callback) {\n  entities = arrify(entities).map(propAssign('method', 'upsert'));\n  this.save(entities, callback);\n};",
    "ctx": {
      "type": "method",
      "constructor": "DatastoreRequest",
      "cons": "DatastoreRequest",
      "name": "upsert",
      "string": "DatastoreRequest.prototype.upsert()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "string": "{string} method - Datastore action (allocateIds, commit, etc.).",
        "name": "method",
        "description": "<ul>\n<li>Datastore action (allocateIds, commit, etc.).</li>\n</ul>\n",
        "types": [
          "string"
        ],
        "typesDescription": "<code>string</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{object=} body - Request configuration object.",
        "name": "body",
        "description": "<ul>\n<li>Request configuration object.</li>\n</ul>\n",
        "types": [
          "object"
        ],
        "typesDescription": "<code>object</code>|<code>undefined</code>",
        "optional": true,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "param",
        "string": "{function} callback - The callback function.",
        "name": "callback",
        "description": "<ul>\n<li>The callback function.</li>\n</ul>\n",
        "types": [
          "function"
        ],
        "typesDescription": "<code>function</code>",
        "optional": false,
        "nullable": false,
        "nonNullable": false,
        "variable": false
      },
      {
        "type": "private",
        "string": "",
        "visibility": "private",
        "html": ""
      },
      {
        "type": "example",
        "string": "var deleteRequest = {\n  mutation: {\n    delete: [] // datastore key objects.\n  }\n};\n\nvar dataset = gcloud.datastore.dataset({ projectId: 'project-id' });\nvar callback = function(err, result, apiResponse) {};\nvar Transaction = require('gcloud/lib/datastore/transaction');\nvar transaction = new Transaction(dataset, 'my-project-id');\ntransaction.makeReq_('commit', deleteRequest, callback);",
        "html": "<p>var deleteRequest = {<br />  mutation: {<br />    delete: [] // datastore key objects.<br />  }<br />};</p><p>var dataset = gcloud.datastore.dataset({ projectId: &#39;project-id&#39; });<br />var callback = function(err, result, apiResponse) {};<br />var Transaction = require(&#39;gcloud/lib/datastore/transaction&#39;);<br />var transaction = new Transaction(dataset, &#39;my-project-id&#39;);<br />transaction.makeReq_(&#39;commit&#39;, deleteRequest, callback);</p>"
      }
    ],
    "description": {
      "full": "<p>Make a request to the API endpoint. Properties to indicate a transactional or<br />non-transactional operation are added automatically.</p>",
      "summary": "<p>Make a request to the API endpoint. Properties to indicate a transactional or<br />non-transactional operation are added automatically.</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": false,
    "line": 730,
    "codeStart": 753,
    "code": "DatastoreRequest.prototype.makeReq_ = function(method, body, callback) {\n  // TODO: Handle non-HTTP 200 cases.\n  if (!callback) {\n    callback = body;\n    body = {};\n  }\n\n  callback = callback || util.noop;\n\n  // Set properties to indicate if we're in a transaction or not.\n  if (method === 'commit') {\n    if (this.id) {\n      body.mode = MODE_TRANSACTIONAL;\n      body.transaction = this.id;\n    } else {\n      body.mode = MODE_NON_TRANSACTIONAL;\n    }\n  }\n\n  if (method === 'rollback') {\n    body.transaction = this.id;\n  }\n\n  if (this.id && (method === 'lookup' || method === 'runQuery')) {\n    body.read_options = body.read_options || {};\n    body.read_options.transaction = this.id;\n  }\n\n  var pbKey = method[0].toUpperCase() + method.substr(1);\n  var pbRequest = new pb[pbKey + 'Request'](body).toBuffer();\n  var pbResponse = pb[pbKey + 'Response'];\n\n  var reqOpts = {\n    method: 'POST',\n    uri: format('{apiEndpoint}/{path}/{projectId}/{method}', {\n      apiEndpoint: this.apiEndpoint,\n      path: 'datastore/v1beta2/datasets',\n      projectId: this.projectId,\n      method: method\n    }),\n    body: is.empty(body) ? '' : pbRequest,\n    encoding: null,\n    headers: {\n      'Content-Type': 'application/x-protobuf'\n    }\n  };\n\n  this.makeAuthenticatedRequest_(reqOpts, {\n    onAuthenticated: function(err, authenticatedReqOpts) {\n      if (err) {\n        callback(err, null);\n        return;\n      }\n\n      request(authenticatedReqOpts, function(err, resp, body) {\n        if (err) {\n          callback(err, null);\n          return;\n        }\n\n        var parsedResp = util.parseHttpRespMessage(resp);\n\n        if (parsedResp.err) {\n          callback(parsedResp.err, null, parsedResp.resp);\n          return;\n        }\n\n        var parsedBody = util.parseHttpRespBody(pbResponse.decode(body));\n\n        if (parsedBody.err) {\n          callback(parsedBody.err, null, parsedResp.resp);\n          return;\n        }\n\n        callback(null, parsedBody.body, resp);\n      });\n    }\n  });\n};",
    "ctx": {
      "type": "method",
      "constructor": "DatastoreRequest",
      "cons": "DatastoreRequest",
      "name": "makeReq_",
      "string": "DatastoreRequest.prototype.makeReq_()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Developer Documentation</p><p>This method can be used with either a callback or as a readable object<br />stream. <code>streamRouter</code> is used to add this dual behavior.</p>",
      "summary": "<p>Developer Documentation</p>",
      "body": "<p>This method can be used with either a callback or as a readable object<br />stream. <code>streamRouter</code> is used to add this dual behavior.</p>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "isClass": false,
    "isEvent": false,
    "ignore": true,
    "line": 833,
    "codeStart": 838,
    "code": "streamRouter.extend(DatastoreRequest, 'runQuery');\n\nmodule.exports = DatastoreRequest;",
    "ctx": false
  }
]