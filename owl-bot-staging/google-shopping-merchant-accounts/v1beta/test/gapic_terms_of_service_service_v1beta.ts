// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// ** This file is automatically generated by gapic-generator-typescript. **
// ** https://github.com/googleapis/gapic-generator-typescript **
// ** All changes to this file may be overwritten. **

import * as protos from '../protos/protos';
import * as assert from 'assert';
import * as sinon from 'sinon';
import {SinonStub} from 'sinon';
import {describe, it} from 'mocha';
import * as termsofserviceserviceModule from '../src';

import {protobuf} from 'google-gax';

// Dynamically loaded proto JSON is needed to get the type information
// to fill in default values for request objects
const root = protobuf.Root.fromJSON(require('../protos/protos.json')).resolveAll();

// eslint-disable-next-line @typescript-eslint/no-unused-vars
function getTypeDefaultValue(typeName: string, fields: string[]) {
    let type = root.lookupType(typeName) as protobuf.Type;
    for (const field of fields.slice(0, -1)) {
        type = type.fields[field]?.resolvedType as protobuf.Type;
    }
    return type.fields[fields[fields.length - 1]]?.defaultValue;
}

function generateSampleMessage<T extends object>(instance: T) {
    const filledObject = (instance.constructor as typeof protobuf.Message)
        .toObject(instance as protobuf.Message<T>, {defaults: true});
    return (instance.constructor as typeof protobuf.Message).fromObject(filledObject) as T;
}

function stubSimpleCall<ResponseType>(response?: ResponseType, error?: Error) {
    return error ? sinon.stub().rejects(error) : sinon.stub().resolves([response]);
}

function stubSimpleCallWithCallback<ResponseType>(response?: ResponseType, error?: Error) {
    return error ? sinon.stub().callsArgWith(2, error) : sinon.stub().callsArgWith(2, null, response);
}

describe('v1beta.TermsOfServiceServiceClient', () => {
    describe('Common methods', () => {
        it('has apiEndpoint', () => {
            const client = new termsofserviceserviceModule.v1beta.TermsOfServiceServiceClient();
            const apiEndpoint = client.apiEndpoint;
            assert.strictEqual(apiEndpoint, 'merchantapi.googleapis.com');
        });

        it('has universeDomain', () => {
            const client = new termsofserviceserviceModule.v1beta.TermsOfServiceServiceClient();
            const universeDomain = client.universeDomain;
            assert.strictEqual(universeDomain, "googleapis.com");
        });

        if (typeof process === 'object' && typeof process.emitWarning === 'function') {
            it('throws DeprecationWarning if static servicePath is used', () => {
                const stub = sinon.stub(process, 'emitWarning');
                const servicePath = termsofserviceserviceModule.v1beta.TermsOfServiceServiceClient.servicePath;
                assert.strictEqual(servicePath, 'merchantapi.googleapis.com');
                assert(stub.called);
                stub.restore();
            });

            it('throws DeprecationWarning if static apiEndpoint is used', () => {
                const stub = sinon.stub(process, 'emitWarning');
                const apiEndpoint = termsofserviceserviceModule.v1beta.TermsOfServiceServiceClient.apiEndpoint;
                assert.strictEqual(apiEndpoint, 'merchantapi.googleapis.com');
                assert(stub.called);
                stub.restore();
            });
        }
        it('sets apiEndpoint according to universe domain camelCase', () => {
            const client = new termsofserviceserviceModule.v1beta.TermsOfServiceServiceClient({universeDomain: 'example.com'});
            const servicePath = client.apiEndpoint;
            assert.strictEqual(servicePath, 'merchantapi.example.com');
        });

        it('sets apiEndpoint according to universe domain snakeCase', () => {
            const client = new termsofserviceserviceModule.v1beta.TermsOfServiceServiceClient({universe_domain: 'example.com'});
            const servicePath = client.apiEndpoint;
            assert.strictEqual(servicePath, 'merchantapi.example.com');
        });

        if (typeof process === 'object' && 'env' in process) {
            describe('GOOGLE_CLOUD_UNIVERSE_DOMAIN environment variable', () => {
                it('sets apiEndpoint from environment variable', () => {
                    const saved = process.env['GOOGLE_CLOUD_UNIVERSE_DOMAIN'];
                    process.env['GOOGLE_CLOUD_UNIVERSE_DOMAIN'] = 'example.com';
                    const client = new termsofserviceserviceModule.v1beta.TermsOfServiceServiceClient();
                    const servicePath = client.apiEndpoint;
                    assert.strictEqual(servicePath, 'merchantapi.example.com');
                    if (saved) {
                        process.env['GOOGLE_CLOUD_UNIVERSE_DOMAIN'] = saved;
                    } else {
                        delete process.env['GOOGLE_CLOUD_UNIVERSE_DOMAIN'];
                    }
                });

                it('value configured in code has priority over environment variable', () => {
                    const saved = process.env['GOOGLE_CLOUD_UNIVERSE_DOMAIN'];
                    process.env['GOOGLE_CLOUD_UNIVERSE_DOMAIN'] = 'example.com';
                    const client = new termsofserviceserviceModule.v1beta.TermsOfServiceServiceClient({universeDomain: 'configured.example.com'});
                    const servicePath = client.apiEndpoint;
                    assert.strictEqual(servicePath, 'merchantapi.configured.example.com');
                    if (saved) {
                        process.env['GOOGLE_CLOUD_UNIVERSE_DOMAIN'] = saved;
                    } else {
                        delete process.env['GOOGLE_CLOUD_UNIVERSE_DOMAIN'];
                    }
                });
            });
        }
        it('does not allow setting both universeDomain and universe_domain', () => {
            assert.throws(() => { new termsofserviceserviceModule.v1beta.TermsOfServiceServiceClient({universe_domain: 'example.com', universeDomain: 'example.net'}); });
        });

        it('has port', () => {
            const port = termsofserviceserviceModule.v1beta.TermsOfServiceServiceClient.port;
            assert(port);
            assert(typeof port === 'number');
        });

        it('should create a client with no option', () => {
            const client = new termsofserviceserviceModule.v1beta.TermsOfServiceServiceClient();
            assert(client);
        });

        it('should create a client with gRPC fallback', () => {
            const client = new termsofserviceserviceModule.v1beta.TermsOfServiceServiceClient({
                fallback: true,
            });
            assert(client);
        });

        it('has initialize method and supports deferred initialization', async () => {
            const client = new termsofserviceserviceModule.v1beta.TermsOfServiceServiceClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            assert.strictEqual(client.termsOfServiceServiceStub, undefined);
            await client.initialize();
            assert(client.termsOfServiceServiceStub);
        });

        it('has close method for the initialized client', done => {
            const client = new termsofserviceserviceModule.v1beta.TermsOfServiceServiceClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            client.initialize().catch(err => {throw err});
            assert(client.termsOfServiceServiceStub);
            client.close().then(() => {
                done();
            }).catch(err => {throw err});
        });

        it('has close method for the non-initialized client', done => {
            const client = new termsofserviceserviceModule.v1beta.TermsOfServiceServiceClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            assert.strictEqual(client.termsOfServiceServiceStub, undefined);
            client.close().then(() => {
                done();
            }).catch(err => {throw err});
        });

        it('has getProjectId method', async () => {
            const fakeProjectId = 'fake-project-id';
            const client = new termsofserviceserviceModule.v1beta.TermsOfServiceServiceClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            client.auth.getProjectId = sinon.stub().resolves(fakeProjectId);
            const result = await client.getProjectId();
            assert.strictEqual(result, fakeProjectId);
            assert((client.auth.getProjectId as SinonStub).calledWithExactly());
        });

        it('has getProjectId method with callback', async () => {
            const fakeProjectId = 'fake-project-id';
            const client = new termsofserviceserviceModule.v1beta.TermsOfServiceServiceClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            client.auth.getProjectId = sinon.stub().callsArgWith(0, null, fakeProjectId);
            const promise = new Promise((resolve, reject) => {
                client.getProjectId((err?: Error|null, projectId?: string|null) => {
                    if (err) {
                        reject(err);
                    } else {
                        resolve(projectId);
                    }
                });
            });
            const result = await promise;
            assert.strictEqual(result, fakeProjectId);
        });
    });

    describe('getTermsOfService', () => {
        it('invokes getTermsOfService without error', async () => {
            const client = new termsofserviceserviceModule.v1beta.TermsOfServiceServiceClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.shopping.merchant.accounts.v1beta.GetTermsOfServiceRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.shopping.merchant.accounts.v1beta.GetTermsOfServiceRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.shopping.merchant.accounts.v1beta.TermsOfService()
            );
            client.innerApiCalls.getTermsOfService = stubSimpleCall(expectedResponse);
            const [response] = await client.getTermsOfService(request);
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.getTermsOfService as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.getTermsOfService as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes getTermsOfService without error using callback', async () => {
            const client = new termsofserviceserviceModule.v1beta.TermsOfServiceServiceClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.shopping.merchant.accounts.v1beta.GetTermsOfServiceRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.shopping.merchant.accounts.v1beta.GetTermsOfServiceRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.shopping.merchant.accounts.v1beta.TermsOfService()
            );
            client.innerApiCalls.getTermsOfService = stubSimpleCallWithCallback(expectedResponse);
            const promise = new Promise((resolve, reject) => {
                 client.getTermsOfService(
                    request,
                    (err?: Error|null, result?: protos.google.shopping.merchant.accounts.v1beta.ITermsOfService|null) => {
                        if (err) {
                            reject(err);
                        } else {
                            resolve(result);
                        }
                    });
            });
            const response = await promise;
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.getTermsOfService as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.getTermsOfService as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes getTermsOfService with error', async () => {
            const client = new termsofserviceserviceModule.v1beta.TermsOfServiceServiceClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.shopping.merchant.accounts.v1beta.GetTermsOfServiceRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.shopping.merchant.accounts.v1beta.GetTermsOfServiceRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedError = new Error('expected');
            client.innerApiCalls.getTermsOfService = stubSimpleCall(undefined, expectedError);
            await assert.rejects(client.getTermsOfService(request), expectedError);
            const actualRequest = (client.innerApiCalls.getTermsOfService as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.getTermsOfService as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes getTermsOfService with closed client', async () => {
            const client = new termsofserviceserviceModule.v1beta.TermsOfServiceServiceClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.shopping.merchant.accounts.v1beta.GetTermsOfServiceRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.shopping.merchant.accounts.v1beta.GetTermsOfServiceRequest', ['name']);
            request.name = defaultValue1;
            const expectedError = new Error('The client has already been closed.');
            client.close().catch(err => {throw err});
            await assert.rejects(client.getTermsOfService(request), expectedError);
        });
    });

    describe('retrieveLatestTermsOfService', () => {
        it('invokes retrieveLatestTermsOfService without error', async () => {
            const client = new termsofserviceserviceModule.v1beta.TermsOfServiceServiceClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.shopping.merchant.accounts.v1beta.RetrieveLatestTermsOfServiceRequest()
            );
            const expectedResponse = generateSampleMessage(
              new protos.google.shopping.merchant.accounts.v1beta.TermsOfService()
            );
            client.innerApiCalls.retrieveLatestTermsOfService = stubSimpleCall(expectedResponse);
            const [response] = await client.retrieveLatestTermsOfService(request);
            assert.deepStrictEqual(response, expectedResponse);
        });

        it('invokes retrieveLatestTermsOfService without error using callback', async () => {
            const client = new termsofserviceserviceModule.v1beta.TermsOfServiceServiceClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.shopping.merchant.accounts.v1beta.RetrieveLatestTermsOfServiceRequest()
            );
            const expectedResponse = generateSampleMessage(
              new protos.google.shopping.merchant.accounts.v1beta.TermsOfService()
            );
            client.innerApiCalls.retrieveLatestTermsOfService = stubSimpleCallWithCallback(expectedResponse);
            const promise = new Promise((resolve, reject) => {
                 client.retrieveLatestTermsOfService(
                    request,
                    (err?: Error|null, result?: protos.google.shopping.merchant.accounts.v1beta.ITermsOfService|null) => {
                        if (err) {
                            reject(err);
                        } else {
                            resolve(result);
                        }
                    });
            });
            const response = await promise;
            assert.deepStrictEqual(response, expectedResponse);
        });

        it('invokes retrieveLatestTermsOfService with error', async () => {
            const client = new termsofserviceserviceModule.v1beta.TermsOfServiceServiceClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.shopping.merchant.accounts.v1beta.RetrieveLatestTermsOfServiceRequest()
            );
            const expectedError = new Error('expected');
            client.innerApiCalls.retrieveLatestTermsOfService = stubSimpleCall(undefined, expectedError);
            await assert.rejects(client.retrieveLatestTermsOfService(request), expectedError);
        });

        it('invokes retrieveLatestTermsOfService with closed client', async () => {
            const client = new termsofserviceserviceModule.v1beta.TermsOfServiceServiceClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.shopping.merchant.accounts.v1beta.RetrieveLatestTermsOfServiceRequest()
            );
            const expectedError = new Error('The client has already been closed.');
            client.close().catch(err => {throw err});
            await assert.rejects(client.retrieveLatestTermsOfService(request), expectedError);
        });
    });

    describe('acceptTermsOfService', () => {
        it('invokes acceptTermsOfService without error', async () => {
            const client = new termsofserviceserviceModule.v1beta.TermsOfServiceServiceClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.shopping.merchant.accounts.v1beta.AcceptTermsOfServiceRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.shopping.merchant.accounts.v1beta.AcceptTermsOfServiceRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.protobuf.Empty()
            );
            client.innerApiCalls.acceptTermsOfService = stubSimpleCall(expectedResponse);
            const [response] = await client.acceptTermsOfService(request);
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.acceptTermsOfService as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.acceptTermsOfService as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes acceptTermsOfService without error using callback', async () => {
            const client = new termsofserviceserviceModule.v1beta.TermsOfServiceServiceClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.shopping.merchant.accounts.v1beta.AcceptTermsOfServiceRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.shopping.merchant.accounts.v1beta.AcceptTermsOfServiceRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedResponse = generateSampleMessage(
              new protos.google.protobuf.Empty()
            );
            client.innerApiCalls.acceptTermsOfService = stubSimpleCallWithCallback(expectedResponse);
            const promise = new Promise((resolve, reject) => {
                 client.acceptTermsOfService(
                    request,
                    (err?: Error|null, result?: protos.google.protobuf.IEmpty|null) => {
                        if (err) {
                            reject(err);
                        } else {
                            resolve(result);
                        }
                    });
            });
            const response = await promise;
            assert.deepStrictEqual(response, expectedResponse);
            const actualRequest = (client.innerApiCalls.acceptTermsOfService as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.acceptTermsOfService as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes acceptTermsOfService with error', async () => {
            const client = new termsofserviceserviceModule.v1beta.TermsOfServiceServiceClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.shopping.merchant.accounts.v1beta.AcceptTermsOfServiceRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.shopping.merchant.accounts.v1beta.AcceptTermsOfServiceRequest', ['name']);
            request.name = defaultValue1;
            const expectedHeaderRequestParams = `name=${defaultValue1 ?? '' }`;
            const expectedError = new Error('expected');
            client.innerApiCalls.acceptTermsOfService = stubSimpleCall(undefined, expectedError);
            await assert.rejects(client.acceptTermsOfService(request), expectedError);
            const actualRequest = (client.innerApiCalls.acceptTermsOfService as SinonStub)
                .getCall(0).args[0];
            assert.deepStrictEqual(actualRequest, request);
            const actualHeaderRequestParams = (client.innerApiCalls.acceptTermsOfService as SinonStub)
                .getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
            assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
        });

        it('invokes acceptTermsOfService with closed client', async () => {
            const client = new termsofserviceserviceModule.v1beta.TermsOfServiceServiceClient({
              credentials: {client_email: 'bogus', private_key: 'bogus'},
              projectId: 'bogus',
            });
            await client.initialize();
            const request = generateSampleMessage(
              new protos.google.shopping.merchant.accounts.v1beta.AcceptTermsOfServiceRequest()
            );
            const defaultValue1 =
              getTypeDefaultValue('.google.shopping.merchant.accounts.v1beta.AcceptTermsOfServiceRequest', ['name']);
            request.name = defaultValue1;
            const expectedError = new Error('The client has already been closed.');
            client.close().catch(err => {throw err});
            await assert.rejects(client.acceptTermsOfService(request), expectedError);
        });
    });

    describe('Path templates', () => {

        describe('account', async () => {
            const fakePath = "/rendered/path/account";
            const expectedParameters = {
                account: "accountValue",
            };
            const client = new termsofserviceserviceModule.v1beta.TermsOfServiceServiceClient({
                credentials: {client_email: 'bogus', private_key: 'bogus'},
                projectId: 'bogus',
            });
            await client.initialize();
            client.pathTemplates.accountPathTemplate.render =
                sinon.stub().returns(fakePath);
            client.pathTemplates.accountPathTemplate.match =
                sinon.stub().returns(expectedParameters);

            it('accountPath', () => {
                const result = client.accountPath("accountValue");
                assert.strictEqual(result, fakePath);
                assert((client.pathTemplates.accountPathTemplate.render as SinonStub)
                    .getCall(-1).calledWith(expectedParameters));
            });

            it('matchAccountFromAccountName', () => {
                const result = client.matchAccountFromAccountName(fakePath);
                assert.strictEqual(result, "accountValue");
                assert((client.pathTemplates.accountPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });
        });

        describe('accountIssue', async () => {
            const fakePath = "/rendered/path/accountIssue";
            const expectedParameters = {
                account: "accountValue",
                issue: "issueValue",
            };
            const client = new termsofserviceserviceModule.v1beta.TermsOfServiceServiceClient({
                credentials: {client_email: 'bogus', private_key: 'bogus'},
                projectId: 'bogus',
            });
            await client.initialize();
            client.pathTemplates.accountIssuePathTemplate.render =
                sinon.stub().returns(fakePath);
            client.pathTemplates.accountIssuePathTemplate.match =
                sinon.stub().returns(expectedParameters);

            it('accountIssuePath', () => {
                const result = client.accountIssuePath("accountValue", "issueValue");
                assert.strictEqual(result, fakePath);
                assert((client.pathTemplates.accountIssuePathTemplate.render as SinonStub)
                    .getCall(-1).calledWith(expectedParameters));
            });

            it('matchAccountFromAccountIssueName', () => {
                const result = client.matchAccountFromAccountIssueName(fakePath);
                assert.strictEqual(result, "accountValue");
                assert((client.pathTemplates.accountIssuePathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchIssueFromAccountIssueName', () => {
                const result = client.matchIssueFromAccountIssueName(fakePath);
                assert.strictEqual(result, "issueValue");
                assert((client.pathTemplates.accountIssuePathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });
        });

        describe('accountTax', async () => {
            const fakePath = "/rendered/path/accountTax";
            const expectedParameters = {
                account: "accountValue",
                tax: "taxValue",
            };
            const client = new termsofserviceserviceModule.v1beta.TermsOfServiceServiceClient({
                credentials: {client_email: 'bogus', private_key: 'bogus'},
                projectId: 'bogus',
            });
            await client.initialize();
            client.pathTemplates.accountTaxPathTemplate.render =
                sinon.stub().returns(fakePath);
            client.pathTemplates.accountTaxPathTemplate.match =
                sinon.stub().returns(expectedParameters);

            it('accountTaxPath', () => {
                const result = client.accountTaxPath("accountValue", "taxValue");
                assert.strictEqual(result, fakePath);
                assert((client.pathTemplates.accountTaxPathTemplate.render as SinonStub)
                    .getCall(-1).calledWith(expectedParameters));
            });

            it('matchAccountFromAccountTaxName', () => {
                const result = client.matchAccountFromAccountTaxName(fakePath);
                assert.strictEqual(result, "accountValue");
                assert((client.pathTemplates.accountTaxPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchTaxFromAccountTaxName', () => {
                const result = client.matchTaxFromAccountTaxName(fakePath);
                assert.strictEqual(result, "taxValue");
                assert((client.pathTemplates.accountTaxPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });
        });

        describe('autofeedSettings', async () => {
            const fakePath = "/rendered/path/autofeedSettings";
            const expectedParameters = {
                account: "accountValue",
            };
            const client = new termsofserviceserviceModule.v1beta.TermsOfServiceServiceClient({
                credentials: {client_email: 'bogus', private_key: 'bogus'},
                projectId: 'bogus',
            });
            await client.initialize();
            client.pathTemplates.autofeedSettingsPathTemplate.render =
                sinon.stub().returns(fakePath);
            client.pathTemplates.autofeedSettingsPathTemplate.match =
                sinon.stub().returns(expectedParameters);

            it('autofeedSettingsPath', () => {
                const result = client.autofeedSettingsPath("accountValue");
                assert.strictEqual(result, fakePath);
                assert((client.pathTemplates.autofeedSettingsPathTemplate.render as SinonStub)
                    .getCall(-1).calledWith(expectedParameters));
            });

            it('matchAccountFromAutofeedSettingsName', () => {
                const result = client.matchAccountFromAutofeedSettingsName(fakePath);
                assert.strictEqual(result, "accountValue");
                assert((client.pathTemplates.autofeedSettingsPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });
        });

        describe('automaticImprovements', async () => {
            const fakePath = "/rendered/path/automaticImprovements";
            const expectedParameters = {
                account: "accountValue",
            };
            const client = new termsofserviceserviceModule.v1beta.TermsOfServiceServiceClient({
                credentials: {client_email: 'bogus', private_key: 'bogus'},
                projectId: 'bogus',
            });
            await client.initialize();
            client.pathTemplates.automaticImprovementsPathTemplate.render =
                sinon.stub().returns(fakePath);
            client.pathTemplates.automaticImprovementsPathTemplate.match =
                sinon.stub().returns(expectedParameters);

            it('automaticImprovementsPath', () => {
                const result = client.automaticImprovementsPath("accountValue");
                assert.strictEqual(result, fakePath);
                assert((client.pathTemplates.automaticImprovementsPathTemplate.render as SinonStub)
                    .getCall(-1).calledWith(expectedParameters));
            });

            it('matchAccountFromAutomaticImprovementsName', () => {
                const result = client.matchAccountFromAutomaticImprovementsName(fakePath);
                assert.strictEqual(result, "accountValue");
                assert((client.pathTemplates.automaticImprovementsPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });
        });

        describe('businessIdentity', async () => {
            const fakePath = "/rendered/path/businessIdentity";
            const expectedParameters = {
                account: "accountValue",
            };
            const client = new termsofserviceserviceModule.v1beta.TermsOfServiceServiceClient({
                credentials: {client_email: 'bogus', private_key: 'bogus'},
                projectId: 'bogus',
            });
            await client.initialize();
            client.pathTemplates.businessIdentityPathTemplate.render =
                sinon.stub().returns(fakePath);
            client.pathTemplates.businessIdentityPathTemplate.match =
                sinon.stub().returns(expectedParameters);

            it('businessIdentityPath', () => {
                const result = client.businessIdentityPath("accountValue");
                assert.strictEqual(result, fakePath);
                assert((client.pathTemplates.businessIdentityPathTemplate.render as SinonStub)
                    .getCall(-1).calledWith(expectedParameters));
            });

            it('matchAccountFromBusinessIdentityName', () => {
                const result = client.matchAccountFromBusinessIdentityName(fakePath);
                assert.strictEqual(result, "accountValue");
                assert((client.pathTemplates.businessIdentityPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });
        });

        describe('businessInfo', async () => {
            const fakePath = "/rendered/path/businessInfo";
            const expectedParameters = {
                account: "accountValue",
            };
            const client = new termsofserviceserviceModule.v1beta.TermsOfServiceServiceClient({
                credentials: {client_email: 'bogus', private_key: 'bogus'},
                projectId: 'bogus',
            });
            await client.initialize();
            client.pathTemplates.businessInfoPathTemplate.render =
                sinon.stub().returns(fakePath);
            client.pathTemplates.businessInfoPathTemplate.match =
                sinon.stub().returns(expectedParameters);

            it('businessInfoPath', () => {
                const result = client.businessInfoPath("accountValue");
                assert.strictEqual(result, fakePath);
                assert((client.pathTemplates.businessInfoPathTemplate.render as SinonStub)
                    .getCall(-1).calledWith(expectedParameters));
            });

            it('matchAccountFromBusinessInfoName', () => {
                const result = client.matchAccountFromBusinessInfoName(fakePath);
                assert.strictEqual(result, "accountValue");
                assert((client.pathTemplates.businessInfoPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });
        });

        describe('emailPreferences', async () => {
            const fakePath = "/rendered/path/emailPreferences";
            const expectedParameters = {
                account: "accountValue",
                email: "emailValue",
            };
            const client = new termsofserviceserviceModule.v1beta.TermsOfServiceServiceClient({
                credentials: {client_email: 'bogus', private_key: 'bogus'},
                projectId: 'bogus',
            });
            await client.initialize();
            client.pathTemplates.emailPreferencesPathTemplate.render =
                sinon.stub().returns(fakePath);
            client.pathTemplates.emailPreferencesPathTemplate.match =
                sinon.stub().returns(expectedParameters);

            it('emailPreferencesPath', () => {
                const result = client.emailPreferencesPath("accountValue", "emailValue");
                assert.strictEqual(result, fakePath);
                assert((client.pathTemplates.emailPreferencesPathTemplate.render as SinonStub)
                    .getCall(-1).calledWith(expectedParameters));
            });

            it('matchAccountFromEmailPreferencesName', () => {
                const result = client.matchAccountFromEmailPreferencesName(fakePath);
                assert.strictEqual(result, "accountValue");
                assert((client.pathTemplates.emailPreferencesPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchEmailFromEmailPreferencesName', () => {
                const result = client.matchEmailFromEmailPreferencesName(fakePath);
                assert.strictEqual(result, "emailValue");
                assert((client.pathTemplates.emailPreferencesPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });
        });

        describe('gbpAccount', async () => {
            const fakePath = "/rendered/path/gbpAccount";
            const expectedParameters = {
                account: "accountValue",
                gbp_account: "gbpAccountValue",
            };
            const client = new termsofserviceserviceModule.v1beta.TermsOfServiceServiceClient({
                credentials: {client_email: 'bogus', private_key: 'bogus'},
                projectId: 'bogus',
            });
            await client.initialize();
            client.pathTemplates.gbpAccountPathTemplate.render =
                sinon.stub().returns(fakePath);
            client.pathTemplates.gbpAccountPathTemplate.match =
                sinon.stub().returns(expectedParameters);

            it('gbpAccountPath', () => {
                const result = client.gbpAccountPath("accountValue", "gbpAccountValue");
                assert.strictEqual(result, fakePath);
                assert((client.pathTemplates.gbpAccountPathTemplate.render as SinonStub)
                    .getCall(-1).calledWith(expectedParameters));
            });

            it('matchAccountFromGbpAccountName', () => {
                const result = client.matchAccountFromGbpAccountName(fakePath);
                assert.strictEqual(result, "accountValue");
                assert((client.pathTemplates.gbpAccountPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchGbpAccountFromGbpAccountName', () => {
                const result = client.matchGbpAccountFromGbpAccountName(fakePath);
                assert.strictEqual(result, "gbpAccountValue");
                assert((client.pathTemplates.gbpAccountPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });
        });

        describe('homepage', async () => {
            const fakePath = "/rendered/path/homepage";
            const expectedParameters = {
                account: "accountValue",
            };
            const client = new termsofserviceserviceModule.v1beta.TermsOfServiceServiceClient({
                credentials: {client_email: 'bogus', private_key: 'bogus'},
                projectId: 'bogus',
            });
            await client.initialize();
            client.pathTemplates.homepagePathTemplate.render =
                sinon.stub().returns(fakePath);
            client.pathTemplates.homepagePathTemplate.match =
                sinon.stub().returns(expectedParameters);

            it('homepagePath', () => {
                const result = client.homepagePath("accountValue");
                assert.strictEqual(result, fakePath);
                assert((client.pathTemplates.homepagePathTemplate.render as SinonStub)
                    .getCall(-1).calledWith(expectedParameters));
            });

            it('matchAccountFromHomepageName', () => {
                const result = client.matchAccountFromHomepageName(fakePath);
                assert.strictEqual(result, "accountValue");
                assert((client.pathTemplates.homepagePathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });
        });

        describe('lfpProvider', async () => {
            const fakePath = "/rendered/path/lfpProvider";
            const expectedParameters = {
                account: "accountValue",
                omnichannel_setting: "omnichannelSettingValue",
                lfp_provider: "lfpProviderValue",
            };
            const client = new termsofserviceserviceModule.v1beta.TermsOfServiceServiceClient({
                credentials: {client_email: 'bogus', private_key: 'bogus'},
                projectId: 'bogus',
            });
            await client.initialize();
            client.pathTemplates.lfpProviderPathTemplate.render =
                sinon.stub().returns(fakePath);
            client.pathTemplates.lfpProviderPathTemplate.match =
                sinon.stub().returns(expectedParameters);

            it('lfpProviderPath', () => {
                const result = client.lfpProviderPath("accountValue", "omnichannelSettingValue", "lfpProviderValue");
                assert.strictEqual(result, fakePath);
                assert((client.pathTemplates.lfpProviderPathTemplate.render as SinonStub)
                    .getCall(-1).calledWith(expectedParameters));
            });

            it('matchAccountFromLfpProviderName', () => {
                const result = client.matchAccountFromLfpProviderName(fakePath);
                assert.strictEqual(result, "accountValue");
                assert((client.pathTemplates.lfpProviderPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchOmnichannelSettingFromLfpProviderName', () => {
                const result = client.matchOmnichannelSettingFromLfpProviderName(fakePath);
                assert.strictEqual(result, "omnichannelSettingValue");
                assert((client.pathTemplates.lfpProviderPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchLfpProviderFromLfpProviderName', () => {
                const result = client.matchLfpProviderFromLfpProviderName(fakePath);
                assert.strictEqual(result, "lfpProviderValue");
                assert((client.pathTemplates.lfpProviderPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });
        });

        describe('omnichannelSetting', async () => {
            const fakePath = "/rendered/path/omnichannelSetting";
            const expectedParameters = {
                account: "accountValue",
                omnichannel_setting: "omnichannelSettingValue",
            };
            const client = new termsofserviceserviceModule.v1beta.TermsOfServiceServiceClient({
                credentials: {client_email: 'bogus', private_key: 'bogus'},
                projectId: 'bogus',
            });
            await client.initialize();
            client.pathTemplates.omnichannelSettingPathTemplate.render =
                sinon.stub().returns(fakePath);
            client.pathTemplates.omnichannelSettingPathTemplate.match =
                sinon.stub().returns(expectedParameters);

            it('omnichannelSettingPath', () => {
                const result = client.omnichannelSettingPath("accountValue", "omnichannelSettingValue");
                assert.strictEqual(result, fakePath);
                assert((client.pathTemplates.omnichannelSettingPathTemplate.render as SinonStub)
                    .getCall(-1).calledWith(expectedParameters));
            });

            it('matchAccountFromOmnichannelSettingName', () => {
                const result = client.matchAccountFromOmnichannelSettingName(fakePath);
                assert.strictEqual(result, "accountValue");
                assert((client.pathTemplates.omnichannelSettingPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchOmnichannelSettingFromOmnichannelSettingName', () => {
                const result = client.matchOmnichannelSettingFromOmnichannelSettingName(fakePath);
                assert.strictEqual(result, "omnichannelSettingValue");
                assert((client.pathTemplates.omnichannelSettingPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });
        });

        describe('onlineReturnPolicy', async () => {
            const fakePath = "/rendered/path/onlineReturnPolicy";
            const expectedParameters = {
                account: "accountValue",
                return_policy: "returnPolicyValue",
            };
            const client = new termsofserviceserviceModule.v1beta.TermsOfServiceServiceClient({
                credentials: {client_email: 'bogus', private_key: 'bogus'},
                projectId: 'bogus',
            });
            await client.initialize();
            client.pathTemplates.onlineReturnPolicyPathTemplate.render =
                sinon.stub().returns(fakePath);
            client.pathTemplates.onlineReturnPolicyPathTemplate.match =
                sinon.stub().returns(expectedParameters);

            it('onlineReturnPolicyPath', () => {
                const result = client.onlineReturnPolicyPath("accountValue", "returnPolicyValue");
                assert.strictEqual(result, fakePath);
                assert((client.pathTemplates.onlineReturnPolicyPathTemplate.render as SinonStub)
                    .getCall(-1).calledWith(expectedParameters));
            });

            it('matchAccountFromOnlineReturnPolicyName', () => {
                const result = client.matchAccountFromOnlineReturnPolicyName(fakePath);
                assert.strictEqual(result, "accountValue");
                assert((client.pathTemplates.onlineReturnPolicyPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchReturnPolicyFromOnlineReturnPolicyName', () => {
                const result = client.matchReturnPolicyFromOnlineReturnPolicyName(fakePath);
                assert.strictEqual(result, "returnPolicyValue");
                assert((client.pathTemplates.onlineReturnPolicyPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });
        });

        describe('program', async () => {
            const fakePath = "/rendered/path/program";
            const expectedParameters = {
                account: "accountValue",
                program: "programValue",
            };
            const client = new termsofserviceserviceModule.v1beta.TermsOfServiceServiceClient({
                credentials: {client_email: 'bogus', private_key: 'bogus'},
                projectId: 'bogus',
            });
            await client.initialize();
            client.pathTemplates.programPathTemplate.render =
                sinon.stub().returns(fakePath);
            client.pathTemplates.programPathTemplate.match =
                sinon.stub().returns(expectedParameters);

            it('programPath', () => {
                const result = client.programPath("accountValue", "programValue");
                assert.strictEqual(result, fakePath);
                assert((client.pathTemplates.programPathTemplate.render as SinonStub)
                    .getCall(-1).calledWith(expectedParameters));
            });

            it('matchAccountFromProgramName', () => {
                const result = client.matchAccountFromProgramName(fakePath);
                assert.strictEqual(result, "accountValue");
                assert((client.pathTemplates.programPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchProgramFromProgramName', () => {
                const result = client.matchProgramFromProgramName(fakePath);
                assert.strictEqual(result, "programValue");
                assert((client.pathTemplates.programPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });
        });

        describe('region', async () => {
            const fakePath = "/rendered/path/region";
            const expectedParameters = {
                account: "accountValue",
                region: "regionValue",
            };
            const client = new termsofserviceserviceModule.v1beta.TermsOfServiceServiceClient({
                credentials: {client_email: 'bogus', private_key: 'bogus'},
                projectId: 'bogus',
            });
            await client.initialize();
            client.pathTemplates.regionPathTemplate.render =
                sinon.stub().returns(fakePath);
            client.pathTemplates.regionPathTemplate.match =
                sinon.stub().returns(expectedParameters);

            it('regionPath', () => {
                const result = client.regionPath("accountValue", "regionValue");
                assert.strictEqual(result, fakePath);
                assert((client.pathTemplates.regionPathTemplate.render as SinonStub)
                    .getCall(-1).calledWith(expectedParameters));
            });

            it('matchAccountFromRegionName', () => {
                const result = client.matchAccountFromRegionName(fakePath);
                assert.strictEqual(result, "accountValue");
                assert((client.pathTemplates.regionPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchRegionFromRegionName', () => {
                const result = client.matchRegionFromRegionName(fakePath);
                assert.strictEqual(result, "regionValue");
                assert((client.pathTemplates.regionPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });
        });

        describe('shippingSettings', async () => {
            const fakePath = "/rendered/path/shippingSettings";
            const expectedParameters = {
                account: "accountValue",
            };
            const client = new termsofserviceserviceModule.v1beta.TermsOfServiceServiceClient({
                credentials: {client_email: 'bogus', private_key: 'bogus'},
                projectId: 'bogus',
            });
            await client.initialize();
            client.pathTemplates.shippingSettingsPathTemplate.render =
                sinon.stub().returns(fakePath);
            client.pathTemplates.shippingSettingsPathTemplate.match =
                sinon.stub().returns(expectedParameters);

            it('shippingSettingsPath', () => {
                const result = client.shippingSettingsPath("accountValue");
                assert.strictEqual(result, fakePath);
                assert((client.pathTemplates.shippingSettingsPathTemplate.render as SinonStub)
                    .getCall(-1).calledWith(expectedParameters));
            });

            it('matchAccountFromShippingSettingsName', () => {
                const result = client.matchAccountFromShippingSettingsName(fakePath);
                assert.strictEqual(result, "accountValue");
                assert((client.pathTemplates.shippingSettingsPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });
        });

        describe('termsOfService', async () => {
            const fakePath = "/rendered/path/termsOfService";
            const expectedParameters = {
                version: "versionValue",
            };
            const client = new termsofserviceserviceModule.v1beta.TermsOfServiceServiceClient({
                credentials: {client_email: 'bogus', private_key: 'bogus'},
                projectId: 'bogus',
            });
            await client.initialize();
            client.pathTemplates.termsOfServicePathTemplate.render =
                sinon.stub().returns(fakePath);
            client.pathTemplates.termsOfServicePathTemplate.match =
                sinon.stub().returns(expectedParameters);

            it('termsOfServicePath', () => {
                const result = client.termsOfServicePath("versionValue");
                assert.strictEqual(result, fakePath);
                assert((client.pathTemplates.termsOfServicePathTemplate.render as SinonStub)
                    .getCall(-1).calledWith(expectedParameters));
            });

            it('matchVersionFromTermsOfServiceName', () => {
                const result = client.matchVersionFromTermsOfServiceName(fakePath);
                assert.strictEqual(result, "versionValue");
                assert((client.pathTemplates.termsOfServicePathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });
        });

        describe('termsOfServiceAgreementState', async () => {
            const fakePath = "/rendered/path/termsOfServiceAgreementState";
            const expectedParameters = {
                account: "accountValue",
                identifier: "identifierValue",
            };
            const client = new termsofserviceserviceModule.v1beta.TermsOfServiceServiceClient({
                credentials: {client_email: 'bogus', private_key: 'bogus'},
                projectId: 'bogus',
            });
            await client.initialize();
            client.pathTemplates.termsOfServiceAgreementStatePathTemplate.render =
                sinon.stub().returns(fakePath);
            client.pathTemplates.termsOfServiceAgreementStatePathTemplate.match =
                sinon.stub().returns(expectedParameters);

            it('termsOfServiceAgreementStatePath', () => {
                const result = client.termsOfServiceAgreementStatePath("accountValue", "identifierValue");
                assert.strictEqual(result, fakePath);
                assert((client.pathTemplates.termsOfServiceAgreementStatePathTemplate.render as SinonStub)
                    .getCall(-1).calledWith(expectedParameters));
            });

            it('matchAccountFromTermsOfServiceAgreementStateName', () => {
                const result = client.matchAccountFromTermsOfServiceAgreementStateName(fakePath);
                assert.strictEqual(result, "accountValue");
                assert((client.pathTemplates.termsOfServiceAgreementStatePathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchIdentifierFromTermsOfServiceAgreementStateName', () => {
                const result = client.matchIdentifierFromTermsOfServiceAgreementStateName(fakePath);
                assert.strictEqual(result, "identifierValue");
                assert((client.pathTemplates.termsOfServiceAgreementStatePathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });
        });

        describe('user', async () => {
            const fakePath = "/rendered/path/user";
            const expectedParameters = {
                account: "accountValue",
                email: "emailValue",
            };
            const client = new termsofserviceserviceModule.v1beta.TermsOfServiceServiceClient({
                credentials: {client_email: 'bogus', private_key: 'bogus'},
                projectId: 'bogus',
            });
            await client.initialize();
            client.pathTemplates.userPathTemplate.render =
                sinon.stub().returns(fakePath);
            client.pathTemplates.userPathTemplate.match =
                sinon.stub().returns(expectedParameters);

            it('userPath', () => {
                const result = client.userPath("accountValue", "emailValue");
                assert.strictEqual(result, fakePath);
                assert((client.pathTemplates.userPathTemplate.render as SinonStub)
                    .getCall(-1).calledWith(expectedParameters));
            });

            it('matchAccountFromUserName', () => {
                const result = client.matchAccountFromUserName(fakePath);
                assert.strictEqual(result, "accountValue");
                assert((client.pathTemplates.userPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });

            it('matchEmailFromUserName', () => {
                const result = client.matchEmailFromUserName(fakePath);
                assert.strictEqual(result, "emailValue");
                assert((client.pathTemplates.userPathTemplate.match as SinonStub)
                    .getCall(-1).calledWith(fakePath));
            });
        });
    });
});
