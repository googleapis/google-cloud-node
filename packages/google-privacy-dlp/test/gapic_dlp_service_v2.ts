// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// ** This file is automatically generated by gapic-generator-typescript. **
// ** https://github.com/googleapis/gapic-generator-typescript **
// ** All changes to this file may be overwritten. **

import * as protos from '../protos/protos';
import * as assert from 'assert';
import * as sinon from 'sinon';
import {SinonStub} from 'sinon';
import {describe, it} from 'mocha';
import * as dlpserviceModule from '../src';

import {PassThrough} from 'stream';

import {protobuf} from 'google-gax';

function generateSampleMessage<T extends object>(instance: T) {
  const filledObject = (
    instance.constructor as typeof protobuf.Message
  ).toObject(instance as protobuf.Message<T>, {defaults: true});
  return (instance.constructor as typeof protobuf.Message).fromObject(
    filledObject
  ) as T;
}

function stubSimpleCall<ResponseType>(response?: ResponseType, error?: Error) {
  return error
    ? sinon.stub().rejects(error)
    : sinon.stub().resolves([response]);
}

function stubSimpleCallWithCallback<ResponseType>(
  response?: ResponseType,
  error?: Error
) {
  return error
    ? sinon.stub().callsArgWith(2, error)
    : sinon.stub().callsArgWith(2, null, response);
}

function stubPageStreamingCall<ResponseType>(
  responses?: ResponseType[],
  error?: Error
) {
  const pagingStub = sinon.stub();
  if (responses) {
    for (let i = 0; i < responses.length; ++i) {
      pagingStub.onCall(i).callsArgWith(2, null, responses[i]);
    }
  }
  const transformStub = error
    ? sinon.stub().callsArgWith(2, error)
    : pagingStub;
  const mockStream = new PassThrough({
    objectMode: true,
    transform: transformStub,
  });
  // trigger as many responses as needed
  if (responses) {
    for (let i = 0; i < responses.length; ++i) {
      setImmediate(() => {
        mockStream.write({});
      });
    }
    setImmediate(() => {
      mockStream.end();
    });
  } else {
    setImmediate(() => {
      mockStream.write({});
    });
    setImmediate(() => {
      mockStream.end();
    });
  }
  return sinon.stub().returns(mockStream);
}

function stubAsyncIterationCall<ResponseType>(
  responses?: ResponseType[],
  error?: Error
) {
  let counter = 0;
  const asyncIterable = {
    [Symbol.asyncIterator]() {
      return {
        async next() {
          if (error) {
            return Promise.reject(error);
          }
          if (counter >= responses!.length) {
            return Promise.resolve({done: true, value: undefined});
          }
          return Promise.resolve({done: false, value: responses![counter++]});
        },
      };
    },
  };
  return sinon.stub().returns(asyncIterable);
}

describe('v2.DlpServiceClient', () => {
  it('has servicePath', () => {
    const servicePath = dlpserviceModule.v2.DlpServiceClient.servicePath;
    assert(servicePath);
  });

  it('has apiEndpoint', () => {
    const apiEndpoint = dlpserviceModule.v2.DlpServiceClient.apiEndpoint;
    assert(apiEndpoint);
  });

  it('has port', () => {
    const port = dlpserviceModule.v2.DlpServiceClient.port;
    assert(port);
    assert(typeof port === 'number');
  });

  it('should create a client with no option', () => {
    const client = new dlpserviceModule.v2.DlpServiceClient();
    assert(client);
  });

  it('should create a client with gRPC fallback', () => {
    const client = new dlpserviceModule.v2.DlpServiceClient({
      fallback: true,
    });
    assert(client);
  });

  it('has initialize method and supports deferred initialization', async () => {
    const client = new dlpserviceModule.v2.DlpServiceClient({
      credentials: {client_email: 'bogus', private_key: 'bogus'},
      projectId: 'bogus',
    });
    assert.strictEqual(client.dlpServiceStub, undefined);
    await client.initialize();
    assert(client.dlpServiceStub);
  });

  it('has close method for the initialized client', done => {
    const client = new dlpserviceModule.v2.DlpServiceClient({
      credentials: {client_email: 'bogus', private_key: 'bogus'},
      projectId: 'bogus',
    });
    client.initialize();
    assert(client.dlpServiceStub);
    client.close().then(() => {
      done();
    });
  });

  it('has close method for the non-initialized client', done => {
    const client = new dlpserviceModule.v2.DlpServiceClient({
      credentials: {client_email: 'bogus', private_key: 'bogus'},
      projectId: 'bogus',
    });
    assert.strictEqual(client.dlpServiceStub, undefined);
    client.close().then(() => {
      done();
    });
  });

  it('has getProjectId method', async () => {
    const fakeProjectId = 'fake-project-id';
    const client = new dlpserviceModule.v2.DlpServiceClient({
      credentials: {client_email: 'bogus', private_key: 'bogus'},
      projectId: 'bogus',
    });
    client.auth.getProjectId = sinon.stub().resolves(fakeProjectId);
    const result = await client.getProjectId();
    assert.strictEqual(result, fakeProjectId);
    assert((client.auth.getProjectId as SinonStub).calledWithExactly());
  });

  it('has getProjectId method with callback', async () => {
    const fakeProjectId = 'fake-project-id';
    const client = new dlpserviceModule.v2.DlpServiceClient({
      credentials: {client_email: 'bogus', private_key: 'bogus'},
      projectId: 'bogus',
    });
    client.auth.getProjectId = sinon
      .stub()
      .callsArgWith(0, null, fakeProjectId);
    const promise = new Promise((resolve, reject) => {
      client.getProjectId((err?: Error | null, projectId?: string | null) => {
        if (err) {
          reject(err);
        } else {
          resolve(projectId);
        }
      });
    });
    const result = await promise;
    assert.strictEqual(result, fakeProjectId);
  });

  describe('inspectContent', () => {
    it('invokes inspectContent without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.InspectContentRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.InspectContentResponse()
      );
      client.innerApiCalls.inspectContent = stubSimpleCall(expectedResponse);
      const [response] = await client.inspectContent(request);
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.inspectContent as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes inspectContent without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.InspectContentRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.InspectContentResponse()
      );
      client.innerApiCalls.inspectContent =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.inspectContent(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IInspectContentResponse | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.inspectContent as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions /*, callback defined above */)
      );
    });

    it('invokes inspectContent with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.InspectContentRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedError = new Error('expected');
      client.innerApiCalls.inspectContent = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.inspectContent(request), expectedError);
      assert(
        (client.innerApiCalls.inspectContent as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes inspectContent with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.InspectContentRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.inspectContent(request), expectedError);
    });
  });

  describe('redactImage', () => {
    it('invokes redactImage without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.RedactImageRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.RedactImageResponse()
      );
      client.innerApiCalls.redactImage = stubSimpleCall(expectedResponse);
      const [response] = await client.redactImage(request);
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.redactImage as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes redactImage without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.RedactImageRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.RedactImageResponse()
      );
      client.innerApiCalls.redactImage =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.redactImage(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IRedactImageResponse | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.redactImage as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions /*, callback defined above */)
      );
    });

    it('invokes redactImage with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.RedactImageRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedError = new Error('expected');
      client.innerApiCalls.redactImage = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.redactImage(request), expectedError);
      assert(
        (client.innerApiCalls.redactImage as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes redactImage with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.RedactImageRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.redactImage(request), expectedError);
    });
  });

  describe('deidentifyContent', () => {
    it('invokes deidentifyContent without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeidentifyContentRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeidentifyContentResponse()
      );
      client.innerApiCalls.deidentifyContent = stubSimpleCall(expectedResponse);
      const [response] = await client.deidentifyContent(request);
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.deidentifyContent as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes deidentifyContent without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeidentifyContentRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeidentifyContentResponse()
      );
      client.innerApiCalls.deidentifyContent =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.deidentifyContent(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IDeidentifyContentResponse | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.deidentifyContent as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions /*, callback defined above */)
      );
    });

    it('invokes deidentifyContent with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeidentifyContentRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedError = new Error('expected');
      client.innerApiCalls.deidentifyContent = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.deidentifyContent(request), expectedError);
      assert(
        (client.innerApiCalls.deidentifyContent as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes deidentifyContent with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeidentifyContentRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.deidentifyContent(request), expectedError);
    });
  });

  describe('reidentifyContent', () => {
    it('invokes reidentifyContent without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ReidentifyContentRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ReidentifyContentResponse()
      );
      client.innerApiCalls.reidentifyContent = stubSimpleCall(expectedResponse);
      const [response] = await client.reidentifyContent(request);
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.reidentifyContent as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes reidentifyContent without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ReidentifyContentRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ReidentifyContentResponse()
      );
      client.innerApiCalls.reidentifyContent =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.reidentifyContent(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IReidentifyContentResponse | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.reidentifyContent as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions /*, callback defined above */)
      );
    });

    it('invokes reidentifyContent with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ReidentifyContentRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedError = new Error('expected');
      client.innerApiCalls.reidentifyContent = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.reidentifyContent(request), expectedError);
      assert(
        (client.innerApiCalls.reidentifyContent as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes reidentifyContent with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ReidentifyContentRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.reidentifyContent(request), expectedError);
    });
  });

  describe('listInfoTypes', () => {
    it('invokes listInfoTypes without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListInfoTypesRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListInfoTypesResponse()
      );
      client.innerApiCalls.listInfoTypes = stubSimpleCall(expectedResponse);
      const [response] = await client.listInfoTypes(request);
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.listInfoTypes as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes listInfoTypes without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListInfoTypesRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListInfoTypesResponse()
      );
      client.innerApiCalls.listInfoTypes =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.listInfoTypes(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IListInfoTypesResponse | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.listInfoTypes as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions /*, callback defined above */)
      );
    });

    it('invokes listInfoTypes with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListInfoTypesRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedError = new Error('expected');
      client.innerApiCalls.listInfoTypes = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.listInfoTypes(request), expectedError);
      assert(
        (client.innerApiCalls.listInfoTypes as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes listInfoTypes with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListInfoTypesRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.listInfoTypes(request), expectedError);
    });
  });

  describe('createInspectTemplate', () => {
    it('invokes createInspectTemplate without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CreateInspectTemplateRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.InspectTemplate()
      );
      client.innerApiCalls.createInspectTemplate =
        stubSimpleCall(expectedResponse);
      const [response] = await client.createInspectTemplate(request);
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.createInspectTemplate as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes createInspectTemplate without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CreateInspectTemplateRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.InspectTemplate()
      );
      client.innerApiCalls.createInspectTemplate =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.createInspectTemplate(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IInspectTemplate | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.createInspectTemplate as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions /*, callback defined above */)
      );
    });

    it('invokes createInspectTemplate with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CreateInspectTemplateRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedError = new Error('expected');
      client.innerApiCalls.createInspectTemplate = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(
        client.createInspectTemplate(request),
        expectedError
      );
      assert(
        (client.innerApiCalls.createInspectTemplate as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes createInspectTemplate with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CreateInspectTemplateRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(
        client.createInspectTemplate(request),
        expectedError
      );
    });
  });

  describe('updateInspectTemplate', () => {
    it('invokes updateInspectTemplate without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.UpdateInspectTemplateRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.InspectTemplate()
      );
      client.innerApiCalls.updateInspectTemplate =
        stubSimpleCall(expectedResponse);
      const [response] = await client.updateInspectTemplate(request);
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.updateInspectTemplate as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes updateInspectTemplate without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.UpdateInspectTemplateRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.InspectTemplate()
      );
      client.innerApiCalls.updateInspectTemplate =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.updateInspectTemplate(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IInspectTemplate | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.updateInspectTemplate as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions /*, callback defined above */)
      );
    });

    it('invokes updateInspectTemplate with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.UpdateInspectTemplateRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedError = new Error('expected');
      client.innerApiCalls.updateInspectTemplate = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(
        client.updateInspectTemplate(request),
        expectedError
      );
      assert(
        (client.innerApiCalls.updateInspectTemplate as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes updateInspectTemplate with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.UpdateInspectTemplateRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(
        client.updateInspectTemplate(request),
        expectedError
      );
    });
  });

  describe('getInspectTemplate', () => {
    it('invokes getInspectTemplate without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetInspectTemplateRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.InspectTemplate()
      );
      client.innerApiCalls.getInspectTemplate =
        stubSimpleCall(expectedResponse);
      const [response] = await client.getInspectTemplate(request);
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.getInspectTemplate as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes getInspectTemplate without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetInspectTemplateRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.InspectTemplate()
      );
      client.innerApiCalls.getInspectTemplate =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.getInspectTemplate(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IInspectTemplate | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.getInspectTemplate as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions /*, callback defined above */)
      );
    });

    it('invokes getInspectTemplate with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetInspectTemplateRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedError = new Error('expected');
      client.innerApiCalls.getInspectTemplate = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.getInspectTemplate(request), expectedError);
      assert(
        (client.innerApiCalls.getInspectTemplate as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes getInspectTemplate with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetInspectTemplateRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.getInspectTemplate(request), expectedError);
    });
  });

  describe('deleteInspectTemplate', () => {
    it('invokes deleteInspectTemplate without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteInspectTemplateRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.protobuf.Empty()
      );
      client.innerApiCalls.deleteInspectTemplate =
        stubSimpleCall(expectedResponse);
      const [response] = await client.deleteInspectTemplate(request);
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.deleteInspectTemplate as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes deleteInspectTemplate without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteInspectTemplateRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.protobuf.Empty()
      );
      client.innerApiCalls.deleteInspectTemplate =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.deleteInspectTemplate(
          request,
          (
            err?: Error | null,
            result?: protos.google.protobuf.IEmpty | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.deleteInspectTemplate as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions /*, callback defined above */)
      );
    });

    it('invokes deleteInspectTemplate with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteInspectTemplateRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedError = new Error('expected');
      client.innerApiCalls.deleteInspectTemplate = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(
        client.deleteInspectTemplate(request),
        expectedError
      );
      assert(
        (client.innerApiCalls.deleteInspectTemplate as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes deleteInspectTemplate with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteInspectTemplateRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(
        client.deleteInspectTemplate(request),
        expectedError
      );
    });
  });

  describe('createDeidentifyTemplate', () => {
    it('invokes createDeidentifyTemplate without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CreateDeidentifyTemplateRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeidentifyTemplate()
      );
      client.innerApiCalls.createDeidentifyTemplate =
        stubSimpleCall(expectedResponse);
      const [response] = await client.createDeidentifyTemplate(request);
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.createDeidentifyTemplate as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes createDeidentifyTemplate without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CreateDeidentifyTemplateRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeidentifyTemplate()
      );
      client.innerApiCalls.createDeidentifyTemplate =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.createDeidentifyTemplate(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IDeidentifyTemplate | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.createDeidentifyTemplate as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions /*, callback defined above */)
      );
    });

    it('invokes createDeidentifyTemplate with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CreateDeidentifyTemplateRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedError = new Error('expected');
      client.innerApiCalls.createDeidentifyTemplate = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(
        client.createDeidentifyTemplate(request),
        expectedError
      );
      assert(
        (client.innerApiCalls.createDeidentifyTemplate as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes createDeidentifyTemplate with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CreateDeidentifyTemplateRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(
        client.createDeidentifyTemplate(request),
        expectedError
      );
    });
  });

  describe('updateDeidentifyTemplate', () => {
    it('invokes updateDeidentifyTemplate without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.UpdateDeidentifyTemplateRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeidentifyTemplate()
      );
      client.innerApiCalls.updateDeidentifyTemplate =
        stubSimpleCall(expectedResponse);
      const [response] = await client.updateDeidentifyTemplate(request);
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.updateDeidentifyTemplate as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes updateDeidentifyTemplate without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.UpdateDeidentifyTemplateRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeidentifyTemplate()
      );
      client.innerApiCalls.updateDeidentifyTemplate =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.updateDeidentifyTemplate(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IDeidentifyTemplate | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.updateDeidentifyTemplate as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions /*, callback defined above */)
      );
    });

    it('invokes updateDeidentifyTemplate with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.UpdateDeidentifyTemplateRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedError = new Error('expected');
      client.innerApiCalls.updateDeidentifyTemplate = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(
        client.updateDeidentifyTemplate(request),
        expectedError
      );
      assert(
        (client.innerApiCalls.updateDeidentifyTemplate as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes updateDeidentifyTemplate with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.UpdateDeidentifyTemplateRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(
        client.updateDeidentifyTemplate(request),
        expectedError
      );
    });
  });

  describe('getDeidentifyTemplate', () => {
    it('invokes getDeidentifyTemplate without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetDeidentifyTemplateRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeidentifyTemplate()
      );
      client.innerApiCalls.getDeidentifyTemplate =
        stubSimpleCall(expectedResponse);
      const [response] = await client.getDeidentifyTemplate(request);
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.getDeidentifyTemplate as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes getDeidentifyTemplate without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetDeidentifyTemplateRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeidentifyTemplate()
      );
      client.innerApiCalls.getDeidentifyTemplate =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.getDeidentifyTemplate(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IDeidentifyTemplate | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.getDeidentifyTemplate as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions /*, callback defined above */)
      );
    });

    it('invokes getDeidentifyTemplate with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetDeidentifyTemplateRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedError = new Error('expected');
      client.innerApiCalls.getDeidentifyTemplate = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(
        client.getDeidentifyTemplate(request),
        expectedError
      );
      assert(
        (client.innerApiCalls.getDeidentifyTemplate as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes getDeidentifyTemplate with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetDeidentifyTemplateRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(
        client.getDeidentifyTemplate(request),
        expectedError
      );
    });
  });

  describe('deleteDeidentifyTemplate', () => {
    it('invokes deleteDeidentifyTemplate without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteDeidentifyTemplateRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.protobuf.Empty()
      );
      client.innerApiCalls.deleteDeidentifyTemplate =
        stubSimpleCall(expectedResponse);
      const [response] = await client.deleteDeidentifyTemplate(request);
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.deleteDeidentifyTemplate as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes deleteDeidentifyTemplate without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteDeidentifyTemplateRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.protobuf.Empty()
      );
      client.innerApiCalls.deleteDeidentifyTemplate =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.deleteDeidentifyTemplate(
          request,
          (
            err?: Error | null,
            result?: protos.google.protobuf.IEmpty | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.deleteDeidentifyTemplate as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions /*, callback defined above */)
      );
    });

    it('invokes deleteDeidentifyTemplate with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteDeidentifyTemplateRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedError = new Error('expected');
      client.innerApiCalls.deleteDeidentifyTemplate = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(
        client.deleteDeidentifyTemplate(request),
        expectedError
      );
      assert(
        (client.innerApiCalls.deleteDeidentifyTemplate as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes deleteDeidentifyTemplate with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteDeidentifyTemplateRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(
        client.deleteDeidentifyTemplate(request),
        expectedError
      );
    });
  });

  describe('createJobTrigger', () => {
    it('invokes createJobTrigger without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CreateJobTriggerRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.JobTrigger()
      );
      client.innerApiCalls.createJobTrigger = stubSimpleCall(expectedResponse);
      const [response] = await client.createJobTrigger(request);
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.createJobTrigger as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes createJobTrigger without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CreateJobTriggerRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.JobTrigger()
      );
      client.innerApiCalls.createJobTrigger =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.createJobTrigger(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IJobTrigger | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.createJobTrigger as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions /*, callback defined above */)
      );
    });

    it('invokes createJobTrigger with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CreateJobTriggerRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedError = new Error('expected');
      client.innerApiCalls.createJobTrigger = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.createJobTrigger(request), expectedError);
      assert(
        (client.innerApiCalls.createJobTrigger as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes createJobTrigger with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CreateJobTriggerRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.createJobTrigger(request), expectedError);
    });
  });

  describe('updateJobTrigger', () => {
    it('invokes updateJobTrigger without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.UpdateJobTriggerRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.JobTrigger()
      );
      client.innerApiCalls.updateJobTrigger = stubSimpleCall(expectedResponse);
      const [response] = await client.updateJobTrigger(request);
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.updateJobTrigger as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes updateJobTrigger without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.UpdateJobTriggerRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.JobTrigger()
      );
      client.innerApiCalls.updateJobTrigger =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.updateJobTrigger(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IJobTrigger | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.updateJobTrigger as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions /*, callback defined above */)
      );
    });

    it('invokes updateJobTrigger with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.UpdateJobTriggerRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedError = new Error('expected');
      client.innerApiCalls.updateJobTrigger = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.updateJobTrigger(request), expectedError);
      assert(
        (client.innerApiCalls.updateJobTrigger as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes updateJobTrigger with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.UpdateJobTriggerRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.updateJobTrigger(request), expectedError);
    });
  });

  describe('hybridInspectJobTrigger', () => {
    it('invokes hybridInspectJobTrigger without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.HybridInspectJobTriggerRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.HybridInspectResponse()
      );
      client.innerApiCalls.hybridInspectJobTrigger =
        stubSimpleCall(expectedResponse);
      const [response] = await client.hybridInspectJobTrigger(request);
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.hybridInspectJobTrigger as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes hybridInspectJobTrigger without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.HybridInspectJobTriggerRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.HybridInspectResponse()
      );
      client.innerApiCalls.hybridInspectJobTrigger =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.hybridInspectJobTrigger(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IHybridInspectResponse | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.hybridInspectJobTrigger as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions /*, callback defined above */)
      );
    });

    it('invokes hybridInspectJobTrigger with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.HybridInspectJobTriggerRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedError = new Error('expected');
      client.innerApiCalls.hybridInspectJobTrigger = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(
        client.hybridInspectJobTrigger(request),
        expectedError
      );
      assert(
        (client.innerApiCalls.hybridInspectJobTrigger as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes hybridInspectJobTrigger with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.HybridInspectJobTriggerRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(
        client.hybridInspectJobTrigger(request),
        expectedError
      );
    });
  });

  describe('getJobTrigger', () => {
    it('invokes getJobTrigger without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetJobTriggerRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.JobTrigger()
      );
      client.innerApiCalls.getJobTrigger = stubSimpleCall(expectedResponse);
      const [response] = await client.getJobTrigger(request);
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.getJobTrigger as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes getJobTrigger without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetJobTriggerRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.JobTrigger()
      );
      client.innerApiCalls.getJobTrigger =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.getJobTrigger(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IJobTrigger | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.getJobTrigger as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions /*, callback defined above */)
      );
    });

    it('invokes getJobTrigger with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetJobTriggerRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedError = new Error('expected');
      client.innerApiCalls.getJobTrigger = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.getJobTrigger(request), expectedError);
      assert(
        (client.innerApiCalls.getJobTrigger as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes getJobTrigger with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetJobTriggerRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.getJobTrigger(request), expectedError);
    });
  });

  describe('deleteJobTrigger', () => {
    it('invokes deleteJobTrigger without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteJobTriggerRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.protobuf.Empty()
      );
      client.innerApiCalls.deleteJobTrigger = stubSimpleCall(expectedResponse);
      const [response] = await client.deleteJobTrigger(request);
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.deleteJobTrigger as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes deleteJobTrigger without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteJobTriggerRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.protobuf.Empty()
      );
      client.innerApiCalls.deleteJobTrigger =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.deleteJobTrigger(
          request,
          (
            err?: Error | null,
            result?: protos.google.protobuf.IEmpty | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.deleteJobTrigger as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions /*, callback defined above */)
      );
    });

    it('invokes deleteJobTrigger with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteJobTriggerRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedError = new Error('expected');
      client.innerApiCalls.deleteJobTrigger = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.deleteJobTrigger(request), expectedError);
      assert(
        (client.innerApiCalls.deleteJobTrigger as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes deleteJobTrigger with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteJobTriggerRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.deleteJobTrigger(request), expectedError);
    });
  });

  describe('activateJobTrigger', () => {
    it('invokes activateJobTrigger without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ActivateJobTriggerRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DlpJob()
      );
      client.innerApiCalls.activateJobTrigger =
        stubSimpleCall(expectedResponse);
      const [response] = await client.activateJobTrigger(request);
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.activateJobTrigger as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes activateJobTrigger without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ActivateJobTriggerRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DlpJob()
      );
      client.innerApiCalls.activateJobTrigger =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.activateJobTrigger(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IDlpJob | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.activateJobTrigger as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions /*, callback defined above */)
      );
    });

    it('invokes activateJobTrigger with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ActivateJobTriggerRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedError = new Error('expected');
      client.innerApiCalls.activateJobTrigger = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.activateJobTrigger(request), expectedError);
      assert(
        (client.innerApiCalls.activateJobTrigger as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes activateJobTrigger with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ActivateJobTriggerRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.activateJobTrigger(request), expectedError);
    });
  });

  describe('createDlpJob', () => {
    it('invokes createDlpJob without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CreateDlpJobRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DlpJob()
      );
      client.innerApiCalls.createDlpJob = stubSimpleCall(expectedResponse);
      const [response] = await client.createDlpJob(request);
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.createDlpJob as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes createDlpJob without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CreateDlpJobRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DlpJob()
      );
      client.innerApiCalls.createDlpJob =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.createDlpJob(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IDlpJob | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.createDlpJob as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions /*, callback defined above */)
      );
    });

    it('invokes createDlpJob with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CreateDlpJobRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedError = new Error('expected');
      client.innerApiCalls.createDlpJob = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.createDlpJob(request), expectedError);
      assert(
        (client.innerApiCalls.createDlpJob as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes createDlpJob with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CreateDlpJobRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.createDlpJob(request), expectedError);
    });
  });

  describe('getDlpJob', () => {
    it('invokes getDlpJob without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetDlpJobRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DlpJob()
      );
      client.innerApiCalls.getDlpJob = stubSimpleCall(expectedResponse);
      const [response] = await client.getDlpJob(request);
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.getDlpJob as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes getDlpJob without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetDlpJobRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DlpJob()
      );
      client.innerApiCalls.getDlpJob =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.getDlpJob(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IDlpJob | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.getDlpJob as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions /*, callback defined above */)
      );
    });

    it('invokes getDlpJob with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetDlpJobRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedError = new Error('expected');
      client.innerApiCalls.getDlpJob = stubSimpleCall(undefined, expectedError);
      await assert.rejects(client.getDlpJob(request), expectedError);
      assert(
        (client.innerApiCalls.getDlpJob as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes getDlpJob with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetDlpJobRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.getDlpJob(request), expectedError);
    });
  });

  describe('deleteDlpJob', () => {
    it('invokes deleteDlpJob without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteDlpJobRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.protobuf.Empty()
      );
      client.innerApiCalls.deleteDlpJob = stubSimpleCall(expectedResponse);
      const [response] = await client.deleteDlpJob(request);
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.deleteDlpJob as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes deleteDlpJob without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteDlpJobRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.protobuf.Empty()
      );
      client.innerApiCalls.deleteDlpJob =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.deleteDlpJob(
          request,
          (
            err?: Error | null,
            result?: protos.google.protobuf.IEmpty | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.deleteDlpJob as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions /*, callback defined above */)
      );
    });

    it('invokes deleteDlpJob with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteDlpJobRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedError = new Error('expected');
      client.innerApiCalls.deleteDlpJob = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.deleteDlpJob(request), expectedError);
      assert(
        (client.innerApiCalls.deleteDlpJob as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes deleteDlpJob with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteDlpJobRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.deleteDlpJob(request), expectedError);
    });
  });

  describe('cancelDlpJob', () => {
    it('invokes cancelDlpJob without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CancelDlpJobRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.protobuf.Empty()
      );
      client.innerApiCalls.cancelDlpJob = stubSimpleCall(expectedResponse);
      const [response] = await client.cancelDlpJob(request);
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.cancelDlpJob as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes cancelDlpJob without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CancelDlpJobRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.protobuf.Empty()
      );
      client.innerApiCalls.cancelDlpJob =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.cancelDlpJob(
          request,
          (
            err?: Error | null,
            result?: protos.google.protobuf.IEmpty | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.cancelDlpJob as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions /*, callback defined above */)
      );
    });

    it('invokes cancelDlpJob with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CancelDlpJobRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedError = new Error('expected');
      client.innerApiCalls.cancelDlpJob = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.cancelDlpJob(request), expectedError);
      assert(
        (client.innerApiCalls.cancelDlpJob as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes cancelDlpJob with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CancelDlpJobRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.cancelDlpJob(request), expectedError);
    });
  });

  describe('createStoredInfoType', () => {
    it('invokes createStoredInfoType without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CreateStoredInfoTypeRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.StoredInfoType()
      );
      client.innerApiCalls.createStoredInfoType =
        stubSimpleCall(expectedResponse);
      const [response] = await client.createStoredInfoType(request);
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.createStoredInfoType as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes createStoredInfoType without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CreateStoredInfoTypeRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.StoredInfoType()
      );
      client.innerApiCalls.createStoredInfoType =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.createStoredInfoType(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IStoredInfoType | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.createStoredInfoType as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions /*, callback defined above */)
      );
    });

    it('invokes createStoredInfoType with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CreateStoredInfoTypeRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedError = new Error('expected');
      client.innerApiCalls.createStoredInfoType = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.createStoredInfoType(request), expectedError);
      assert(
        (client.innerApiCalls.createStoredInfoType as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes createStoredInfoType with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CreateStoredInfoTypeRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.createStoredInfoType(request), expectedError);
    });
  });

  describe('updateStoredInfoType', () => {
    it('invokes updateStoredInfoType without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.UpdateStoredInfoTypeRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.StoredInfoType()
      );
      client.innerApiCalls.updateStoredInfoType =
        stubSimpleCall(expectedResponse);
      const [response] = await client.updateStoredInfoType(request);
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.updateStoredInfoType as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes updateStoredInfoType without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.UpdateStoredInfoTypeRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.StoredInfoType()
      );
      client.innerApiCalls.updateStoredInfoType =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.updateStoredInfoType(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IStoredInfoType | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.updateStoredInfoType as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions /*, callback defined above */)
      );
    });

    it('invokes updateStoredInfoType with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.UpdateStoredInfoTypeRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedError = new Error('expected');
      client.innerApiCalls.updateStoredInfoType = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.updateStoredInfoType(request), expectedError);
      assert(
        (client.innerApiCalls.updateStoredInfoType as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes updateStoredInfoType with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.UpdateStoredInfoTypeRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.updateStoredInfoType(request), expectedError);
    });
  });

  describe('getStoredInfoType', () => {
    it('invokes getStoredInfoType without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetStoredInfoTypeRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.StoredInfoType()
      );
      client.innerApiCalls.getStoredInfoType = stubSimpleCall(expectedResponse);
      const [response] = await client.getStoredInfoType(request);
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.getStoredInfoType as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes getStoredInfoType without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetStoredInfoTypeRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.StoredInfoType()
      );
      client.innerApiCalls.getStoredInfoType =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.getStoredInfoType(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IStoredInfoType | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.getStoredInfoType as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions /*, callback defined above */)
      );
    });

    it('invokes getStoredInfoType with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetStoredInfoTypeRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedError = new Error('expected');
      client.innerApiCalls.getStoredInfoType = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.getStoredInfoType(request), expectedError);
      assert(
        (client.innerApiCalls.getStoredInfoType as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes getStoredInfoType with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetStoredInfoTypeRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.getStoredInfoType(request), expectedError);
    });
  });

  describe('deleteStoredInfoType', () => {
    it('invokes deleteStoredInfoType without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteStoredInfoTypeRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.protobuf.Empty()
      );
      client.innerApiCalls.deleteStoredInfoType =
        stubSimpleCall(expectedResponse);
      const [response] = await client.deleteStoredInfoType(request);
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.deleteStoredInfoType as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes deleteStoredInfoType without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteStoredInfoTypeRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.protobuf.Empty()
      );
      client.innerApiCalls.deleteStoredInfoType =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.deleteStoredInfoType(
          request,
          (
            err?: Error | null,
            result?: protos.google.protobuf.IEmpty | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.deleteStoredInfoType as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions /*, callback defined above */)
      );
    });

    it('invokes deleteStoredInfoType with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteStoredInfoTypeRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedError = new Error('expected');
      client.innerApiCalls.deleteStoredInfoType = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.deleteStoredInfoType(request), expectedError);
      assert(
        (client.innerApiCalls.deleteStoredInfoType as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes deleteStoredInfoType with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteStoredInfoTypeRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.deleteStoredInfoType(request), expectedError);
    });
  });

  describe('hybridInspectDlpJob', () => {
    it('invokes hybridInspectDlpJob without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.HybridInspectDlpJobRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.HybridInspectResponse()
      );
      client.innerApiCalls.hybridInspectDlpJob =
        stubSimpleCall(expectedResponse);
      const [response] = await client.hybridInspectDlpJob(request);
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.hybridInspectDlpJob as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes hybridInspectDlpJob without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.HybridInspectDlpJobRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.HybridInspectResponse()
      );
      client.innerApiCalls.hybridInspectDlpJob =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.hybridInspectDlpJob(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IHybridInspectResponse | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.hybridInspectDlpJob as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions /*, callback defined above */)
      );
    });

    it('invokes hybridInspectDlpJob with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.HybridInspectDlpJobRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedError = new Error('expected');
      client.innerApiCalls.hybridInspectDlpJob = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.hybridInspectDlpJob(request), expectedError);
      assert(
        (client.innerApiCalls.hybridInspectDlpJob as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes hybridInspectDlpJob with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.HybridInspectDlpJobRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.hybridInspectDlpJob(request), expectedError);
    });
  });

  describe('finishDlpJob', () => {
    it('invokes finishDlpJob without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.FinishDlpJobRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.protobuf.Empty()
      );
      client.innerApiCalls.finishDlpJob = stubSimpleCall(expectedResponse);
      const [response] = await client.finishDlpJob(request);
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.finishDlpJob as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes finishDlpJob without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.FinishDlpJobRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new protos.google.protobuf.Empty()
      );
      client.innerApiCalls.finishDlpJob =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.finishDlpJob(
          request,
          (
            err?: Error | null,
            result?: protos.google.protobuf.IEmpty | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.finishDlpJob as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions /*, callback defined above */)
      );
    });

    it('invokes finishDlpJob with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.FinishDlpJobRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedError = new Error('expected');
      client.innerApiCalls.finishDlpJob = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.finishDlpJob(request), expectedError);
      assert(
        (client.innerApiCalls.finishDlpJob as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes finishDlpJob with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.FinishDlpJobRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.finishDlpJob(request), expectedError);
    });
  });

  describe('listInspectTemplates', () => {
    it('invokes listInspectTemplates without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListInspectTemplatesRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = [
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.InspectTemplate()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.InspectTemplate()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.InspectTemplate()
        ),
      ];
      client.innerApiCalls.listInspectTemplates =
        stubSimpleCall(expectedResponse);
      const [response] = await client.listInspectTemplates(request);
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.listInspectTemplates as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes listInspectTemplates without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListInspectTemplatesRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = [
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.InspectTemplate()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.InspectTemplate()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.InspectTemplate()
        ),
      ];
      client.innerApiCalls.listInspectTemplates =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.listInspectTemplates(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IInspectTemplate[] | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.listInspectTemplates as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions /*, callback defined above */)
      );
    });

    it('invokes listInspectTemplates with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListInspectTemplatesRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedError = new Error('expected');
      client.innerApiCalls.listInspectTemplates = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.listInspectTemplates(request), expectedError);
      assert(
        (client.innerApiCalls.listInspectTemplates as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes listInspectTemplatesStream without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListInspectTemplatesRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedResponse = [
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.InspectTemplate()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.InspectTemplate()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.InspectTemplate()
        ),
      ];
      client.descriptors.page.listInspectTemplates.createStream =
        stubPageStreamingCall(expectedResponse);
      const stream = client.listInspectTemplatesStream(request);
      const promise = new Promise((resolve, reject) => {
        const responses: protos.google.privacy.dlp.v2.InspectTemplate[] = [];
        stream.on(
          'data',
          (response: protos.google.privacy.dlp.v2.InspectTemplate) => {
            responses.push(response);
          }
        );
        stream.on('end', () => {
          resolve(responses);
        });
        stream.on('error', (err: Error) => {
          reject(err);
        });
      });
      const responses = await promise;
      assert.deepStrictEqual(responses, expectedResponse);
      assert(
        (client.descriptors.page.listInspectTemplates.createStream as SinonStub)
          .getCall(0)
          .calledWith(client.innerApiCalls.listInspectTemplates, request)
      );
      assert.strictEqual(
        (
          client.descriptors.page.listInspectTemplates.createStream as SinonStub
        ).getCall(0).args[2].otherArgs.headers['x-goog-request-params'],
        expectedHeaderRequestParams
      );
    });

    it('invokes listInspectTemplatesStream with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListInspectTemplatesRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedError = new Error('expected');
      client.descriptors.page.listInspectTemplates.createStream =
        stubPageStreamingCall(undefined, expectedError);
      const stream = client.listInspectTemplatesStream(request);
      const promise = new Promise((resolve, reject) => {
        const responses: protos.google.privacy.dlp.v2.InspectTemplate[] = [];
        stream.on(
          'data',
          (response: protos.google.privacy.dlp.v2.InspectTemplate) => {
            responses.push(response);
          }
        );
        stream.on('end', () => {
          resolve(responses);
        });
        stream.on('error', (err: Error) => {
          reject(err);
        });
      });
      await assert.rejects(promise, expectedError);
      assert(
        (client.descriptors.page.listInspectTemplates.createStream as SinonStub)
          .getCall(0)
          .calledWith(client.innerApiCalls.listInspectTemplates, request)
      );
      assert.strictEqual(
        (
          client.descriptors.page.listInspectTemplates.createStream as SinonStub
        ).getCall(0).args[2].otherArgs.headers['x-goog-request-params'],
        expectedHeaderRequestParams
      );
    });

    it('uses async iteration with listInspectTemplates without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListInspectTemplatesRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedResponse = [
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.InspectTemplate()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.InspectTemplate()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.InspectTemplate()
        ),
      ];
      client.descriptors.page.listInspectTemplates.asyncIterate =
        stubAsyncIterationCall(expectedResponse);
      const responses: protos.google.privacy.dlp.v2.IInspectTemplate[] = [];
      const iterable = client.listInspectTemplatesAsync(request);
      for await (const resource of iterable) {
        responses.push(resource!);
      }
      assert.deepStrictEqual(responses, expectedResponse);
      assert.deepStrictEqual(
        (
          client.descriptors.page.listInspectTemplates.asyncIterate as SinonStub
        ).getCall(0).args[1],
        request
      );
      assert.strictEqual(
        (
          client.descriptors.page.listInspectTemplates.asyncIterate as SinonStub
        ).getCall(0).args[2].otherArgs.headers['x-goog-request-params'],
        expectedHeaderRequestParams
      );
    });

    it('uses async iteration with listInspectTemplates with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListInspectTemplatesRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedError = new Error('expected');
      client.descriptors.page.listInspectTemplates.asyncIterate =
        stubAsyncIterationCall(undefined, expectedError);
      const iterable = client.listInspectTemplatesAsync(request);
      await assert.rejects(async () => {
        const responses: protos.google.privacy.dlp.v2.IInspectTemplate[] = [];
        for await (const resource of iterable) {
          responses.push(resource!);
        }
      });
      assert.deepStrictEqual(
        (
          client.descriptors.page.listInspectTemplates.asyncIterate as SinonStub
        ).getCall(0).args[1],
        request
      );
      assert.strictEqual(
        (
          client.descriptors.page.listInspectTemplates.asyncIterate as SinonStub
        ).getCall(0).args[2].otherArgs.headers['x-goog-request-params'],
        expectedHeaderRequestParams
      );
    });
  });

  describe('listDeidentifyTemplates', () => {
    it('invokes listDeidentifyTemplates without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListDeidentifyTemplatesRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = [
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.DeidentifyTemplate()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.DeidentifyTemplate()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.DeidentifyTemplate()
        ),
      ];
      client.innerApiCalls.listDeidentifyTemplates =
        stubSimpleCall(expectedResponse);
      const [response] = await client.listDeidentifyTemplates(request);
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.listDeidentifyTemplates as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes listDeidentifyTemplates without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListDeidentifyTemplatesRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = [
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.DeidentifyTemplate()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.DeidentifyTemplate()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.DeidentifyTemplate()
        ),
      ];
      client.innerApiCalls.listDeidentifyTemplates =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.listDeidentifyTemplates(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IDeidentifyTemplate[] | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.listDeidentifyTemplates as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions /*, callback defined above */)
      );
    });

    it('invokes listDeidentifyTemplates with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListDeidentifyTemplatesRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedError = new Error('expected');
      client.innerApiCalls.listDeidentifyTemplates = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(
        client.listDeidentifyTemplates(request),
        expectedError
      );
      assert(
        (client.innerApiCalls.listDeidentifyTemplates as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes listDeidentifyTemplatesStream without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListDeidentifyTemplatesRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedResponse = [
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.DeidentifyTemplate()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.DeidentifyTemplate()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.DeidentifyTemplate()
        ),
      ];
      client.descriptors.page.listDeidentifyTemplates.createStream =
        stubPageStreamingCall(expectedResponse);
      const stream = client.listDeidentifyTemplatesStream(request);
      const promise = new Promise((resolve, reject) => {
        const responses: protos.google.privacy.dlp.v2.DeidentifyTemplate[] = [];
        stream.on(
          'data',
          (response: protos.google.privacy.dlp.v2.DeidentifyTemplate) => {
            responses.push(response);
          }
        );
        stream.on('end', () => {
          resolve(responses);
        });
        stream.on('error', (err: Error) => {
          reject(err);
        });
      });
      const responses = await promise;
      assert.deepStrictEqual(responses, expectedResponse);
      assert(
        (
          client.descriptors.page.listDeidentifyTemplates
            .createStream as SinonStub
        )
          .getCall(0)
          .calledWith(client.innerApiCalls.listDeidentifyTemplates, request)
      );
      assert.strictEqual(
        (
          client.descriptors.page.listDeidentifyTemplates
            .createStream as SinonStub
        ).getCall(0).args[2].otherArgs.headers['x-goog-request-params'],
        expectedHeaderRequestParams
      );
    });

    it('invokes listDeidentifyTemplatesStream with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListDeidentifyTemplatesRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedError = new Error('expected');
      client.descriptors.page.listDeidentifyTemplates.createStream =
        stubPageStreamingCall(undefined, expectedError);
      const stream = client.listDeidentifyTemplatesStream(request);
      const promise = new Promise((resolve, reject) => {
        const responses: protos.google.privacy.dlp.v2.DeidentifyTemplate[] = [];
        stream.on(
          'data',
          (response: protos.google.privacy.dlp.v2.DeidentifyTemplate) => {
            responses.push(response);
          }
        );
        stream.on('end', () => {
          resolve(responses);
        });
        stream.on('error', (err: Error) => {
          reject(err);
        });
      });
      await assert.rejects(promise, expectedError);
      assert(
        (
          client.descriptors.page.listDeidentifyTemplates
            .createStream as SinonStub
        )
          .getCall(0)
          .calledWith(client.innerApiCalls.listDeidentifyTemplates, request)
      );
      assert.strictEqual(
        (
          client.descriptors.page.listDeidentifyTemplates
            .createStream as SinonStub
        ).getCall(0).args[2].otherArgs.headers['x-goog-request-params'],
        expectedHeaderRequestParams
      );
    });

    it('uses async iteration with listDeidentifyTemplates without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListDeidentifyTemplatesRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedResponse = [
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.DeidentifyTemplate()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.DeidentifyTemplate()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.DeidentifyTemplate()
        ),
      ];
      client.descriptors.page.listDeidentifyTemplates.asyncIterate =
        stubAsyncIterationCall(expectedResponse);
      const responses: protos.google.privacy.dlp.v2.IDeidentifyTemplate[] = [];
      const iterable = client.listDeidentifyTemplatesAsync(request);
      for await (const resource of iterable) {
        responses.push(resource!);
      }
      assert.deepStrictEqual(responses, expectedResponse);
      assert.deepStrictEqual(
        (
          client.descriptors.page.listDeidentifyTemplates
            .asyncIterate as SinonStub
        ).getCall(0).args[1],
        request
      );
      assert.strictEqual(
        (
          client.descriptors.page.listDeidentifyTemplates
            .asyncIterate as SinonStub
        ).getCall(0).args[2].otherArgs.headers['x-goog-request-params'],
        expectedHeaderRequestParams
      );
    });

    it('uses async iteration with listDeidentifyTemplates with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListDeidentifyTemplatesRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedError = new Error('expected');
      client.descriptors.page.listDeidentifyTemplates.asyncIterate =
        stubAsyncIterationCall(undefined, expectedError);
      const iterable = client.listDeidentifyTemplatesAsync(request);
      await assert.rejects(async () => {
        const responses: protos.google.privacy.dlp.v2.IDeidentifyTemplate[] =
          [];
        for await (const resource of iterable) {
          responses.push(resource!);
        }
      });
      assert.deepStrictEqual(
        (
          client.descriptors.page.listDeidentifyTemplates
            .asyncIterate as SinonStub
        ).getCall(0).args[1],
        request
      );
      assert.strictEqual(
        (
          client.descriptors.page.listDeidentifyTemplates
            .asyncIterate as SinonStub
        ).getCall(0).args[2].otherArgs.headers['x-goog-request-params'],
        expectedHeaderRequestParams
      );
    });
  });

  describe('listJobTriggers', () => {
    it('invokes listJobTriggers without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListJobTriggersRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = [
        generateSampleMessage(new protos.google.privacy.dlp.v2.JobTrigger()),
        generateSampleMessage(new protos.google.privacy.dlp.v2.JobTrigger()),
        generateSampleMessage(new protos.google.privacy.dlp.v2.JobTrigger()),
      ];
      client.innerApiCalls.listJobTriggers = stubSimpleCall(expectedResponse);
      const [response] = await client.listJobTriggers(request);
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.listJobTriggers as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes listJobTriggers without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListJobTriggersRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = [
        generateSampleMessage(new protos.google.privacy.dlp.v2.JobTrigger()),
        generateSampleMessage(new protos.google.privacy.dlp.v2.JobTrigger()),
        generateSampleMessage(new protos.google.privacy.dlp.v2.JobTrigger()),
      ];
      client.innerApiCalls.listJobTriggers =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.listJobTriggers(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IJobTrigger[] | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.listJobTriggers as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions /*, callback defined above */)
      );
    });

    it('invokes listJobTriggers with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListJobTriggersRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedError = new Error('expected');
      client.innerApiCalls.listJobTriggers = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.listJobTriggers(request), expectedError);
      assert(
        (client.innerApiCalls.listJobTriggers as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes listJobTriggersStream without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListJobTriggersRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedResponse = [
        generateSampleMessage(new protos.google.privacy.dlp.v2.JobTrigger()),
        generateSampleMessage(new protos.google.privacy.dlp.v2.JobTrigger()),
        generateSampleMessage(new protos.google.privacy.dlp.v2.JobTrigger()),
      ];
      client.descriptors.page.listJobTriggers.createStream =
        stubPageStreamingCall(expectedResponse);
      const stream = client.listJobTriggersStream(request);
      const promise = new Promise((resolve, reject) => {
        const responses: protos.google.privacy.dlp.v2.JobTrigger[] = [];
        stream.on(
          'data',
          (response: protos.google.privacy.dlp.v2.JobTrigger) => {
            responses.push(response);
          }
        );
        stream.on('end', () => {
          resolve(responses);
        });
        stream.on('error', (err: Error) => {
          reject(err);
        });
      });
      const responses = await promise;
      assert.deepStrictEqual(responses, expectedResponse);
      assert(
        (client.descriptors.page.listJobTriggers.createStream as SinonStub)
          .getCall(0)
          .calledWith(client.innerApiCalls.listJobTriggers, request)
      );
      assert.strictEqual(
        (
          client.descriptors.page.listJobTriggers.createStream as SinonStub
        ).getCall(0).args[2].otherArgs.headers['x-goog-request-params'],
        expectedHeaderRequestParams
      );
    });

    it('invokes listJobTriggersStream with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListJobTriggersRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedError = new Error('expected');
      client.descriptors.page.listJobTriggers.createStream =
        stubPageStreamingCall(undefined, expectedError);
      const stream = client.listJobTriggersStream(request);
      const promise = new Promise((resolve, reject) => {
        const responses: protos.google.privacy.dlp.v2.JobTrigger[] = [];
        stream.on(
          'data',
          (response: protos.google.privacy.dlp.v2.JobTrigger) => {
            responses.push(response);
          }
        );
        stream.on('end', () => {
          resolve(responses);
        });
        stream.on('error', (err: Error) => {
          reject(err);
        });
      });
      await assert.rejects(promise, expectedError);
      assert(
        (client.descriptors.page.listJobTriggers.createStream as SinonStub)
          .getCall(0)
          .calledWith(client.innerApiCalls.listJobTriggers, request)
      );
      assert.strictEqual(
        (
          client.descriptors.page.listJobTriggers.createStream as SinonStub
        ).getCall(0).args[2].otherArgs.headers['x-goog-request-params'],
        expectedHeaderRequestParams
      );
    });

    it('uses async iteration with listJobTriggers without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListJobTriggersRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedResponse = [
        generateSampleMessage(new protos.google.privacy.dlp.v2.JobTrigger()),
        generateSampleMessage(new protos.google.privacy.dlp.v2.JobTrigger()),
        generateSampleMessage(new protos.google.privacy.dlp.v2.JobTrigger()),
      ];
      client.descriptors.page.listJobTriggers.asyncIterate =
        stubAsyncIterationCall(expectedResponse);
      const responses: protos.google.privacy.dlp.v2.IJobTrigger[] = [];
      const iterable = client.listJobTriggersAsync(request);
      for await (const resource of iterable) {
        responses.push(resource!);
      }
      assert.deepStrictEqual(responses, expectedResponse);
      assert.deepStrictEqual(
        (
          client.descriptors.page.listJobTriggers.asyncIterate as SinonStub
        ).getCall(0).args[1],
        request
      );
      assert.strictEqual(
        (
          client.descriptors.page.listJobTriggers.asyncIterate as SinonStub
        ).getCall(0).args[2].otherArgs.headers['x-goog-request-params'],
        expectedHeaderRequestParams
      );
    });

    it('uses async iteration with listJobTriggers with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListJobTriggersRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedError = new Error('expected');
      client.descriptors.page.listJobTriggers.asyncIterate =
        stubAsyncIterationCall(undefined, expectedError);
      const iterable = client.listJobTriggersAsync(request);
      await assert.rejects(async () => {
        const responses: protos.google.privacy.dlp.v2.IJobTrigger[] = [];
        for await (const resource of iterable) {
          responses.push(resource!);
        }
      });
      assert.deepStrictEqual(
        (
          client.descriptors.page.listJobTriggers.asyncIterate as SinonStub
        ).getCall(0).args[1],
        request
      );
      assert.strictEqual(
        (
          client.descriptors.page.listJobTriggers.asyncIterate as SinonStub
        ).getCall(0).args[2].otherArgs.headers['x-goog-request-params'],
        expectedHeaderRequestParams
      );
    });
  });

  describe('listDlpJobs', () => {
    it('invokes listDlpJobs without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListDlpJobsRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = [
        generateSampleMessage(new protos.google.privacy.dlp.v2.DlpJob()),
        generateSampleMessage(new protos.google.privacy.dlp.v2.DlpJob()),
        generateSampleMessage(new protos.google.privacy.dlp.v2.DlpJob()),
      ];
      client.innerApiCalls.listDlpJobs = stubSimpleCall(expectedResponse);
      const [response] = await client.listDlpJobs(request);
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.listDlpJobs as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes listDlpJobs without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListDlpJobsRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = [
        generateSampleMessage(new protos.google.privacy.dlp.v2.DlpJob()),
        generateSampleMessage(new protos.google.privacy.dlp.v2.DlpJob()),
        generateSampleMessage(new protos.google.privacy.dlp.v2.DlpJob()),
      ];
      client.innerApiCalls.listDlpJobs =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.listDlpJobs(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IDlpJob[] | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.listDlpJobs as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions /*, callback defined above */)
      );
    });

    it('invokes listDlpJobs with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListDlpJobsRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedError = new Error('expected');
      client.innerApiCalls.listDlpJobs = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.listDlpJobs(request), expectedError);
      assert(
        (client.innerApiCalls.listDlpJobs as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes listDlpJobsStream without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListDlpJobsRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedResponse = [
        generateSampleMessage(new protos.google.privacy.dlp.v2.DlpJob()),
        generateSampleMessage(new protos.google.privacy.dlp.v2.DlpJob()),
        generateSampleMessage(new protos.google.privacy.dlp.v2.DlpJob()),
      ];
      client.descriptors.page.listDlpJobs.createStream =
        stubPageStreamingCall(expectedResponse);
      const stream = client.listDlpJobsStream(request);
      const promise = new Promise((resolve, reject) => {
        const responses: protos.google.privacy.dlp.v2.DlpJob[] = [];
        stream.on('data', (response: protos.google.privacy.dlp.v2.DlpJob) => {
          responses.push(response);
        });
        stream.on('end', () => {
          resolve(responses);
        });
        stream.on('error', (err: Error) => {
          reject(err);
        });
      });
      const responses = await promise;
      assert.deepStrictEqual(responses, expectedResponse);
      assert(
        (client.descriptors.page.listDlpJobs.createStream as SinonStub)
          .getCall(0)
          .calledWith(client.innerApiCalls.listDlpJobs, request)
      );
      assert.strictEqual(
        (client.descriptors.page.listDlpJobs.createStream as SinonStub).getCall(
          0
        ).args[2].otherArgs.headers['x-goog-request-params'],
        expectedHeaderRequestParams
      );
    });

    it('invokes listDlpJobsStream with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListDlpJobsRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedError = new Error('expected');
      client.descriptors.page.listDlpJobs.createStream = stubPageStreamingCall(
        undefined,
        expectedError
      );
      const stream = client.listDlpJobsStream(request);
      const promise = new Promise((resolve, reject) => {
        const responses: protos.google.privacy.dlp.v2.DlpJob[] = [];
        stream.on('data', (response: protos.google.privacy.dlp.v2.DlpJob) => {
          responses.push(response);
        });
        stream.on('end', () => {
          resolve(responses);
        });
        stream.on('error', (err: Error) => {
          reject(err);
        });
      });
      await assert.rejects(promise, expectedError);
      assert(
        (client.descriptors.page.listDlpJobs.createStream as SinonStub)
          .getCall(0)
          .calledWith(client.innerApiCalls.listDlpJobs, request)
      );
      assert.strictEqual(
        (client.descriptors.page.listDlpJobs.createStream as SinonStub).getCall(
          0
        ).args[2].otherArgs.headers['x-goog-request-params'],
        expectedHeaderRequestParams
      );
    });

    it('uses async iteration with listDlpJobs without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListDlpJobsRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedResponse = [
        generateSampleMessage(new protos.google.privacy.dlp.v2.DlpJob()),
        generateSampleMessage(new protos.google.privacy.dlp.v2.DlpJob()),
        generateSampleMessage(new protos.google.privacy.dlp.v2.DlpJob()),
      ];
      client.descriptors.page.listDlpJobs.asyncIterate =
        stubAsyncIterationCall(expectedResponse);
      const responses: protos.google.privacy.dlp.v2.IDlpJob[] = [];
      const iterable = client.listDlpJobsAsync(request);
      for await (const resource of iterable) {
        responses.push(resource!);
      }
      assert.deepStrictEqual(responses, expectedResponse);
      assert.deepStrictEqual(
        (client.descriptors.page.listDlpJobs.asyncIterate as SinonStub).getCall(
          0
        ).args[1],
        request
      );
      assert.strictEqual(
        (client.descriptors.page.listDlpJobs.asyncIterate as SinonStub).getCall(
          0
        ).args[2].otherArgs.headers['x-goog-request-params'],
        expectedHeaderRequestParams
      );
    });

    it('uses async iteration with listDlpJobs with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListDlpJobsRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedError = new Error('expected');
      client.descriptors.page.listDlpJobs.asyncIterate = stubAsyncIterationCall(
        undefined,
        expectedError
      );
      const iterable = client.listDlpJobsAsync(request);
      await assert.rejects(async () => {
        const responses: protos.google.privacy.dlp.v2.IDlpJob[] = [];
        for await (const resource of iterable) {
          responses.push(resource!);
        }
      });
      assert.deepStrictEqual(
        (client.descriptors.page.listDlpJobs.asyncIterate as SinonStub).getCall(
          0
        ).args[1],
        request
      );
      assert.strictEqual(
        (client.descriptors.page.listDlpJobs.asyncIterate as SinonStub).getCall(
          0
        ).args[2].otherArgs.headers['x-goog-request-params'],
        expectedHeaderRequestParams
      );
    });
  });

  describe('listStoredInfoTypes', () => {
    it('invokes listStoredInfoTypes without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListStoredInfoTypesRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = [
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.StoredInfoType()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.StoredInfoType()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.StoredInfoType()
        ),
      ];
      client.innerApiCalls.listStoredInfoTypes =
        stubSimpleCall(expectedResponse);
      const [response] = await client.listStoredInfoTypes(request);
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.listStoredInfoTypes as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes listStoredInfoTypes without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListStoredInfoTypesRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = [
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.StoredInfoType()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.StoredInfoType()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.StoredInfoType()
        ),
      ];
      client.innerApiCalls.listStoredInfoTypes =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.listStoredInfoTypes(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IStoredInfoType[] | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      assert(
        (client.innerApiCalls.listStoredInfoTypes as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions /*, callback defined above */)
      );
    });

    it('invokes listStoredInfoTypes with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListStoredInfoTypesRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedError = new Error('expected');
      client.innerApiCalls.listStoredInfoTypes = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.listStoredInfoTypes(request), expectedError);
      assert(
        (client.innerApiCalls.listStoredInfoTypes as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });

    it('invokes listStoredInfoTypesStream without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListStoredInfoTypesRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedResponse = [
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.StoredInfoType()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.StoredInfoType()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.StoredInfoType()
        ),
      ];
      client.descriptors.page.listStoredInfoTypes.createStream =
        stubPageStreamingCall(expectedResponse);
      const stream = client.listStoredInfoTypesStream(request);
      const promise = new Promise((resolve, reject) => {
        const responses: protos.google.privacy.dlp.v2.StoredInfoType[] = [];
        stream.on(
          'data',
          (response: protos.google.privacy.dlp.v2.StoredInfoType) => {
            responses.push(response);
          }
        );
        stream.on('end', () => {
          resolve(responses);
        });
        stream.on('error', (err: Error) => {
          reject(err);
        });
      });
      const responses = await promise;
      assert.deepStrictEqual(responses, expectedResponse);
      assert(
        (client.descriptors.page.listStoredInfoTypes.createStream as SinonStub)
          .getCall(0)
          .calledWith(client.innerApiCalls.listStoredInfoTypes, request)
      );
      assert.strictEqual(
        (
          client.descriptors.page.listStoredInfoTypes.createStream as SinonStub
        ).getCall(0).args[2].otherArgs.headers['x-goog-request-params'],
        expectedHeaderRequestParams
      );
    });

    it('invokes listStoredInfoTypesStream with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListStoredInfoTypesRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedError = new Error('expected');
      client.descriptors.page.listStoredInfoTypes.createStream =
        stubPageStreamingCall(undefined, expectedError);
      const stream = client.listStoredInfoTypesStream(request);
      const promise = new Promise((resolve, reject) => {
        const responses: protos.google.privacy.dlp.v2.StoredInfoType[] = [];
        stream.on(
          'data',
          (response: protos.google.privacy.dlp.v2.StoredInfoType) => {
            responses.push(response);
          }
        );
        stream.on('end', () => {
          resolve(responses);
        });
        stream.on('error', (err: Error) => {
          reject(err);
        });
      });
      await assert.rejects(promise, expectedError);
      assert(
        (client.descriptors.page.listStoredInfoTypes.createStream as SinonStub)
          .getCall(0)
          .calledWith(client.innerApiCalls.listStoredInfoTypes, request)
      );
      assert.strictEqual(
        (
          client.descriptors.page.listStoredInfoTypes.createStream as SinonStub
        ).getCall(0).args[2].otherArgs.headers['x-goog-request-params'],
        expectedHeaderRequestParams
      );
    });

    it('uses async iteration with listStoredInfoTypes without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListStoredInfoTypesRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedResponse = [
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.StoredInfoType()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.StoredInfoType()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.StoredInfoType()
        ),
      ];
      client.descriptors.page.listStoredInfoTypes.asyncIterate =
        stubAsyncIterationCall(expectedResponse);
      const responses: protos.google.privacy.dlp.v2.IStoredInfoType[] = [];
      const iterable = client.listStoredInfoTypesAsync(request);
      for await (const resource of iterable) {
        responses.push(resource!);
      }
      assert.deepStrictEqual(responses, expectedResponse);
      assert.deepStrictEqual(
        (
          client.descriptors.page.listStoredInfoTypes.asyncIterate as SinonStub
        ).getCall(0).args[1],
        request
      );
      assert.strictEqual(
        (
          client.descriptors.page.listStoredInfoTypes.asyncIterate as SinonStub
        ).getCall(0).args[2].otherArgs.headers['x-goog-request-params'],
        expectedHeaderRequestParams
      );
    });

    it('uses async iteration with listStoredInfoTypes with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListStoredInfoTypesRequest()
      );
      request.parent = '';
      const expectedHeaderRequestParams = 'parent=';
      const expectedError = new Error('expected');
      client.descriptors.page.listStoredInfoTypes.asyncIterate =
        stubAsyncIterationCall(undefined, expectedError);
      const iterable = client.listStoredInfoTypesAsync(request);
      await assert.rejects(async () => {
        const responses: protos.google.privacy.dlp.v2.IStoredInfoType[] = [];
        for await (const resource of iterable) {
          responses.push(resource!);
        }
      });
      assert.deepStrictEqual(
        (
          client.descriptors.page.listStoredInfoTypes.asyncIterate as SinonStub
        ).getCall(0).args[1],
        request
      );
      assert.strictEqual(
        (
          client.descriptors.page.listStoredInfoTypes.asyncIterate as SinonStub
        ).getCall(0).args[2].otherArgs.headers['x-goog-request-params'],
        expectedHeaderRequestParams
      );
    });
  });

  describe('Path templates', () => {
    describe('finding', () => {
      const fakePath = '/rendered/path/finding';
      const expectedParameters = {
        project: 'projectValue',
        location: 'locationValue',
        finding: 'findingValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.findingPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.findingPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('findingPath', () => {
        const result = client.findingPath(
          'projectValue',
          'locationValue',
          'findingValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (client.pathTemplates.findingPathTemplate.render as SinonStub)
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchProjectFromFindingName', () => {
        const result = client.matchProjectFromFindingName(fakePath);
        assert.strictEqual(result, 'projectValue');
        assert(
          (client.pathTemplates.findingPathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchLocationFromFindingName', () => {
        const result = client.matchLocationFromFindingName(fakePath);
        assert.strictEqual(result, 'locationValue');
        assert(
          (client.pathTemplates.findingPathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchFindingFromFindingName', () => {
        const result = client.matchFindingFromFindingName(fakePath);
        assert.strictEqual(result, 'findingValue');
        assert(
          (client.pathTemplates.findingPathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('organization', () => {
      const fakePath = '/rendered/path/organization';
      const expectedParameters = {
        organization: 'organizationValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.organizationPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.organizationPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('organizationPath', () => {
        const result = client.organizationPath('organizationValue');
        assert.strictEqual(result, fakePath);
        assert(
          (client.pathTemplates.organizationPathTemplate.render as SinonStub)
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchOrganizationFromOrganizationName', () => {
        const result = client.matchOrganizationFromOrganizationName(fakePath);
        assert.strictEqual(result, 'organizationValue');
        assert(
          (client.pathTemplates.organizationPathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('organizationDeidentifyTemplate', () => {
      const fakePath = '/rendered/path/organizationDeidentifyTemplate';
      const expectedParameters = {
        organization: 'organizationValue',
        deidentify_template: 'deidentifyTemplateValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.organizationDeidentifyTemplatePathTemplate.render =
        sinon.stub().returns(fakePath);
      client.pathTemplates.organizationDeidentifyTemplatePathTemplate.match =
        sinon.stub().returns(expectedParameters);

      it('organizationDeidentifyTemplatePath', () => {
        const result = client.organizationDeidentifyTemplatePath(
          'organizationValue',
          'deidentifyTemplateValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.organizationDeidentifyTemplatePathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchOrganizationFromOrganizationDeidentifyTemplateName', () => {
        const result =
          client.matchOrganizationFromOrganizationDeidentifyTemplateName(
            fakePath
          );
        assert.strictEqual(result, 'organizationValue');
        assert(
          (
            client.pathTemplates.organizationDeidentifyTemplatePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchDeidentifyTemplateFromOrganizationDeidentifyTemplateName', () => {
        const result =
          client.matchDeidentifyTemplateFromOrganizationDeidentifyTemplateName(
            fakePath
          );
        assert.strictEqual(result, 'deidentifyTemplateValue');
        assert(
          (
            client.pathTemplates.organizationDeidentifyTemplatePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('organizationInspectTemplate', () => {
      const fakePath = '/rendered/path/organizationInspectTemplate';
      const expectedParameters = {
        organization: 'organizationValue',
        inspect_template: 'inspectTemplateValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.organizationInspectTemplatePathTemplate.render =
        sinon.stub().returns(fakePath);
      client.pathTemplates.organizationInspectTemplatePathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('organizationInspectTemplatePath', () => {
        const result = client.organizationInspectTemplatePath(
          'organizationValue',
          'inspectTemplateValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.organizationInspectTemplatePathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchOrganizationFromOrganizationInspectTemplateName', () => {
        const result =
          client.matchOrganizationFromOrganizationInspectTemplateName(fakePath);
        assert.strictEqual(result, 'organizationValue');
        assert(
          (
            client.pathTemplates.organizationInspectTemplatePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchInspectTemplateFromOrganizationInspectTemplateName', () => {
        const result =
          client.matchInspectTemplateFromOrganizationInspectTemplateName(
            fakePath
          );
        assert.strictEqual(result, 'inspectTemplateValue');
        assert(
          (
            client.pathTemplates.organizationInspectTemplatePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('organizationLocationDeidentifyTemplate', () => {
      const fakePath = '/rendered/path/organizationLocationDeidentifyTemplate';
      const expectedParameters = {
        organization: 'organizationValue',
        location: 'locationValue',
        deidentify_template: 'deidentifyTemplateValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.organizationLocationDeidentifyTemplatePathTemplate.render =
        sinon.stub().returns(fakePath);
      client.pathTemplates.organizationLocationDeidentifyTemplatePathTemplate.match =
        sinon.stub().returns(expectedParameters);

      it('organizationLocationDeidentifyTemplatePath', () => {
        const result = client.organizationLocationDeidentifyTemplatePath(
          'organizationValue',
          'locationValue',
          'deidentifyTemplateValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates
              .organizationLocationDeidentifyTemplatePathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchOrganizationFromOrganizationLocationDeidentifyTemplateName', () => {
        const result =
          client.matchOrganizationFromOrganizationLocationDeidentifyTemplateName(
            fakePath
          );
        assert.strictEqual(result, 'organizationValue');
        assert(
          (
            client.pathTemplates
              .organizationLocationDeidentifyTemplatePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchLocationFromOrganizationLocationDeidentifyTemplateName', () => {
        const result =
          client.matchLocationFromOrganizationLocationDeidentifyTemplateName(
            fakePath
          );
        assert.strictEqual(result, 'locationValue');
        assert(
          (
            client.pathTemplates
              .organizationLocationDeidentifyTemplatePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchDeidentifyTemplateFromOrganizationLocationDeidentifyTemplateName', () => {
        const result =
          client.matchDeidentifyTemplateFromOrganizationLocationDeidentifyTemplateName(
            fakePath
          );
        assert.strictEqual(result, 'deidentifyTemplateValue');
        assert(
          (
            client.pathTemplates
              .organizationLocationDeidentifyTemplatePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('organizationLocationInspectTemplate', () => {
      const fakePath = '/rendered/path/organizationLocationInspectTemplate';
      const expectedParameters = {
        organization: 'organizationValue',
        location: 'locationValue',
        inspect_template: 'inspectTemplateValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.organizationLocationInspectTemplatePathTemplate.render =
        sinon.stub().returns(fakePath);
      client.pathTemplates.organizationLocationInspectTemplatePathTemplate.match =
        sinon.stub().returns(expectedParameters);

      it('organizationLocationInspectTemplatePath', () => {
        const result = client.organizationLocationInspectTemplatePath(
          'organizationValue',
          'locationValue',
          'inspectTemplateValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.organizationLocationInspectTemplatePathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchOrganizationFromOrganizationLocationInspectTemplateName', () => {
        const result =
          client.matchOrganizationFromOrganizationLocationInspectTemplateName(
            fakePath
          );
        assert.strictEqual(result, 'organizationValue');
        assert(
          (
            client.pathTemplates.organizationLocationInspectTemplatePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchLocationFromOrganizationLocationInspectTemplateName', () => {
        const result =
          client.matchLocationFromOrganizationLocationInspectTemplateName(
            fakePath
          );
        assert.strictEqual(result, 'locationValue');
        assert(
          (
            client.pathTemplates.organizationLocationInspectTemplatePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchInspectTemplateFromOrganizationLocationInspectTemplateName', () => {
        const result =
          client.matchInspectTemplateFromOrganizationLocationInspectTemplateName(
            fakePath
          );
        assert.strictEqual(result, 'inspectTemplateValue');
        assert(
          (
            client.pathTemplates.organizationLocationInspectTemplatePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('organizationLocationStoredInfoType', () => {
      const fakePath = '/rendered/path/organizationLocationStoredInfoType';
      const expectedParameters = {
        organization: 'organizationValue',
        location: 'locationValue',
        stored_info_type: 'storedInfoTypeValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.organizationLocationStoredInfoTypePathTemplate.render =
        sinon.stub().returns(fakePath);
      client.pathTemplates.organizationLocationStoredInfoTypePathTemplate.match =
        sinon.stub().returns(expectedParameters);

      it('organizationLocationStoredInfoTypePath', () => {
        const result = client.organizationLocationStoredInfoTypePath(
          'organizationValue',
          'locationValue',
          'storedInfoTypeValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.organizationLocationStoredInfoTypePathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchOrganizationFromOrganizationLocationStoredInfoTypeName', () => {
        const result =
          client.matchOrganizationFromOrganizationLocationStoredInfoTypeName(
            fakePath
          );
        assert.strictEqual(result, 'organizationValue');
        assert(
          (
            client.pathTemplates.organizationLocationStoredInfoTypePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchLocationFromOrganizationLocationStoredInfoTypeName', () => {
        const result =
          client.matchLocationFromOrganizationLocationStoredInfoTypeName(
            fakePath
          );
        assert.strictEqual(result, 'locationValue');
        assert(
          (
            client.pathTemplates.organizationLocationStoredInfoTypePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchStoredInfoTypeFromOrganizationLocationStoredInfoTypeName', () => {
        const result =
          client.matchStoredInfoTypeFromOrganizationLocationStoredInfoTypeName(
            fakePath
          );
        assert.strictEqual(result, 'storedInfoTypeValue');
        assert(
          (
            client.pathTemplates.organizationLocationStoredInfoTypePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('organizationStoredInfoType', () => {
      const fakePath = '/rendered/path/organizationStoredInfoType';
      const expectedParameters = {
        organization: 'organizationValue',
        stored_info_type: 'storedInfoTypeValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.organizationStoredInfoTypePathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.organizationStoredInfoTypePathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('organizationStoredInfoTypePath', () => {
        const result = client.organizationStoredInfoTypePath(
          'organizationValue',
          'storedInfoTypeValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.organizationStoredInfoTypePathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchOrganizationFromOrganizationStoredInfoTypeName', () => {
        const result =
          client.matchOrganizationFromOrganizationStoredInfoTypeName(fakePath);
        assert.strictEqual(result, 'organizationValue');
        assert(
          (
            client.pathTemplates.organizationStoredInfoTypePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchStoredInfoTypeFromOrganizationStoredInfoTypeName', () => {
        const result =
          client.matchStoredInfoTypeFromOrganizationStoredInfoTypeName(
            fakePath
          );
        assert.strictEqual(result, 'storedInfoTypeValue');
        assert(
          (
            client.pathTemplates.organizationStoredInfoTypePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('project', () => {
      const fakePath = '/rendered/path/project';
      const expectedParameters = {
        project: 'projectValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.projectPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.projectPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('projectPath', () => {
        const result = client.projectPath('projectValue');
        assert.strictEqual(result, fakePath);
        assert(
          (client.pathTemplates.projectPathTemplate.render as SinonStub)
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchProjectFromProjectName', () => {
        const result = client.matchProjectFromProjectName(fakePath);
        assert.strictEqual(result, 'projectValue');
        assert(
          (client.pathTemplates.projectPathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('projectDeidentifyTemplate', () => {
      const fakePath = '/rendered/path/projectDeidentifyTemplate';
      const expectedParameters = {
        project: 'projectValue',
        deidentify_template: 'deidentifyTemplateValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.projectDeidentifyTemplatePathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.projectDeidentifyTemplatePathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('projectDeidentifyTemplatePath', () => {
        const result = client.projectDeidentifyTemplatePath(
          'projectValue',
          'deidentifyTemplateValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.projectDeidentifyTemplatePathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchProjectFromProjectDeidentifyTemplateName', () => {
        const result =
          client.matchProjectFromProjectDeidentifyTemplateName(fakePath);
        assert.strictEqual(result, 'projectValue');
        assert(
          (
            client.pathTemplates.projectDeidentifyTemplatePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchDeidentifyTemplateFromProjectDeidentifyTemplateName', () => {
        const result =
          client.matchDeidentifyTemplateFromProjectDeidentifyTemplateName(
            fakePath
          );
        assert.strictEqual(result, 'deidentifyTemplateValue');
        assert(
          (
            client.pathTemplates.projectDeidentifyTemplatePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('projectDlpContent', () => {
      const fakePath = '/rendered/path/projectDlpContent';
      const expectedParameters = {
        project: 'projectValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.projectDlpContentPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.projectDlpContentPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('projectDlpContentPath', () => {
        const result = client.projectDlpContentPath('projectValue');
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.projectDlpContentPathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchProjectFromProjectDlpContentName', () => {
        const result = client.matchProjectFromProjectDlpContentName(fakePath);
        assert.strictEqual(result, 'projectValue');
        assert(
          (
            client.pathTemplates.projectDlpContentPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('projectDlpJob', () => {
      const fakePath = '/rendered/path/projectDlpJob';
      const expectedParameters = {
        project: 'projectValue',
        dlp_job: 'dlpJobValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.projectDlpJobPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.projectDlpJobPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('projectDlpJobPath', () => {
        const result = client.projectDlpJobPath('projectValue', 'dlpJobValue');
        assert.strictEqual(result, fakePath);
        assert(
          (client.pathTemplates.projectDlpJobPathTemplate.render as SinonStub)
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchProjectFromProjectDlpJobName', () => {
        const result = client.matchProjectFromProjectDlpJobName(fakePath);
        assert.strictEqual(result, 'projectValue');
        assert(
          (client.pathTemplates.projectDlpJobPathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchDlpJobFromProjectDlpJobName', () => {
        const result = client.matchDlpJobFromProjectDlpJobName(fakePath);
        assert.strictEqual(result, 'dlpJobValue');
        assert(
          (client.pathTemplates.projectDlpJobPathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('projectInspectTemplate', () => {
      const fakePath = '/rendered/path/projectInspectTemplate';
      const expectedParameters = {
        project: 'projectValue',
        inspect_template: 'inspectTemplateValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.projectInspectTemplatePathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.projectInspectTemplatePathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('projectInspectTemplatePath', () => {
        const result = client.projectInspectTemplatePath(
          'projectValue',
          'inspectTemplateValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.projectInspectTemplatePathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchProjectFromProjectInspectTemplateName', () => {
        const result =
          client.matchProjectFromProjectInspectTemplateName(fakePath);
        assert.strictEqual(result, 'projectValue');
        assert(
          (
            client.pathTemplates.projectInspectTemplatePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchInspectTemplateFromProjectInspectTemplateName', () => {
        const result =
          client.matchInspectTemplateFromProjectInspectTemplateName(fakePath);
        assert.strictEqual(result, 'inspectTemplateValue');
        assert(
          (
            client.pathTemplates.projectInspectTemplatePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('projectJobTrigger', () => {
      const fakePath = '/rendered/path/projectJobTrigger';
      const expectedParameters = {
        project: 'projectValue',
        job_trigger: 'jobTriggerValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.projectJobTriggerPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.projectJobTriggerPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('projectJobTriggerPath', () => {
        const result = client.projectJobTriggerPath(
          'projectValue',
          'jobTriggerValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.projectJobTriggerPathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchProjectFromProjectJobTriggerName', () => {
        const result = client.matchProjectFromProjectJobTriggerName(fakePath);
        assert.strictEqual(result, 'projectValue');
        assert(
          (
            client.pathTemplates.projectJobTriggerPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchJobTriggerFromProjectJobTriggerName', () => {
        const result =
          client.matchJobTriggerFromProjectJobTriggerName(fakePath);
        assert.strictEqual(result, 'jobTriggerValue');
        assert(
          (
            client.pathTemplates.projectJobTriggerPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('projectLocationDeidentifyTemplate', () => {
      const fakePath = '/rendered/path/projectLocationDeidentifyTemplate';
      const expectedParameters = {
        project: 'projectValue',
        location: 'locationValue',
        deidentify_template: 'deidentifyTemplateValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.projectLocationDeidentifyTemplatePathTemplate.render =
        sinon.stub().returns(fakePath);
      client.pathTemplates.projectLocationDeidentifyTemplatePathTemplate.match =
        sinon.stub().returns(expectedParameters);

      it('projectLocationDeidentifyTemplatePath', () => {
        const result = client.projectLocationDeidentifyTemplatePath(
          'projectValue',
          'locationValue',
          'deidentifyTemplateValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.projectLocationDeidentifyTemplatePathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchProjectFromProjectLocationDeidentifyTemplateName', () => {
        const result =
          client.matchProjectFromProjectLocationDeidentifyTemplateName(
            fakePath
          );
        assert.strictEqual(result, 'projectValue');
        assert(
          (
            client.pathTemplates.projectLocationDeidentifyTemplatePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchLocationFromProjectLocationDeidentifyTemplateName', () => {
        const result =
          client.matchLocationFromProjectLocationDeidentifyTemplateName(
            fakePath
          );
        assert.strictEqual(result, 'locationValue');
        assert(
          (
            client.pathTemplates.projectLocationDeidentifyTemplatePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchDeidentifyTemplateFromProjectLocationDeidentifyTemplateName', () => {
        const result =
          client.matchDeidentifyTemplateFromProjectLocationDeidentifyTemplateName(
            fakePath
          );
        assert.strictEqual(result, 'deidentifyTemplateValue');
        assert(
          (
            client.pathTemplates.projectLocationDeidentifyTemplatePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('projectLocationDlpJob', () => {
      const fakePath = '/rendered/path/projectLocationDlpJob';
      const expectedParameters = {
        project: 'projectValue',
        location: 'locationValue',
        dlp_job: 'dlpJobValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.projectLocationDlpJobPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.projectLocationDlpJobPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('projectLocationDlpJobPath', () => {
        const result = client.projectLocationDlpJobPath(
          'projectValue',
          'locationValue',
          'dlpJobValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.projectLocationDlpJobPathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchProjectFromProjectLocationDlpJobName', () => {
        const result =
          client.matchProjectFromProjectLocationDlpJobName(fakePath);
        assert.strictEqual(result, 'projectValue');
        assert(
          (
            client.pathTemplates.projectLocationDlpJobPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchLocationFromProjectLocationDlpJobName', () => {
        const result =
          client.matchLocationFromProjectLocationDlpJobName(fakePath);
        assert.strictEqual(result, 'locationValue');
        assert(
          (
            client.pathTemplates.projectLocationDlpJobPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchDlpJobFromProjectLocationDlpJobName', () => {
        const result =
          client.matchDlpJobFromProjectLocationDlpJobName(fakePath);
        assert.strictEqual(result, 'dlpJobValue');
        assert(
          (
            client.pathTemplates.projectLocationDlpJobPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('projectLocationInspectTemplate', () => {
      const fakePath = '/rendered/path/projectLocationInspectTemplate';
      const expectedParameters = {
        project: 'projectValue',
        location: 'locationValue',
        inspect_template: 'inspectTemplateValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.projectLocationInspectTemplatePathTemplate.render =
        sinon.stub().returns(fakePath);
      client.pathTemplates.projectLocationInspectTemplatePathTemplate.match =
        sinon.stub().returns(expectedParameters);

      it('projectLocationInspectTemplatePath', () => {
        const result = client.projectLocationInspectTemplatePath(
          'projectValue',
          'locationValue',
          'inspectTemplateValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.projectLocationInspectTemplatePathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchProjectFromProjectLocationInspectTemplateName', () => {
        const result =
          client.matchProjectFromProjectLocationInspectTemplateName(fakePath);
        assert.strictEqual(result, 'projectValue');
        assert(
          (
            client.pathTemplates.projectLocationInspectTemplatePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchLocationFromProjectLocationInspectTemplateName', () => {
        const result =
          client.matchLocationFromProjectLocationInspectTemplateName(fakePath);
        assert.strictEqual(result, 'locationValue');
        assert(
          (
            client.pathTemplates.projectLocationInspectTemplatePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchInspectTemplateFromProjectLocationInspectTemplateName', () => {
        const result =
          client.matchInspectTemplateFromProjectLocationInspectTemplateName(
            fakePath
          );
        assert.strictEqual(result, 'inspectTemplateValue');
        assert(
          (
            client.pathTemplates.projectLocationInspectTemplatePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('projectLocationJobTrigger', () => {
      const fakePath = '/rendered/path/projectLocationJobTrigger';
      const expectedParameters = {
        project: 'projectValue',
        location: 'locationValue',
        job_trigger: 'jobTriggerValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.projectLocationJobTriggerPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.projectLocationJobTriggerPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('projectLocationJobTriggerPath', () => {
        const result = client.projectLocationJobTriggerPath(
          'projectValue',
          'locationValue',
          'jobTriggerValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.projectLocationJobTriggerPathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchProjectFromProjectLocationJobTriggerName', () => {
        const result =
          client.matchProjectFromProjectLocationJobTriggerName(fakePath);
        assert.strictEqual(result, 'projectValue');
        assert(
          (
            client.pathTemplates.projectLocationJobTriggerPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchLocationFromProjectLocationJobTriggerName', () => {
        const result =
          client.matchLocationFromProjectLocationJobTriggerName(fakePath);
        assert.strictEqual(result, 'locationValue');
        assert(
          (
            client.pathTemplates.projectLocationJobTriggerPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchJobTriggerFromProjectLocationJobTriggerName', () => {
        const result =
          client.matchJobTriggerFromProjectLocationJobTriggerName(fakePath);
        assert.strictEqual(result, 'jobTriggerValue');
        assert(
          (
            client.pathTemplates.projectLocationJobTriggerPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('projectLocationStoredInfoType', () => {
      const fakePath = '/rendered/path/projectLocationStoredInfoType';
      const expectedParameters = {
        project: 'projectValue',
        location: 'locationValue',
        stored_info_type: 'storedInfoTypeValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.projectLocationStoredInfoTypePathTemplate.render =
        sinon.stub().returns(fakePath);
      client.pathTemplates.projectLocationStoredInfoTypePathTemplate.match =
        sinon.stub().returns(expectedParameters);

      it('projectLocationStoredInfoTypePath', () => {
        const result = client.projectLocationStoredInfoTypePath(
          'projectValue',
          'locationValue',
          'storedInfoTypeValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.projectLocationStoredInfoTypePathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchProjectFromProjectLocationStoredInfoTypeName', () => {
        const result =
          client.matchProjectFromProjectLocationStoredInfoTypeName(fakePath);
        assert.strictEqual(result, 'projectValue');
        assert(
          (
            client.pathTemplates.projectLocationStoredInfoTypePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchLocationFromProjectLocationStoredInfoTypeName', () => {
        const result =
          client.matchLocationFromProjectLocationStoredInfoTypeName(fakePath);
        assert.strictEqual(result, 'locationValue');
        assert(
          (
            client.pathTemplates.projectLocationStoredInfoTypePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchStoredInfoTypeFromProjectLocationStoredInfoTypeName', () => {
        const result =
          client.matchStoredInfoTypeFromProjectLocationStoredInfoTypeName(
            fakePath
          );
        assert.strictEqual(result, 'storedInfoTypeValue');
        assert(
          (
            client.pathTemplates.projectLocationStoredInfoTypePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('projectStoredInfoType', () => {
      const fakePath = '/rendered/path/projectStoredInfoType';
      const expectedParameters = {
        project: 'projectValue',
        stored_info_type: 'storedInfoTypeValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.projectStoredInfoTypePathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.projectStoredInfoTypePathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('projectStoredInfoTypePath', () => {
        const result = client.projectStoredInfoTypePath(
          'projectValue',
          'storedInfoTypeValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.projectStoredInfoTypePathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchProjectFromProjectStoredInfoTypeName', () => {
        const result =
          client.matchProjectFromProjectStoredInfoTypeName(fakePath);
        assert.strictEqual(result, 'projectValue');
        assert(
          (
            client.pathTemplates.projectStoredInfoTypePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchStoredInfoTypeFromProjectStoredInfoTypeName', () => {
        const result =
          client.matchStoredInfoTypeFromProjectStoredInfoTypeName(fakePath);
        assert.strictEqual(result, 'storedInfoTypeValue');
        assert(
          (
            client.pathTemplates.projectStoredInfoTypePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });
  });
});
