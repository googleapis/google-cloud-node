// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// ** This file is automatically generated by gapic-generator-typescript. **
// ** https://github.com/googleapis/gapic-generator-typescript **
// ** All changes to this file may be overwritten. **

import * as protos from '../protos/protos';
import * as assert from 'assert';
import * as sinon from 'sinon';
import {SinonStub} from 'sinon';
import {describe, it} from 'mocha';
import * as dlpserviceModule from '../src';

import {PassThrough} from 'stream';

import {protobuf, LocationProtos} from 'google-gax';

// Dynamically loaded proto JSON is needed to get the type information
// to fill in default values for request objects
const root = protobuf.Root.fromJSON(
  require('../protos/protos.json')
).resolveAll();

// eslint-disable-next-line @typescript-eslint/no-unused-vars
function getTypeDefaultValue(typeName: string, fields: string[]) {
  let type = root.lookupType(typeName) as protobuf.Type;
  for (const field of fields.slice(0, -1)) {
    type = type.fields[field]?.resolvedType as protobuf.Type;
  }
  return type.fields[fields[fields.length - 1]]?.defaultValue;
}

function generateSampleMessage<T extends object>(instance: T) {
  const filledObject = (
    instance.constructor as typeof protobuf.Message
  ).toObject(instance as protobuf.Message<T>, {defaults: true});
  return (instance.constructor as typeof protobuf.Message).fromObject(
    filledObject
  ) as T;
}

function stubSimpleCall<ResponseType>(response?: ResponseType, error?: Error) {
  return error
    ? sinon.stub().rejects(error)
    : sinon.stub().resolves([response]);
}

function stubSimpleCallWithCallback<ResponseType>(
  response?: ResponseType,
  error?: Error
) {
  return error
    ? sinon.stub().callsArgWith(2, error)
    : sinon.stub().callsArgWith(2, null, response);
}

function stubPageStreamingCall<ResponseType>(
  responses?: ResponseType[],
  error?: Error
) {
  const pagingStub = sinon.stub();
  if (responses) {
    for (let i = 0; i < responses.length; ++i) {
      pagingStub.onCall(i).callsArgWith(2, null, responses[i]);
    }
  }
  const transformStub = error
    ? sinon.stub().callsArgWith(2, error)
    : pagingStub;
  const mockStream = new PassThrough({
    objectMode: true,
    transform: transformStub,
  });
  // trigger as many responses as needed
  if (responses) {
    for (let i = 0; i < responses.length; ++i) {
      setImmediate(() => {
        mockStream.write({});
      });
    }
    setImmediate(() => {
      mockStream.end();
    });
  } else {
    setImmediate(() => {
      mockStream.write({});
    });
    setImmediate(() => {
      mockStream.end();
    });
  }
  return sinon.stub().returns(mockStream);
}

function stubAsyncIterationCall<ResponseType>(
  responses?: ResponseType[],
  error?: Error
) {
  let counter = 0;
  const asyncIterable = {
    [Symbol.asyncIterator]() {
      return {
        async next() {
          if (error) {
            return Promise.reject(error);
          }
          if (counter >= responses!.length) {
            return Promise.resolve({done: true, value: undefined});
          }
          return Promise.resolve({done: false, value: responses![counter++]});
        },
      };
    },
  };
  return sinon.stub().returns(asyncIterable);
}

describe('v2.DlpServiceClient', () => {
  describe('Common methods', () => {
    it('has apiEndpoint', () => {
      const client = new dlpserviceModule.v2.DlpServiceClient();
      const apiEndpoint = client.apiEndpoint;
      assert.strictEqual(apiEndpoint, 'dlp.googleapis.com');
    });

    it('has universeDomain', () => {
      const client = new dlpserviceModule.v2.DlpServiceClient();
      const universeDomain = client.universeDomain;
      assert.strictEqual(universeDomain, 'googleapis.com');
    });

    if (
      typeof process === 'object' &&
      typeof process.emitWarning === 'function'
    ) {
      it('throws DeprecationWarning if static servicePath is used', () => {
        const stub = sinon.stub(process, 'emitWarning');
        const servicePath = dlpserviceModule.v2.DlpServiceClient.servicePath;
        assert.strictEqual(servicePath, 'dlp.googleapis.com');
        assert(stub.called);
        stub.restore();
      });

      it('throws DeprecationWarning if static apiEndpoint is used', () => {
        const stub = sinon.stub(process, 'emitWarning');
        const apiEndpoint = dlpserviceModule.v2.DlpServiceClient.apiEndpoint;
        assert.strictEqual(apiEndpoint, 'dlp.googleapis.com');
        assert(stub.called);
        stub.restore();
      });
    }
    it('sets apiEndpoint according to universe domain camelCase', () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        universeDomain: 'example.com',
      });
      const servicePath = client.apiEndpoint;
      assert.strictEqual(servicePath, 'dlp.example.com');
    });

    it('sets apiEndpoint according to universe domain snakeCase', () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        universe_domain: 'example.com',
      });
      const servicePath = client.apiEndpoint;
      assert.strictEqual(servicePath, 'dlp.example.com');
    });

    if (typeof process === 'object' && 'env' in process) {
      describe('GOOGLE_CLOUD_UNIVERSE_DOMAIN environment variable', () => {
        it('sets apiEndpoint from environment variable', () => {
          const saved = process.env['GOOGLE_CLOUD_UNIVERSE_DOMAIN'];
          process.env['GOOGLE_CLOUD_UNIVERSE_DOMAIN'] = 'example.com';
          const client = new dlpserviceModule.v2.DlpServiceClient();
          const servicePath = client.apiEndpoint;
          assert.strictEqual(servicePath, 'dlp.example.com');
          if (saved) {
            process.env['GOOGLE_CLOUD_UNIVERSE_DOMAIN'] = saved;
          } else {
            delete process.env['GOOGLE_CLOUD_UNIVERSE_DOMAIN'];
          }
        });

        it('value configured in code has priority over environment variable', () => {
          const saved = process.env['GOOGLE_CLOUD_UNIVERSE_DOMAIN'];
          process.env['GOOGLE_CLOUD_UNIVERSE_DOMAIN'] = 'example.com';
          const client = new dlpserviceModule.v2.DlpServiceClient({
            universeDomain: 'configured.example.com',
          });
          const servicePath = client.apiEndpoint;
          assert.strictEqual(servicePath, 'dlp.configured.example.com');
          if (saved) {
            process.env['GOOGLE_CLOUD_UNIVERSE_DOMAIN'] = saved;
          } else {
            delete process.env['GOOGLE_CLOUD_UNIVERSE_DOMAIN'];
          }
        });
      });
    }
    it('does not allow setting both universeDomain and universe_domain', () => {
      assert.throws(() => {
        new dlpserviceModule.v2.DlpServiceClient({
          universe_domain: 'example.com',
          universeDomain: 'example.net',
        });
      });
    });

    it('has port', () => {
      const port = dlpserviceModule.v2.DlpServiceClient.port;
      assert(port);
      assert(typeof port === 'number');
    });

    it('should create a client with no option', () => {
      const client = new dlpserviceModule.v2.DlpServiceClient();
      assert(client);
    });

    it('should create a client with gRPC fallback', () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        fallback: true,
      });
      assert(client);
    });

    it('has initialize method and supports deferred initialization', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      assert.strictEqual(client.dlpServiceStub, undefined);
      await client.initialize();
      assert(client.dlpServiceStub);
    });

    it('has close method for the initialized client', done => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      assert(client.dlpServiceStub);
      client.close().then(() => {
        done();
      });
    });

    it('has close method for the non-initialized client', done => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      assert.strictEqual(client.dlpServiceStub, undefined);
      client.close().then(() => {
        done();
      });
    });

    it('has getProjectId method', async () => {
      const fakeProjectId = 'fake-project-id';
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.auth.getProjectId = sinon.stub().resolves(fakeProjectId);
      const result = await client.getProjectId();
      assert.strictEqual(result, fakeProjectId);
      assert((client.auth.getProjectId as SinonStub).calledWithExactly());
    });

    it('has getProjectId method with callback', async () => {
      const fakeProjectId = 'fake-project-id';
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.auth.getProjectId = sinon
        .stub()
        .callsArgWith(0, null, fakeProjectId);
      const promise = new Promise((resolve, reject) => {
        client.getProjectId((err?: Error | null, projectId?: string | null) => {
          if (err) {
            reject(err);
          } else {
            resolve(projectId);
          }
        });
      });
      const result = await promise;
      assert.strictEqual(result, fakeProjectId);
    });
  });

  describe('inspectContent', () => {
    it('invokes inspectContent without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.InspectContentRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.InspectContentRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.InspectContentResponse()
      );
      client.innerApiCalls.inspectContent = stubSimpleCall(expectedResponse);
      const [response] = await client.inspectContent(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.inspectContent as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.inspectContent as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes inspectContent without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.InspectContentRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.InspectContentRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.InspectContentResponse()
      );
      client.innerApiCalls.inspectContent =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.inspectContent(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IInspectContentResponse | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.inspectContent as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.inspectContent as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes inspectContent with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.InspectContentRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.InspectContentRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.inspectContent = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.inspectContent(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.inspectContent as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.inspectContent as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes inspectContent with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.InspectContentRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.InspectContentRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.inspectContent(request), expectedError);
    });
  });

  describe('redactImage', () => {
    it('invokes redactImage without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.RedactImageRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.RedactImageRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.RedactImageResponse()
      );
      client.innerApiCalls.redactImage = stubSimpleCall(expectedResponse);
      const [response] = await client.redactImage(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.redactImage as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.redactImage as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes redactImage without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.RedactImageRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.RedactImageRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.RedactImageResponse()
      );
      client.innerApiCalls.redactImage =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.redactImage(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IRedactImageResponse | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.redactImage as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.redactImage as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes redactImage with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.RedactImageRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.RedactImageRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.redactImage = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.redactImage(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.redactImage as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.redactImage as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes redactImage with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.RedactImageRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.RedactImageRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.redactImage(request), expectedError);
    });
  });

  describe('deidentifyContent', () => {
    it('invokes deidentifyContent without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeidentifyContentRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.DeidentifyContentRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeidentifyContentResponse()
      );
      client.innerApiCalls.deidentifyContent = stubSimpleCall(expectedResponse);
      const [response] = await client.deidentifyContent(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.deidentifyContent as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deidentifyContent as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deidentifyContent without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeidentifyContentRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.DeidentifyContentRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeidentifyContentResponse()
      );
      client.innerApiCalls.deidentifyContent =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.deidentifyContent(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IDeidentifyContentResponse | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.deidentifyContent as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deidentifyContent as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deidentifyContent with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeidentifyContentRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.DeidentifyContentRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.deidentifyContent = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.deidentifyContent(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.deidentifyContent as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deidentifyContent as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deidentifyContent with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeidentifyContentRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.DeidentifyContentRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.deidentifyContent(request), expectedError);
    });
  });

  describe('reidentifyContent', () => {
    it('invokes reidentifyContent without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ReidentifyContentRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ReidentifyContentRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ReidentifyContentResponse()
      );
      client.innerApiCalls.reidentifyContent = stubSimpleCall(expectedResponse);
      const [response] = await client.reidentifyContent(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.reidentifyContent as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.reidentifyContent as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes reidentifyContent without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ReidentifyContentRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ReidentifyContentRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ReidentifyContentResponse()
      );
      client.innerApiCalls.reidentifyContent =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.reidentifyContent(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IReidentifyContentResponse | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.reidentifyContent as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.reidentifyContent as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes reidentifyContent with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ReidentifyContentRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ReidentifyContentRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.reidentifyContent = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.reidentifyContent(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.reidentifyContent as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.reidentifyContent as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes reidentifyContent with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ReidentifyContentRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ReidentifyContentRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.reidentifyContent(request), expectedError);
    });
  });

  describe('listInfoTypes', () => {
    it('invokes listInfoTypes without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListInfoTypesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListInfoTypesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListInfoTypesResponse()
      );
      client.innerApiCalls.listInfoTypes = stubSimpleCall(expectedResponse);
      const [response] = await client.listInfoTypes(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.listInfoTypes as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listInfoTypes as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listInfoTypes without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListInfoTypesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListInfoTypesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListInfoTypesResponse()
      );
      client.innerApiCalls.listInfoTypes =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.listInfoTypes(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IListInfoTypesResponse | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.listInfoTypes as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listInfoTypes as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listInfoTypes with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListInfoTypesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListInfoTypesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.listInfoTypes = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.listInfoTypes(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.listInfoTypes as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listInfoTypes as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listInfoTypes with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListInfoTypesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListInfoTypesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.listInfoTypes(request), expectedError);
    });
  });

  describe('createInspectTemplate', () => {
    it('invokes createInspectTemplate without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CreateInspectTemplateRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.CreateInspectTemplateRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.InspectTemplate()
      );
      client.innerApiCalls.createInspectTemplate =
        stubSimpleCall(expectedResponse);
      const [response] = await client.createInspectTemplate(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.createInspectTemplate as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.createInspectTemplate as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes createInspectTemplate without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CreateInspectTemplateRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.CreateInspectTemplateRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.InspectTemplate()
      );
      client.innerApiCalls.createInspectTemplate =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.createInspectTemplate(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IInspectTemplate | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.createInspectTemplate as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.createInspectTemplate as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes createInspectTemplate with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CreateInspectTemplateRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.CreateInspectTemplateRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.createInspectTemplate = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(
        client.createInspectTemplate(request),
        expectedError
      );
      const actualRequest = (
        client.innerApiCalls.createInspectTemplate as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.createInspectTemplate as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes createInspectTemplate with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CreateInspectTemplateRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.CreateInspectTemplateRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(
        client.createInspectTemplate(request),
        expectedError
      );
    });
  });

  describe('updateInspectTemplate', () => {
    it('invokes updateInspectTemplate without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.UpdateInspectTemplateRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.UpdateInspectTemplateRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.InspectTemplate()
      );
      client.innerApiCalls.updateInspectTemplate =
        stubSimpleCall(expectedResponse);
      const [response] = await client.updateInspectTemplate(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.updateInspectTemplate as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.updateInspectTemplate as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes updateInspectTemplate without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.UpdateInspectTemplateRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.UpdateInspectTemplateRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.InspectTemplate()
      );
      client.innerApiCalls.updateInspectTemplate =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.updateInspectTemplate(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IInspectTemplate | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.updateInspectTemplate as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.updateInspectTemplate as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes updateInspectTemplate with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.UpdateInspectTemplateRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.UpdateInspectTemplateRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.updateInspectTemplate = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(
        client.updateInspectTemplate(request),
        expectedError
      );
      const actualRequest = (
        client.innerApiCalls.updateInspectTemplate as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.updateInspectTemplate as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes updateInspectTemplate with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.UpdateInspectTemplateRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.UpdateInspectTemplateRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(
        client.updateInspectTemplate(request),
        expectedError
      );
    });
  });

  describe('getInspectTemplate', () => {
    it('invokes getInspectTemplate without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetInspectTemplateRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.GetInspectTemplateRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.InspectTemplate()
      );
      client.innerApiCalls.getInspectTemplate =
        stubSimpleCall(expectedResponse);
      const [response] = await client.getInspectTemplate(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.getInspectTemplate as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getInspectTemplate as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getInspectTemplate without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetInspectTemplateRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.GetInspectTemplateRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.InspectTemplate()
      );
      client.innerApiCalls.getInspectTemplate =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.getInspectTemplate(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IInspectTemplate | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.getInspectTemplate as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getInspectTemplate as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getInspectTemplate with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetInspectTemplateRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.GetInspectTemplateRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.getInspectTemplate = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.getInspectTemplate(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.getInspectTemplate as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getInspectTemplate as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getInspectTemplate with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetInspectTemplateRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.GetInspectTemplateRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.getInspectTemplate(request), expectedError);
    });
  });

  describe('deleteInspectTemplate', () => {
    it('invokes deleteInspectTemplate without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteInspectTemplateRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.DeleteInspectTemplateRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.protobuf.Empty()
      );
      client.innerApiCalls.deleteInspectTemplate =
        stubSimpleCall(expectedResponse);
      const [response] = await client.deleteInspectTemplate(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.deleteInspectTemplate as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deleteInspectTemplate as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deleteInspectTemplate without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteInspectTemplateRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.DeleteInspectTemplateRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.protobuf.Empty()
      );
      client.innerApiCalls.deleteInspectTemplate =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.deleteInspectTemplate(
          request,
          (
            err?: Error | null,
            result?: protos.google.protobuf.IEmpty | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.deleteInspectTemplate as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deleteInspectTemplate as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deleteInspectTemplate with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteInspectTemplateRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.DeleteInspectTemplateRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.deleteInspectTemplate = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(
        client.deleteInspectTemplate(request),
        expectedError
      );
      const actualRequest = (
        client.innerApiCalls.deleteInspectTemplate as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deleteInspectTemplate as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deleteInspectTemplate with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteInspectTemplateRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.DeleteInspectTemplateRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(
        client.deleteInspectTemplate(request),
        expectedError
      );
    });
  });

  describe('createDeidentifyTemplate', () => {
    it('invokes createDeidentifyTemplate without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CreateDeidentifyTemplateRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.CreateDeidentifyTemplateRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeidentifyTemplate()
      );
      client.innerApiCalls.createDeidentifyTemplate =
        stubSimpleCall(expectedResponse);
      const [response] = await client.createDeidentifyTemplate(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.createDeidentifyTemplate as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.createDeidentifyTemplate as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes createDeidentifyTemplate without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CreateDeidentifyTemplateRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.CreateDeidentifyTemplateRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeidentifyTemplate()
      );
      client.innerApiCalls.createDeidentifyTemplate =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.createDeidentifyTemplate(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IDeidentifyTemplate | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.createDeidentifyTemplate as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.createDeidentifyTemplate as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes createDeidentifyTemplate with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CreateDeidentifyTemplateRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.CreateDeidentifyTemplateRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.createDeidentifyTemplate = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(
        client.createDeidentifyTemplate(request),
        expectedError
      );
      const actualRequest = (
        client.innerApiCalls.createDeidentifyTemplate as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.createDeidentifyTemplate as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes createDeidentifyTemplate with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CreateDeidentifyTemplateRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.CreateDeidentifyTemplateRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(
        client.createDeidentifyTemplate(request),
        expectedError
      );
    });
  });

  describe('updateDeidentifyTemplate', () => {
    it('invokes updateDeidentifyTemplate without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.UpdateDeidentifyTemplateRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.UpdateDeidentifyTemplateRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeidentifyTemplate()
      );
      client.innerApiCalls.updateDeidentifyTemplate =
        stubSimpleCall(expectedResponse);
      const [response] = await client.updateDeidentifyTemplate(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.updateDeidentifyTemplate as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.updateDeidentifyTemplate as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes updateDeidentifyTemplate without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.UpdateDeidentifyTemplateRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.UpdateDeidentifyTemplateRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeidentifyTemplate()
      );
      client.innerApiCalls.updateDeidentifyTemplate =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.updateDeidentifyTemplate(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IDeidentifyTemplate | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.updateDeidentifyTemplate as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.updateDeidentifyTemplate as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes updateDeidentifyTemplate with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.UpdateDeidentifyTemplateRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.UpdateDeidentifyTemplateRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.updateDeidentifyTemplate = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(
        client.updateDeidentifyTemplate(request),
        expectedError
      );
      const actualRequest = (
        client.innerApiCalls.updateDeidentifyTemplate as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.updateDeidentifyTemplate as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes updateDeidentifyTemplate with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.UpdateDeidentifyTemplateRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.UpdateDeidentifyTemplateRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(
        client.updateDeidentifyTemplate(request),
        expectedError
      );
    });
  });

  describe('getDeidentifyTemplate', () => {
    it('invokes getDeidentifyTemplate without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetDeidentifyTemplateRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.GetDeidentifyTemplateRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeidentifyTemplate()
      );
      client.innerApiCalls.getDeidentifyTemplate =
        stubSimpleCall(expectedResponse);
      const [response] = await client.getDeidentifyTemplate(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.getDeidentifyTemplate as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getDeidentifyTemplate as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getDeidentifyTemplate without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetDeidentifyTemplateRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.GetDeidentifyTemplateRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeidentifyTemplate()
      );
      client.innerApiCalls.getDeidentifyTemplate =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.getDeidentifyTemplate(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IDeidentifyTemplate | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.getDeidentifyTemplate as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getDeidentifyTemplate as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getDeidentifyTemplate with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetDeidentifyTemplateRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.GetDeidentifyTemplateRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.getDeidentifyTemplate = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(
        client.getDeidentifyTemplate(request),
        expectedError
      );
      const actualRequest = (
        client.innerApiCalls.getDeidentifyTemplate as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getDeidentifyTemplate as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getDeidentifyTemplate with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetDeidentifyTemplateRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.GetDeidentifyTemplateRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(
        client.getDeidentifyTemplate(request),
        expectedError
      );
    });
  });

  describe('deleteDeidentifyTemplate', () => {
    it('invokes deleteDeidentifyTemplate without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteDeidentifyTemplateRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.DeleteDeidentifyTemplateRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.protobuf.Empty()
      );
      client.innerApiCalls.deleteDeidentifyTemplate =
        stubSimpleCall(expectedResponse);
      const [response] = await client.deleteDeidentifyTemplate(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.deleteDeidentifyTemplate as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deleteDeidentifyTemplate as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deleteDeidentifyTemplate without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteDeidentifyTemplateRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.DeleteDeidentifyTemplateRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.protobuf.Empty()
      );
      client.innerApiCalls.deleteDeidentifyTemplate =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.deleteDeidentifyTemplate(
          request,
          (
            err?: Error | null,
            result?: protos.google.protobuf.IEmpty | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.deleteDeidentifyTemplate as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deleteDeidentifyTemplate as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deleteDeidentifyTemplate with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteDeidentifyTemplateRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.DeleteDeidentifyTemplateRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.deleteDeidentifyTemplate = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(
        client.deleteDeidentifyTemplate(request),
        expectedError
      );
      const actualRequest = (
        client.innerApiCalls.deleteDeidentifyTemplate as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deleteDeidentifyTemplate as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deleteDeidentifyTemplate with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteDeidentifyTemplateRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.DeleteDeidentifyTemplateRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(
        client.deleteDeidentifyTemplate(request),
        expectedError
      );
    });
  });

  describe('createJobTrigger', () => {
    it('invokes createJobTrigger without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CreateJobTriggerRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.CreateJobTriggerRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.JobTrigger()
      );
      client.innerApiCalls.createJobTrigger = stubSimpleCall(expectedResponse);
      const [response] = await client.createJobTrigger(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.createJobTrigger as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.createJobTrigger as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes createJobTrigger without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CreateJobTriggerRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.CreateJobTriggerRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.JobTrigger()
      );
      client.innerApiCalls.createJobTrigger =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.createJobTrigger(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IJobTrigger | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.createJobTrigger as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.createJobTrigger as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes createJobTrigger with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CreateJobTriggerRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.CreateJobTriggerRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.createJobTrigger = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.createJobTrigger(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.createJobTrigger as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.createJobTrigger as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes createJobTrigger with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CreateJobTriggerRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.CreateJobTriggerRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.createJobTrigger(request), expectedError);
    });
  });

  describe('updateJobTrigger', () => {
    it('invokes updateJobTrigger without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.UpdateJobTriggerRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.UpdateJobTriggerRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.JobTrigger()
      );
      client.innerApiCalls.updateJobTrigger = stubSimpleCall(expectedResponse);
      const [response] = await client.updateJobTrigger(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.updateJobTrigger as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.updateJobTrigger as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes updateJobTrigger without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.UpdateJobTriggerRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.UpdateJobTriggerRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.JobTrigger()
      );
      client.innerApiCalls.updateJobTrigger =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.updateJobTrigger(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IJobTrigger | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.updateJobTrigger as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.updateJobTrigger as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes updateJobTrigger with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.UpdateJobTriggerRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.UpdateJobTriggerRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.updateJobTrigger = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.updateJobTrigger(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.updateJobTrigger as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.updateJobTrigger as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes updateJobTrigger with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.UpdateJobTriggerRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.UpdateJobTriggerRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.updateJobTrigger(request), expectedError);
    });
  });

  describe('hybridInspectJobTrigger', () => {
    it('invokes hybridInspectJobTrigger without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.HybridInspectJobTriggerRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.HybridInspectJobTriggerRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.HybridInspectResponse()
      );
      client.innerApiCalls.hybridInspectJobTrigger =
        stubSimpleCall(expectedResponse);
      const [response] = await client.hybridInspectJobTrigger(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.hybridInspectJobTrigger as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.hybridInspectJobTrigger as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes hybridInspectJobTrigger without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.HybridInspectJobTriggerRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.HybridInspectJobTriggerRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.HybridInspectResponse()
      );
      client.innerApiCalls.hybridInspectJobTrigger =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.hybridInspectJobTrigger(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IHybridInspectResponse | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.hybridInspectJobTrigger as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.hybridInspectJobTrigger as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes hybridInspectJobTrigger with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.HybridInspectJobTriggerRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.HybridInspectJobTriggerRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.hybridInspectJobTrigger = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(
        client.hybridInspectJobTrigger(request),
        expectedError
      );
      const actualRequest = (
        client.innerApiCalls.hybridInspectJobTrigger as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.hybridInspectJobTrigger as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes hybridInspectJobTrigger with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.HybridInspectJobTriggerRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.HybridInspectJobTriggerRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(
        client.hybridInspectJobTrigger(request),
        expectedError
      );
    });
  });

  describe('getJobTrigger', () => {
    it('invokes getJobTrigger without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetJobTriggerRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.GetJobTriggerRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.JobTrigger()
      );
      client.innerApiCalls.getJobTrigger = stubSimpleCall(expectedResponse);
      const [response] = await client.getJobTrigger(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.getJobTrigger as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getJobTrigger as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getJobTrigger without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetJobTriggerRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.GetJobTriggerRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.JobTrigger()
      );
      client.innerApiCalls.getJobTrigger =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.getJobTrigger(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IJobTrigger | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.getJobTrigger as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getJobTrigger as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getJobTrigger with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetJobTriggerRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.GetJobTriggerRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.getJobTrigger = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.getJobTrigger(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.getJobTrigger as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getJobTrigger as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getJobTrigger with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetJobTriggerRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.GetJobTriggerRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.getJobTrigger(request), expectedError);
    });
  });

  describe('deleteJobTrigger', () => {
    it('invokes deleteJobTrigger without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteJobTriggerRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.DeleteJobTriggerRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.protobuf.Empty()
      );
      client.innerApiCalls.deleteJobTrigger = stubSimpleCall(expectedResponse);
      const [response] = await client.deleteJobTrigger(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.deleteJobTrigger as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deleteJobTrigger as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deleteJobTrigger without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteJobTriggerRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.DeleteJobTriggerRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.protobuf.Empty()
      );
      client.innerApiCalls.deleteJobTrigger =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.deleteJobTrigger(
          request,
          (
            err?: Error | null,
            result?: protos.google.protobuf.IEmpty | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.deleteJobTrigger as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deleteJobTrigger as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deleteJobTrigger with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteJobTriggerRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.DeleteJobTriggerRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.deleteJobTrigger = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.deleteJobTrigger(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.deleteJobTrigger as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deleteJobTrigger as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deleteJobTrigger with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteJobTriggerRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.DeleteJobTriggerRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.deleteJobTrigger(request), expectedError);
    });
  });

  describe('activateJobTrigger', () => {
    it('invokes activateJobTrigger without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ActivateJobTriggerRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ActivateJobTriggerRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DlpJob()
      );
      client.innerApiCalls.activateJobTrigger =
        stubSimpleCall(expectedResponse);
      const [response] = await client.activateJobTrigger(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.activateJobTrigger as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.activateJobTrigger as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes activateJobTrigger without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ActivateJobTriggerRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ActivateJobTriggerRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DlpJob()
      );
      client.innerApiCalls.activateJobTrigger =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.activateJobTrigger(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IDlpJob | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.activateJobTrigger as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.activateJobTrigger as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes activateJobTrigger with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ActivateJobTriggerRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ActivateJobTriggerRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.activateJobTrigger = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.activateJobTrigger(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.activateJobTrigger as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.activateJobTrigger as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes activateJobTrigger with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ActivateJobTriggerRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ActivateJobTriggerRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.activateJobTrigger(request), expectedError);
    });
  });

  describe('createDiscoveryConfig', () => {
    it('invokes createDiscoveryConfig without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CreateDiscoveryConfigRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.CreateDiscoveryConfigRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DiscoveryConfig()
      );
      client.innerApiCalls.createDiscoveryConfig =
        stubSimpleCall(expectedResponse);
      const [response] = await client.createDiscoveryConfig(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.createDiscoveryConfig as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.createDiscoveryConfig as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes createDiscoveryConfig without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CreateDiscoveryConfigRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.CreateDiscoveryConfigRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DiscoveryConfig()
      );
      client.innerApiCalls.createDiscoveryConfig =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.createDiscoveryConfig(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IDiscoveryConfig | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.createDiscoveryConfig as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.createDiscoveryConfig as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes createDiscoveryConfig with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CreateDiscoveryConfigRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.CreateDiscoveryConfigRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.createDiscoveryConfig = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(
        client.createDiscoveryConfig(request),
        expectedError
      );
      const actualRequest = (
        client.innerApiCalls.createDiscoveryConfig as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.createDiscoveryConfig as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes createDiscoveryConfig with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CreateDiscoveryConfigRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.CreateDiscoveryConfigRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(
        client.createDiscoveryConfig(request),
        expectedError
      );
    });
  });

  describe('updateDiscoveryConfig', () => {
    it('invokes updateDiscoveryConfig without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.UpdateDiscoveryConfigRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.UpdateDiscoveryConfigRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DiscoveryConfig()
      );
      client.innerApiCalls.updateDiscoveryConfig =
        stubSimpleCall(expectedResponse);
      const [response] = await client.updateDiscoveryConfig(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.updateDiscoveryConfig as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.updateDiscoveryConfig as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes updateDiscoveryConfig without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.UpdateDiscoveryConfigRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.UpdateDiscoveryConfigRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DiscoveryConfig()
      );
      client.innerApiCalls.updateDiscoveryConfig =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.updateDiscoveryConfig(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IDiscoveryConfig | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.updateDiscoveryConfig as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.updateDiscoveryConfig as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes updateDiscoveryConfig with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.UpdateDiscoveryConfigRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.UpdateDiscoveryConfigRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.updateDiscoveryConfig = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(
        client.updateDiscoveryConfig(request),
        expectedError
      );
      const actualRequest = (
        client.innerApiCalls.updateDiscoveryConfig as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.updateDiscoveryConfig as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes updateDiscoveryConfig with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.UpdateDiscoveryConfigRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.UpdateDiscoveryConfigRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(
        client.updateDiscoveryConfig(request),
        expectedError
      );
    });
  });

  describe('getDiscoveryConfig', () => {
    it('invokes getDiscoveryConfig without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetDiscoveryConfigRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.GetDiscoveryConfigRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DiscoveryConfig()
      );
      client.innerApiCalls.getDiscoveryConfig =
        stubSimpleCall(expectedResponse);
      const [response] = await client.getDiscoveryConfig(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.getDiscoveryConfig as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getDiscoveryConfig as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getDiscoveryConfig without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetDiscoveryConfigRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.GetDiscoveryConfigRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DiscoveryConfig()
      );
      client.innerApiCalls.getDiscoveryConfig =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.getDiscoveryConfig(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IDiscoveryConfig | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.getDiscoveryConfig as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getDiscoveryConfig as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getDiscoveryConfig with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetDiscoveryConfigRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.GetDiscoveryConfigRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.getDiscoveryConfig = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.getDiscoveryConfig(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.getDiscoveryConfig as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getDiscoveryConfig as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getDiscoveryConfig with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetDiscoveryConfigRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.GetDiscoveryConfigRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.getDiscoveryConfig(request), expectedError);
    });
  });

  describe('deleteDiscoveryConfig', () => {
    it('invokes deleteDiscoveryConfig without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteDiscoveryConfigRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.DeleteDiscoveryConfigRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.protobuf.Empty()
      );
      client.innerApiCalls.deleteDiscoveryConfig =
        stubSimpleCall(expectedResponse);
      const [response] = await client.deleteDiscoveryConfig(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.deleteDiscoveryConfig as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deleteDiscoveryConfig as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deleteDiscoveryConfig without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteDiscoveryConfigRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.DeleteDiscoveryConfigRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.protobuf.Empty()
      );
      client.innerApiCalls.deleteDiscoveryConfig =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.deleteDiscoveryConfig(
          request,
          (
            err?: Error | null,
            result?: protos.google.protobuf.IEmpty | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.deleteDiscoveryConfig as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deleteDiscoveryConfig as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deleteDiscoveryConfig with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteDiscoveryConfigRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.DeleteDiscoveryConfigRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.deleteDiscoveryConfig = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(
        client.deleteDiscoveryConfig(request),
        expectedError
      );
      const actualRequest = (
        client.innerApiCalls.deleteDiscoveryConfig as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deleteDiscoveryConfig as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deleteDiscoveryConfig with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteDiscoveryConfigRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.DeleteDiscoveryConfigRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(
        client.deleteDiscoveryConfig(request),
        expectedError
      );
    });
  });

  describe('createDlpJob', () => {
    it('invokes createDlpJob without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CreateDlpJobRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.CreateDlpJobRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DlpJob()
      );
      client.innerApiCalls.createDlpJob = stubSimpleCall(expectedResponse);
      const [response] = await client.createDlpJob(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.createDlpJob as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.createDlpJob as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes createDlpJob without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CreateDlpJobRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.CreateDlpJobRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DlpJob()
      );
      client.innerApiCalls.createDlpJob =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.createDlpJob(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IDlpJob | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.createDlpJob as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.createDlpJob as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes createDlpJob with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CreateDlpJobRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.CreateDlpJobRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.createDlpJob = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.createDlpJob(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.createDlpJob as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.createDlpJob as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes createDlpJob with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CreateDlpJobRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.CreateDlpJobRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.createDlpJob(request), expectedError);
    });
  });

  describe('getDlpJob', () => {
    it('invokes getDlpJob without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetDlpJobRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.GetDlpJobRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DlpJob()
      );
      client.innerApiCalls.getDlpJob = stubSimpleCall(expectedResponse);
      const [response] = await client.getDlpJob(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.getDlpJob as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getDlpJob as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getDlpJob without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetDlpJobRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.GetDlpJobRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DlpJob()
      );
      client.innerApiCalls.getDlpJob =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.getDlpJob(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IDlpJob | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.getDlpJob as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getDlpJob as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getDlpJob with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetDlpJobRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.GetDlpJobRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.getDlpJob = stubSimpleCall(undefined, expectedError);
      await assert.rejects(client.getDlpJob(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.getDlpJob as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getDlpJob as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getDlpJob with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetDlpJobRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.GetDlpJobRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.getDlpJob(request), expectedError);
    });
  });

  describe('deleteDlpJob', () => {
    it('invokes deleteDlpJob without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteDlpJobRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.DeleteDlpJobRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.protobuf.Empty()
      );
      client.innerApiCalls.deleteDlpJob = stubSimpleCall(expectedResponse);
      const [response] = await client.deleteDlpJob(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.deleteDlpJob as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deleteDlpJob as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deleteDlpJob without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteDlpJobRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.DeleteDlpJobRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.protobuf.Empty()
      );
      client.innerApiCalls.deleteDlpJob =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.deleteDlpJob(
          request,
          (
            err?: Error | null,
            result?: protos.google.protobuf.IEmpty | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.deleteDlpJob as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deleteDlpJob as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deleteDlpJob with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteDlpJobRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.DeleteDlpJobRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.deleteDlpJob = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.deleteDlpJob(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.deleteDlpJob as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deleteDlpJob as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deleteDlpJob with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteDlpJobRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.DeleteDlpJobRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.deleteDlpJob(request), expectedError);
    });
  });

  describe('cancelDlpJob', () => {
    it('invokes cancelDlpJob without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CancelDlpJobRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.CancelDlpJobRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.protobuf.Empty()
      );
      client.innerApiCalls.cancelDlpJob = stubSimpleCall(expectedResponse);
      const [response] = await client.cancelDlpJob(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.cancelDlpJob as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.cancelDlpJob as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes cancelDlpJob without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CancelDlpJobRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.CancelDlpJobRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.protobuf.Empty()
      );
      client.innerApiCalls.cancelDlpJob =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.cancelDlpJob(
          request,
          (
            err?: Error | null,
            result?: protos.google.protobuf.IEmpty | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.cancelDlpJob as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.cancelDlpJob as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes cancelDlpJob with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CancelDlpJobRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.CancelDlpJobRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.cancelDlpJob = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.cancelDlpJob(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.cancelDlpJob as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.cancelDlpJob as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes cancelDlpJob with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CancelDlpJobRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.CancelDlpJobRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.cancelDlpJob(request), expectedError);
    });
  });

  describe('createStoredInfoType', () => {
    it('invokes createStoredInfoType without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CreateStoredInfoTypeRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.CreateStoredInfoTypeRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.StoredInfoType()
      );
      client.innerApiCalls.createStoredInfoType =
        stubSimpleCall(expectedResponse);
      const [response] = await client.createStoredInfoType(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.createStoredInfoType as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.createStoredInfoType as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes createStoredInfoType without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CreateStoredInfoTypeRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.CreateStoredInfoTypeRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.StoredInfoType()
      );
      client.innerApiCalls.createStoredInfoType =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.createStoredInfoType(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IStoredInfoType | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.createStoredInfoType as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.createStoredInfoType as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes createStoredInfoType with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CreateStoredInfoTypeRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.CreateStoredInfoTypeRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.createStoredInfoType = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.createStoredInfoType(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.createStoredInfoType as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.createStoredInfoType as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes createStoredInfoType with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CreateStoredInfoTypeRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.CreateStoredInfoTypeRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.createStoredInfoType(request), expectedError);
    });
  });

  describe('updateStoredInfoType', () => {
    it('invokes updateStoredInfoType without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.UpdateStoredInfoTypeRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.UpdateStoredInfoTypeRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.StoredInfoType()
      );
      client.innerApiCalls.updateStoredInfoType =
        stubSimpleCall(expectedResponse);
      const [response] = await client.updateStoredInfoType(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.updateStoredInfoType as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.updateStoredInfoType as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes updateStoredInfoType without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.UpdateStoredInfoTypeRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.UpdateStoredInfoTypeRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.StoredInfoType()
      );
      client.innerApiCalls.updateStoredInfoType =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.updateStoredInfoType(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IStoredInfoType | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.updateStoredInfoType as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.updateStoredInfoType as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes updateStoredInfoType with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.UpdateStoredInfoTypeRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.UpdateStoredInfoTypeRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.updateStoredInfoType = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.updateStoredInfoType(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.updateStoredInfoType as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.updateStoredInfoType as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes updateStoredInfoType with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.UpdateStoredInfoTypeRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.UpdateStoredInfoTypeRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.updateStoredInfoType(request), expectedError);
    });
  });

  describe('getStoredInfoType', () => {
    it('invokes getStoredInfoType without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetStoredInfoTypeRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.GetStoredInfoTypeRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.StoredInfoType()
      );
      client.innerApiCalls.getStoredInfoType = stubSimpleCall(expectedResponse);
      const [response] = await client.getStoredInfoType(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.getStoredInfoType as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getStoredInfoType as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getStoredInfoType without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetStoredInfoTypeRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.GetStoredInfoTypeRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.StoredInfoType()
      );
      client.innerApiCalls.getStoredInfoType =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.getStoredInfoType(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IStoredInfoType | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.getStoredInfoType as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getStoredInfoType as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getStoredInfoType with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetStoredInfoTypeRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.GetStoredInfoTypeRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.getStoredInfoType = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.getStoredInfoType(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.getStoredInfoType as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getStoredInfoType as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getStoredInfoType with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetStoredInfoTypeRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.GetStoredInfoTypeRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.getStoredInfoType(request), expectedError);
    });
  });

  describe('deleteStoredInfoType', () => {
    it('invokes deleteStoredInfoType without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteStoredInfoTypeRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.DeleteStoredInfoTypeRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.protobuf.Empty()
      );
      client.innerApiCalls.deleteStoredInfoType =
        stubSimpleCall(expectedResponse);
      const [response] = await client.deleteStoredInfoType(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.deleteStoredInfoType as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deleteStoredInfoType as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deleteStoredInfoType without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteStoredInfoTypeRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.DeleteStoredInfoTypeRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.protobuf.Empty()
      );
      client.innerApiCalls.deleteStoredInfoType =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.deleteStoredInfoType(
          request,
          (
            err?: Error | null,
            result?: protos.google.protobuf.IEmpty | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.deleteStoredInfoType as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deleteStoredInfoType as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deleteStoredInfoType with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteStoredInfoTypeRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.DeleteStoredInfoTypeRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.deleteStoredInfoType = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.deleteStoredInfoType(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.deleteStoredInfoType as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deleteStoredInfoType as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deleteStoredInfoType with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteStoredInfoTypeRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.DeleteStoredInfoTypeRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.deleteStoredInfoType(request), expectedError);
    });
  });

  describe('getProjectDataProfile', () => {
    it('invokes getProjectDataProfile without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetProjectDataProfileRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.GetProjectDataProfileRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ProjectDataProfile()
      );
      client.innerApiCalls.getProjectDataProfile =
        stubSimpleCall(expectedResponse);
      const [response] = await client.getProjectDataProfile(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.getProjectDataProfile as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getProjectDataProfile as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getProjectDataProfile without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetProjectDataProfileRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.GetProjectDataProfileRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ProjectDataProfile()
      );
      client.innerApiCalls.getProjectDataProfile =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.getProjectDataProfile(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IProjectDataProfile | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.getProjectDataProfile as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getProjectDataProfile as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getProjectDataProfile with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetProjectDataProfileRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.GetProjectDataProfileRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.getProjectDataProfile = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(
        client.getProjectDataProfile(request),
        expectedError
      );
      const actualRequest = (
        client.innerApiCalls.getProjectDataProfile as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getProjectDataProfile as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getProjectDataProfile with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetProjectDataProfileRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.GetProjectDataProfileRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(
        client.getProjectDataProfile(request),
        expectedError
      );
    });
  });

  describe('getFileStoreDataProfile', () => {
    it('invokes getFileStoreDataProfile without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetFileStoreDataProfileRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.GetFileStoreDataProfileRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.FileStoreDataProfile()
      );
      client.innerApiCalls.getFileStoreDataProfile =
        stubSimpleCall(expectedResponse);
      const [response] = await client.getFileStoreDataProfile(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.getFileStoreDataProfile as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getFileStoreDataProfile as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getFileStoreDataProfile without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetFileStoreDataProfileRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.GetFileStoreDataProfileRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.FileStoreDataProfile()
      );
      client.innerApiCalls.getFileStoreDataProfile =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.getFileStoreDataProfile(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IFileStoreDataProfile | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.getFileStoreDataProfile as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getFileStoreDataProfile as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getFileStoreDataProfile with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetFileStoreDataProfileRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.GetFileStoreDataProfileRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.getFileStoreDataProfile = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(
        client.getFileStoreDataProfile(request),
        expectedError
      );
      const actualRequest = (
        client.innerApiCalls.getFileStoreDataProfile as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getFileStoreDataProfile as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getFileStoreDataProfile with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetFileStoreDataProfileRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.GetFileStoreDataProfileRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(
        client.getFileStoreDataProfile(request),
        expectedError
      );
    });
  });

  describe('deleteFileStoreDataProfile', () => {
    it('invokes deleteFileStoreDataProfile without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteFileStoreDataProfileRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.DeleteFileStoreDataProfileRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.protobuf.Empty()
      );
      client.innerApiCalls.deleteFileStoreDataProfile =
        stubSimpleCall(expectedResponse);
      const [response] = await client.deleteFileStoreDataProfile(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.deleteFileStoreDataProfile as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deleteFileStoreDataProfile as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deleteFileStoreDataProfile without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteFileStoreDataProfileRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.DeleteFileStoreDataProfileRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.protobuf.Empty()
      );
      client.innerApiCalls.deleteFileStoreDataProfile =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.deleteFileStoreDataProfile(
          request,
          (
            err?: Error | null,
            result?: protos.google.protobuf.IEmpty | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.deleteFileStoreDataProfile as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deleteFileStoreDataProfile as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deleteFileStoreDataProfile with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteFileStoreDataProfileRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.DeleteFileStoreDataProfileRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.deleteFileStoreDataProfile = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(
        client.deleteFileStoreDataProfile(request),
        expectedError
      );
      const actualRequest = (
        client.innerApiCalls.deleteFileStoreDataProfile as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deleteFileStoreDataProfile as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deleteFileStoreDataProfile with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteFileStoreDataProfileRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.DeleteFileStoreDataProfileRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(
        client.deleteFileStoreDataProfile(request),
        expectedError
      );
    });
  });

  describe('getTableDataProfile', () => {
    it('invokes getTableDataProfile without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetTableDataProfileRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.GetTableDataProfileRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.TableDataProfile()
      );
      client.innerApiCalls.getTableDataProfile =
        stubSimpleCall(expectedResponse);
      const [response] = await client.getTableDataProfile(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.getTableDataProfile as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getTableDataProfile as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getTableDataProfile without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetTableDataProfileRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.GetTableDataProfileRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.TableDataProfile()
      );
      client.innerApiCalls.getTableDataProfile =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.getTableDataProfile(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.ITableDataProfile | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.getTableDataProfile as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getTableDataProfile as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getTableDataProfile with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetTableDataProfileRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.GetTableDataProfileRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.getTableDataProfile = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.getTableDataProfile(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.getTableDataProfile as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getTableDataProfile as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getTableDataProfile with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetTableDataProfileRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.GetTableDataProfileRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.getTableDataProfile(request), expectedError);
    });
  });

  describe('getColumnDataProfile', () => {
    it('invokes getColumnDataProfile without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetColumnDataProfileRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.GetColumnDataProfileRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ColumnDataProfile()
      );
      client.innerApiCalls.getColumnDataProfile =
        stubSimpleCall(expectedResponse);
      const [response] = await client.getColumnDataProfile(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.getColumnDataProfile as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getColumnDataProfile as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getColumnDataProfile without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetColumnDataProfileRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.GetColumnDataProfileRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ColumnDataProfile()
      );
      client.innerApiCalls.getColumnDataProfile =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.getColumnDataProfile(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IColumnDataProfile | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.getColumnDataProfile as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getColumnDataProfile as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getColumnDataProfile with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetColumnDataProfileRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.GetColumnDataProfileRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.getColumnDataProfile = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.getColumnDataProfile(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.getColumnDataProfile as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getColumnDataProfile as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getColumnDataProfile with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetColumnDataProfileRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.GetColumnDataProfileRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.getColumnDataProfile(request), expectedError);
    });
  });

  describe('deleteTableDataProfile', () => {
    it('invokes deleteTableDataProfile without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteTableDataProfileRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.DeleteTableDataProfileRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.protobuf.Empty()
      );
      client.innerApiCalls.deleteTableDataProfile =
        stubSimpleCall(expectedResponse);
      const [response] = await client.deleteTableDataProfile(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.deleteTableDataProfile as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deleteTableDataProfile as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deleteTableDataProfile without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteTableDataProfileRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.DeleteTableDataProfileRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.protobuf.Empty()
      );
      client.innerApiCalls.deleteTableDataProfile =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.deleteTableDataProfile(
          request,
          (
            err?: Error | null,
            result?: protos.google.protobuf.IEmpty | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.deleteTableDataProfile as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deleteTableDataProfile as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deleteTableDataProfile with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteTableDataProfileRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.DeleteTableDataProfileRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.deleteTableDataProfile = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(
        client.deleteTableDataProfile(request),
        expectedError
      );
      const actualRequest = (
        client.innerApiCalls.deleteTableDataProfile as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deleteTableDataProfile as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deleteTableDataProfile with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteTableDataProfileRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.DeleteTableDataProfileRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(
        client.deleteTableDataProfile(request),
        expectedError
      );
    });
  });

  describe('hybridInspectDlpJob', () => {
    it('invokes hybridInspectDlpJob without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.HybridInspectDlpJobRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.HybridInspectDlpJobRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.HybridInspectResponse()
      );
      client.innerApiCalls.hybridInspectDlpJob =
        stubSimpleCall(expectedResponse);
      const [response] = await client.hybridInspectDlpJob(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.hybridInspectDlpJob as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.hybridInspectDlpJob as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes hybridInspectDlpJob without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.HybridInspectDlpJobRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.HybridInspectDlpJobRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.HybridInspectResponse()
      );
      client.innerApiCalls.hybridInspectDlpJob =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.hybridInspectDlpJob(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IHybridInspectResponse | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.hybridInspectDlpJob as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.hybridInspectDlpJob as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes hybridInspectDlpJob with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.HybridInspectDlpJobRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.HybridInspectDlpJobRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.hybridInspectDlpJob = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.hybridInspectDlpJob(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.hybridInspectDlpJob as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.hybridInspectDlpJob as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes hybridInspectDlpJob with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.HybridInspectDlpJobRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.HybridInspectDlpJobRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.hybridInspectDlpJob(request), expectedError);
    });
  });

  describe('finishDlpJob', () => {
    it('invokes finishDlpJob without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.FinishDlpJobRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.FinishDlpJobRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.protobuf.Empty()
      );
      client.innerApiCalls.finishDlpJob = stubSimpleCall(expectedResponse);
      const [response] = await client.finishDlpJob(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.finishDlpJob as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.finishDlpJob as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes finishDlpJob without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.FinishDlpJobRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.FinishDlpJobRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.protobuf.Empty()
      );
      client.innerApiCalls.finishDlpJob =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.finishDlpJob(
          request,
          (
            err?: Error | null,
            result?: protos.google.protobuf.IEmpty | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.finishDlpJob as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.finishDlpJob as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes finishDlpJob with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.FinishDlpJobRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.FinishDlpJobRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.finishDlpJob = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.finishDlpJob(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.finishDlpJob as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.finishDlpJob as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes finishDlpJob with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.FinishDlpJobRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.FinishDlpJobRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.finishDlpJob(request), expectedError);
    });
  });

  describe('createConnection', () => {
    it('invokes createConnection without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CreateConnectionRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.CreateConnectionRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.Connection()
      );
      client.innerApiCalls.createConnection = stubSimpleCall(expectedResponse);
      const [response] = await client.createConnection(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.createConnection as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.createConnection as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes createConnection without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CreateConnectionRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.CreateConnectionRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.Connection()
      );
      client.innerApiCalls.createConnection =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.createConnection(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IConnection | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.createConnection as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.createConnection as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes createConnection with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CreateConnectionRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.CreateConnectionRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.createConnection = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.createConnection(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.createConnection as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.createConnection as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes createConnection with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.CreateConnectionRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.CreateConnectionRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.createConnection(request), expectedError);
    });
  });

  describe('getConnection', () => {
    it('invokes getConnection without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetConnectionRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.GetConnectionRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.Connection()
      );
      client.innerApiCalls.getConnection = stubSimpleCall(expectedResponse);
      const [response] = await client.getConnection(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.getConnection as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getConnection as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getConnection without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetConnectionRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.GetConnectionRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.Connection()
      );
      client.innerApiCalls.getConnection =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.getConnection(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IConnection | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.getConnection as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getConnection as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getConnection with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetConnectionRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.GetConnectionRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.getConnection = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.getConnection(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.getConnection as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getConnection as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getConnection with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.GetConnectionRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.GetConnectionRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.getConnection(request), expectedError);
    });
  });

  describe('deleteConnection', () => {
    it('invokes deleteConnection without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteConnectionRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.DeleteConnectionRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.protobuf.Empty()
      );
      client.innerApiCalls.deleteConnection = stubSimpleCall(expectedResponse);
      const [response] = await client.deleteConnection(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.deleteConnection as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deleteConnection as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deleteConnection without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteConnectionRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.DeleteConnectionRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.protobuf.Empty()
      );
      client.innerApiCalls.deleteConnection =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.deleteConnection(
          request,
          (
            err?: Error | null,
            result?: protos.google.protobuf.IEmpty | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.deleteConnection as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deleteConnection as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deleteConnection with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteConnectionRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.DeleteConnectionRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.deleteConnection = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.deleteConnection(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.deleteConnection as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deleteConnection as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deleteConnection with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.DeleteConnectionRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.DeleteConnectionRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.deleteConnection(request), expectedError);
    });
  });

  describe('updateConnection', () => {
    it('invokes updateConnection without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.UpdateConnectionRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.UpdateConnectionRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.Connection()
      );
      client.innerApiCalls.updateConnection = stubSimpleCall(expectedResponse);
      const [response] = await client.updateConnection(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.updateConnection as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.updateConnection as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes updateConnection without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.UpdateConnectionRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.UpdateConnectionRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.privacy.dlp.v2.Connection()
      );
      client.innerApiCalls.updateConnection =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.updateConnection(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IConnection | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.updateConnection as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.updateConnection as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes updateConnection with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.UpdateConnectionRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.UpdateConnectionRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.updateConnection = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.updateConnection(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.updateConnection as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.updateConnection as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes updateConnection with closed client', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.UpdateConnectionRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.UpdateConnectionRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.updateConnection(request), expectedError);
    });
  });

  describe('listInspectTemplates', () => {
    it('invokes listInspectTemplates without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListInspectTemplatesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListInspectTemplatesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.InspectTemplate()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.InspectTemplate()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.InspectTemplate()
        ),
      ];
      client.innerApiCalls.listInspectTemplates =
        stubSimpleCall(expectedResponse);
      const [response] = await client.listInspectTemplates(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.listInspectTemplates as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listInspectTemplates as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listInspectTemplates without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListInspectTemplatesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListInspectTemplatesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.InspectTemplate()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.InspectTemplate()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.InspectTemplate()
        ),
      ];
      client.innerApiCalls.listInspectTemplates =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.listInspectTemplates(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IInspectTemplate[] | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.listInspectTemplates as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listInspectTemplates as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listInspectTemplates with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListInspectTemplatesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListInspectTemplatesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.listInspectTemplates = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.listInspectTemplates(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.listInspectTemplates as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listInspectTemplates as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listInspectTemplatesStream without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListInspectTemplatesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListInspectTemplatesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.InspectTemplate()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.InspectTemplate()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.InspectTemplate()
        ),
      ];
      client.descriptors.page.listInspectTemplates.createStream =
        stubPageStreamingCall(expectedResponse);
      const stream = client.listInspectTemplatesStream(request);
      const promise = new Promise((resolve, reject) => {
        const responses: protos.google.privacy.dlp.v2.InspectTemplate[] = [];
        stream.on(
          'data',
          (response: protos.google.privacy.dlp.v2.InspectTemplate) => {
            responses.push(response);
          }
        );
        stream.on('end', () => {
          resolve(responses);
        });
        stream.on('error', (err: Error) => {
          reject(err);
        });
      });
      const responses = await promise;
      assert.deepStrictEqual(responses, expectedResponse);
      assert(
        (client.descriptors.page.listInspectTemplates.createStream as SinonStub)
          .getCall(0)
          .calledWith(client.innerApiCalls.listInspectTemplates, request)
      );
      assert(
        (client.descriptors.page.listInspectTemplates.createStream as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers[
            'x-goog-request-params'
          ].includes(expectedHeaderRequestParams)
      );
    });

    it('invokes listInspectTemplatesStream with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListInspectTemplatesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListInspectTemplatesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.descriptors.page.listInspectTemplates.createStream =
        stubPageStreamingCall(undefined, expectedError);
      const stream = client.listInspectTemplatesStream(request);
      const promise = new Promise((resolve, reject) => {
        const responses: protos.google.privacy.dlp.v2.InspectTemplate[] = [];
        stream.on(
          'data',
          (response: protos.google.privacy.dlp.v2.InspectTemplate) => {
            responses.push(response);
          }
        );
        stream.on('end', () => {
          resolve(responses);
        });
        stream.on('error', (err: Error) => {
          reject(err);
        });
      });
      await assert.rejects(promise, expectedError);
      assert(
        (client.descriptors.page.listInspectTemplates.createStream as SinonStub)
          .getCall(0)
          .calledWith(client.innerApiCalls.listInspectTemplates, request)
      );
      assert(
        (client.descriptors.page.listInspectTemplates.createStream as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers[
            'x-goog-request-params'
          ].includes(expectedHeaderRequestParams)
      );
    });

    it('uses async iteration with listInspectTemplates without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListInspectTemplatesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListInspectTemplatesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.InspectTemplate()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.InspectTemplate()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.InspectTemplate()
        ),
      ];
      client.descriptors.page.listInspectTemplates.asyncIterate =
        stubAsyncIterationCall(expectedResponse);
      const responses: protos.google.privacy.dlp.v2.IInspectTemplate[] = [];
      const iterable = client.listInspectTemplatesAsync(request);
      for await (const resource of iterable) {
        responses.push(resource!);
      }
      assert.deepStrictEqual(responses, expectedResponse);
      assert.deepStrictEqual(
        (
          client.descriptors.page.listInspectTemplates.asyncIterate as SinonStub
        ).getCall(0).args[1],
        request
      );
      assert(
        (client.descriptors.page.listInspectTemplates.asyncIterate as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers[
            'x-goog-request-params'
          ].includes(expectedHeaderRequestParams)
      );
    });

    it('uses async iteration with listInspectTemplates with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListInspectTemplatesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListInspectTemplatesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.descriptors.page.listInspectTemplates.asyncIterate =
        stubAsyncIterationCall(undefined, expectedError);
      const iterable = client.listInspectTemplatesAsync(request);
      await assert.rejects(async () => {
        const responses: protos.google.privacy.dlp.v2.IInspectTemplate[] = [];
        for await (const resource of iterable) {
          responses.push(resource!);
        }
      });
      assert.deepStrictEqual(
        (
          client.descriptors.page.listInspectTemplates.asyncIterate as SinonStub
        ).getCall(0).args[1],
        request
      );
      assert(
        (client.descriptors.page.listInspectTemplates.asyncIterate as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers[
            'x-goog-request-params'
          ].includes(expectedHeaderRequestParams)
      );
    });
  });

  describe('listDeidentifyTemplates', () => {
    it('invokes listDeidentifyTemplates without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListDeidentifyTemplatesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListDeidentifyTemplatesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.DeidentifyTemplate()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.DeidentifyTemplate()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.DeidentifyTemplate()
        ),
      ];
      client.innerApiCalls.listDeidentifyTemplates =
        stubSimpleCall(expectedResponse);
      const [response] = await client.listDeidentifyTemplates(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.listDeidentifyTemplates as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listDeidentifyTemplates as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listDeidentifyTemplates without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListDeidentifyTemplatesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListDeidentifyTemplatesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.DeidentifyTemplate()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.DeidentifyTemplate()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.DeidentifyTemplate()
        ),
      ];
      client.innerApiCalls.listDeidentifyTemplates =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.listDeidentifyTemplates(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IDeidentifyTemplate[] | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.listDeidentifyTemplates as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listDeidentifyTemplates as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listDeidentifyTemplates with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListDeidentifyTemplatesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListDeidentifyTemplatesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.listDeidentifyTemplates = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(
        client.listDeidentifyTemplates(request),
        expectedError
      );
      const actualRequest = (
        client.innerApiCalls.listDeidentifyTemplates as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listDeidentifyTemplates as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listDeidentifyTemplatesStream without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListDeidentifyTemplatesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListDeidentifyTemplatesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.DeidentifyTemplate()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.DeidentifyTemplate()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.DeidentifyTemplate()
        ),
      ];
      client.descriptors.page.listDeidentifyTemplates.createStream =
        stubPageStreamingCall(expectedResponse);
      const stream = client.listDeidentifyTemplatesStream(request);
      const promise = new Promise((resolve, reject) => {
        const responses: protos.google.privacy.dlp.v2.DeidentifyTemplate[] = [];
        stream.on(
          'data',
          (response: protos.google.privacy.dlp.v2.DeidentifyTemplate) => {
            responses.push(response);
          }
        );
        stream.on('end', () => {
          resolve(responses);
        });
        stream.on('error', (err: Error) => {
          reject(err);
        });
      });
      const responses = await promise;
      assert.deepStrictEqual(responses, expectedResponse);
      assert(
        (
          client.descriptors.page.listDeidentifyTemplates
            .createStream as SinonStub
        )
          .getCall(0)
          .calledWith(client.innerApiCalls.listDeidentifyTemplates, request)
      );
      assert(
        (
          client.descriptors.page.listDeidentifyTemplates
            .createStream as SinonStub
        )
          .getCall(0)
          .args[2].otherArgs.headers['x-goog-request-params'].includes(
            expectedHeaderRequestParams
          )
      );
    });

    it('invokes listDeidentifyTemplatesStream with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListDeidentifyTemplatesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListDeidentifyTemplatesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.descriptors.page.listDeidentifyTemplates.createStream =
        stubPageStreamingCall(undefined, expectedError);
      const stream = client.listDeidentifyTemplatesStream(request);
      const promise = new Promise((resolve, reject) => {
        const responses: protos.google.privacy.dlp.v2.DeidentifyTemplate[] = [];
        stream.on(
          'data',
          (response: protos.google.privacy.dlp.v2.DeidentifyTemplate) => {
            responses.push(response);
          }
        );
        stream.on('end', () => {
          resolve(responses);
        });
        stream.on('error', (err: Error) => {
          reject(err);
        });
      });
      await assert.rejects(promise, expectedError);
      assert(
        (
          client.descriptors.page.listDeidentifyTemplates
            .createStream as SinonStub
        )
          .getCall(0)
          .calledWith(client.innerApiCalls.listDeidentifyTemplates, request)
      );
      assert(
        (
          client.descriptors.page.listDeidentifyTemplates
            .createStream as SinonStub
        )
          .getCall(0)
          .args[2].otherArgs.headers['x-goog-request-params'].includes(
            expectedHeaderRequestParams
          )
      );
    });

    it('uses async iteration with listDeidentifyTemplates without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListDeidentifyTemplatesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListDeidentifyTemplatesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.DeidentifyTemplate()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.DeidentifyTemplate()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.DeidentifyTemplate()
        ),
      ];
      client.descriptors.page.listDeidentifyTemplates.asyncIterate =
        stubAsyncIterationCall(expectedResponse);
      const responses: protos.google.privacy.dlp.v2.IDeidentifyTemplate[] = [];
      const iterable = client.listDeidentifyTemplatesAsync(request);
      for await (const resource of iterable) {
        responses.push(resource!);
      }
      assert.deepStrictEqual(responses, expectedResponse);
      assert.deepStrictEqual(
        (
          client.descriptors.page.listDeidentifyTemplates
            .asyncIterate as SinonStub
        ).getCall(0).args[1],
        request
      );
      assert(
        (
          client.descriptors.page.listDeidentifyTemplates
            .asyncIterate as SinonStub
        )
          .getCall(0)
          .args[2].otherArgs.headers['x-goog-request-params'].includes(
            expectedHeaderRequestParams
          )
      );
    });

    it('uses async iteration with listDeidentifyTemplates with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListDeidentifyTemplatesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListDeidentifyTemplatesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.descriptors.page.listDeidentifyTemplates.asyncIterate =
        stubAsyncIterationCall(undefined, expectedError);
      const iterable = client.listDeidentifyTemplatesAsync(request);
      await assert.rejects(async () => {
        const responses: protos.google.privacy.dlp.v2.IDeidentifyTemplate[] =
          [];
        for await (const resource of iterable) {
          responses.push(resource!);
        }
      });
      assert.deepStrictEqual(
        (
          client.descriptors.page.listDeidentifyTemplates
            .asyncIterate as SinonStub
        ).getCall(0).args[1],
        request
      );
      assert(
        (
          client.descriptors.page.listDeidentifyTemplates
            .asyncIterate as SinonStub
        )
          .getCall(0)
          .args[2].otherArgs.headers['x-goog-request-params'].includes(
            expectedHeaderRequestParams
          )
      );
    });
  });

  describe('listJobTriggers', () => {
    it('invokes listJobTriggers without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListJobTriggersRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListJobTriggersRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(new protos.google.privacy.dlp.v2.JobTrigger()),
        generateSampleMessage(new protos.google.privacy.dlp.v2.JobTrigger()),
        generateSampleMessage(new protos.google.privacy.dlp.v2.JobTrigger()),
      ];
      client.innerApiCalls.listJobTriggers = stubSimpleCall(expectedResponse);
      const [response] = await client.listJobTriggers(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.listJobTriggers as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listJobTriggers as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listJobTriggers without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListJobTriggersRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListJobTriggersRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(new protos.google.privacy.dlp.v2.JobTrigger()),
        generateSampleMessage(new protos.google.privacy.dlp.v2.JobTrigger()),
        generateSampleMessage(new protos.google.privacy.dlp.v2.JobTrigger()),
      ];
      client.innerApiCalls.listJobTriggers =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.listJobTriggers(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IJobTrigger[] | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.listJobTriggers as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listJobTriggers as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listJobTriggers with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListJobTriggersRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListJobTriggersRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.listJobTriggers = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.listJobTriggers(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.listJobTriggers as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listJobTriggers as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listJobTriggersStream without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListJobTriggersRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListJobTriggersRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(new protos.google.privacy.dlp.v2.JobTrigger()),
        generateSampleMessage(new protos.google.privacy.dlp.v2.JobTrigger()),
        generateSampleMessage(new protos.google.privacy.dlp.v2.JobTrigger()),
      ];
      client.descriptors.page.listJobTriggers.createStream =
        stubPageStreamingCall(expectedResponse);
      const stream = client.listJobTriggersStream(request);
      const promise = new Promise((resolve, reject) => {
        const responses: protos.google.privacy.dlp.v2.JobTrigger[] = [];
        stream.on(
          'data',
          (response: protos.google.privacy.dlp.v2.JobTrigger) => {
            responses.push(response);
          }
        );
        stream.on('end', () => {
          resolve(responses);
        });
        stream.on('error', (err: Error) => {
          reject(err);
        });
      });
      const responses = await promise;
      assert.deepStrictEqual(responses, expectedResponse);
      assert(
        (client.descriptors.page.listJobTriggers.createStream as SinonStub)
          .getCall(0)
          .calledWith(client.innerApiCalls.listJobTriggers, request)
      );
      assert(
        (client.descriptors.page.listJobTriggers.createStream as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers[
            'x-goog-request-params'
          ].includes(expectedHeaderRequestParams)
      );
    });

    it('invokes listJobTriggersStream with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListJobTriggersRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListJobTriggersRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.descriptors.page.listJobTriggers.createStream =
        stubPageStreamingCall(undefined, expectedError);
      const stream = client.listJobTriggersStream(request);
      const promise = new Promise((resolve, reject) => {
        const responses: protos.google.privacy.dlp.v2.JobTrigger[] = [];
        stream.on(
          'data',
          (response: protos.google.privacy.dlp.v2.JobTrigger) => {
            responses.push(response);
          }
        );
        stream.on('end', () => {
          resolve(responses);
        });
        stream.on('error', (err: Error) => {
          reject(err);
        });
      });
      await assert.rejects(promise, expectedError);
      assert(
        (client.descriptors.page.listJobTriggers.createStream as SinonStub)
          .getCall(0)
          .calledWith(client.innerApiCalls.listJobTriggers, request)
      );
      assert(
        (client.descriptors.page.listJobTriggers.createStream as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers[
            'x-goog-request-params'
          ].includes(expectedHeaderRequestParams)
      );
    });

    it('uses async iteration with listJobTriggers without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListJobTriggersRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListJobTriggersRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(new protos.google.privacy.dlp.v2.JobTrigger()),
        generateSampleMessage(new protos.google.privacy.dlp.v2.JobTrigger()),
        generateSampleMessage(new protos.google.privacy.dlp.v2.JobTrigger()),
      ];
      client.descriptors.page.listJobTriggers.asyncIterate =
        stubAsyncIterationCall(expectedResponse);
      const responses: protos.google.privacy.dlp.v2.IJobTrigger[] = [];
      const iterable = client.listJobTriggersAsync(request);
      for await (const resource of iterable) {
        responses.push(resource!);
      }
      assert.deepStrictEqual(responses, expectedResponse);
      assert.deepStrictEqual(
        (
          client.descriptors.page.listJobTriggers.asyncIterate as SinonStub
        ).getCall(0).args[1],
        request
      );
      assert(
        (client.descriptors.page.listJobTriggers.asyncIterate as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers[
            'x-goog-request-params'
          ].includes(expectedHeaderRequestParams)
      );
    });

    it('uses async iteration with listJobTriggers with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListJobTriggersRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListJobTriggersRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.descriptors.page.listJobTriggers.asyncIterate =
        stubAsyncIterationCall(undefined, expectedError);
      const iterable = client.listJobTriggersAsync(request);
      await assert.rejects(async () => {
        const responses: protos.google.privacy.dlp.v2.IJobTrigger[] = [];
        for await (const resource of iterable) {
          responses.push(resource!);
        }
      });
      assert.deepStrictEqual(
        (
          client.descriptors.page.listJobTriggers.asyncIterate as SinonStub
        ).getCall(0).args[1],
        request
      );
      assert(
        (client.descriptors.page.listJobTriggers.asyncIterate as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers[
            'x-goog-request-params'
          ].includes(expectedHeaderRequestParams)
      );
    });
  });

  describe('listDiscoveryConfigs', () => {
    it('invokes listDiscoveryConfigs without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListDiscoveryConfigsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListDiscoveryConfigsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.DiscoveryConfig()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.DiscoveryConfig()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.DiscoveryConfig()
        ),
      ];
      client.innerApiCalls.listDiscoveryConfigs =
        stubSimpleCall(expectedResponse);
      const [response] = await client.listDiscoveryConfigs(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.listDiscoveryConfigs as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listDiscoveryConfigs as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listDiscoveryConfigs without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListDiscoveryConfigsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListDiscoveryConfigsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.DiscoveryConfig()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.DiscoveryConfig()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.DiscoveryConfig()
        ),
      ];
      client.innerApiCalls.listDiscoveryConfigs =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.listDiscoveryConfigs(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IDiscoveryConfig[] | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.listDiscoveryConfigs as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listDiscoveryConfigs as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listDiscoveryConfigs with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListDiscoveryConfigsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListDiscoveryConfigsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.listDiscoveryConfigs = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.listDiscoveryConfigs(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.listDiscoveryConfigs as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listDiscoveryConfigs as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listDiscoveryConfigsStream without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListDiscoveryConfigsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListDiscoveryConfigsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.DiscoveryConfig()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.DiscoveryConfig()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.DiscoveryConfig()
        ),
      ];
      client.descriptors.page.listDiscoveryConfigs.createStream =
        stubPageStreamingCall(expectedResponse);
      const stream = client.listDiscoveryConfigsStream(request);
      const promise = new Promise((resolve, reject) => {
        const responses: protos.google.privacy.dlp.v2.DiscoveryConfig[] = [];
        stream.on(
          'data',
          (response: protos.google.privacy.dlp.v2.DiscoveryConfig) => {
            responses.push(response);
          }
        );
        stream.on('end', () => {
          resolve(responses);
        });
        stream.on('error', (err: Error) => {
          reject(err);
        });
      });
      const responses = await promise;
      assert.deepStrictEqual(responses, expectedResponse);
      assert(
        (client.descriptors.page.listDiscoveryConfigs.createStream as SinonStub)
          .getCall(0)
          .calledWith(client.innerApiCalls.listDiscoveryConfigs, request)
      );
      assert(
        (client.descriptors.page.listDiscoveryConfigs.createStream as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers[
            'x-goog-request-params'
          ].includes(expectedHeaderRequestParams)
      );
    });

    it('invokes listDiscoveryConfigsStream with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListDiscoveryConfigsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListDiscoveryConfigsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.descriptors.page.listDiscoveryConfigs.createStream =
        stubPageStreamingCall(undefined, expectedError);
      const stream = client.listDiscoveryConfigsStream(request);
      const promise = new Promise((resolve, reject) => {
        const responses: protos.google.privacy.dlp.v2.DiscoveryConfig[] = [];
        stream.on(
          'data',
          (response: protos.google.privacy.dlp.v2.DiscoveryConfig) => {
            responses.push(response);
          }
        );
        stream.on('end', () => {
          resolve(responses);
        });
        stream.on('error', (err: Error) => {
          reject(err);
        });
      });
      await assert.rejects(promise, expectedError);
      assert(
        (client.descriptors.page.listDiscoveryConfigs.createStream as SinonStub)
          .getCall(0)
          .calledWith(client.innerApiCalls.listDiscoveryConfigs, request)
      );
      assert(
        (client.descriptors.page.listDiscoveryConfigs.createStream as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers[
            'x-goog-request-params'
          ].includes(expectedHeaderRequestParams)
      );
    });

    it('uses async iteration with listDiscoveryConfigs without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListDiscoveryConfigsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListDiscoveryConfigsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.DiscoveryConfig()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.DiscoveryConfig()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.DiscoveryConfig()
        ),
      ];
      client.descriptors.page.listDiscoveryConfigs.asyncIterate =
        stubAsyncIterationCall(expectedResponse);
      const responses: protos.google.privacy.dlp.v2.IDiscoveryConfig[] = [];
      const iterable = client.listDiscoveryConfigsAsync(request);
      for await (const resource of iterable) {
        responses.push(resource!);
      }
      assert.deepStrictEqual(responses, expectedResponse);
      assert.deepStrictEqual(
        (
          client.descriptors.page.listDiscoveryConfigs.asyncIterate as SinonStub
        ).getCall(0).args[1],
        request
      );
      assert(
        (client.descriptors.page.listDiscoveryConfigs.asyncIterate as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers[
            'x-goog-request-params'
          ].includes(expectedHeaderRequestParams)
      );
    });

    it('uses async iteration with listDiscoveryConfigs with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListDiscoveryConfigsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListDiscoveryConfigsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.descriptors.page.listDiscoveryConfigs.asyncIterate =
        stubAsyncIterationCall(undefined, expectedError);
      const iterable = client.listDiscoveryConfigsAsync(request);
      await assert.rejects(async () => {
        const responses: protos.google.privacy.dlp.v2.IDiscoveryConfig[] = [];
        for await (const resource of iterable) {
          responses.push(resource!);
        }
      });
      assert.deepStrictEqual(
        (
          client.descriptors.page.listDiscoveryConfigs.asyncIterate as SinonStub
        ).getCall(0).args[1],
        request
      );
      assert(
        (client.descriptors.page.listDiscoveryConfigs.asyncIterate as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers[
            'x-goog-request-params'
          ].includes(expectedHeaderRequestParams)
      );
    });
  });

  describe('listDlpJobs', () => {
    it('invokes listDlpJobs without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListDlpJobsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListDlpJobsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(new protos.google.privacy.dlp.v2.DlpJob()),
        generateSampleMessage(new protos.google.privacy.dlp.v2.DlpJob()),
        generateSampleMessage(new protos.google.privacy.dlp.v2.DlpJob()),
      ];
      client.innerApiCalls.listDlpJobs = stubSimpleCall(expectedResponse);
      const [response] = await client.listDlpJobs(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.listDlpJobs as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listDlpJobs as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listDlpJobs without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListDlpJobsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListDlpJobsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(new protos.google.privacy.dlp.v2.DlpJob()),
        generateSampleMessage(new protos.google.privacy.dlp.v2.DlpJob()),
        generateSampleMessage(new protos.google.privacy.dlp.v2.DlpJob()),
      ];
      client.innerApiCalls.listDlpJobs =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.listDlpJobs(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IDlpJob[] | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.listDlpJobs as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listDlpJobs as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listDlpJobs with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListDlpJobsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListDlpJobsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.listDlpJobs = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.listDlpJobs(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.listDlpJobs as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listDlpJobs as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listDlpJobsStream without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListDlpJobsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListDlpJobsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(new protos.google.privacy.dlp.v2.DlpJob()),
        generateSampleMessage(new protos.google.privacy.dlp.v2.DlpJob()),
        generateSampleMessage(new protos.google.privacy.dlp.v2.DlpJob()),
      ];
      client.descriptors.page.listDlpJobs.createStream =
        stubPageStreamingCall(expectedResponse);
      const stream = client.listDlpJobsStream(request);
      const promise = new Promise((resolve, reject) => {
        const responses: protos.google.privacy.dlp.v2.DlpJob[] = [];
        stream.on('data', (response: protos.google.privacy.dlp.v2.DlpJob) => {
          responses.push(response);
        });
        stream.on('end', () => {
          resolve(responses);
        });
        stream.on('error', (err: Error) => {
          reject(err);
        });
      });
      const responses = await promise;
      assert.deepStrictEqual(responses, expectedResponse);
      assert(
        (client.descriptors.page.listDlpJobs.createStream as SinonStub)
          .getCall(0)
          .calledWith(client.innerApiCalls.listDlpJobs, request)
      );
      assert(
        (client.descriptors.page.listDlpJobs.createStream as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers[
            'x-goog-request-params'
          ].includes(expectedHeaderRequestParams)
      );
    });

    it('invokes listDlpJobsStream with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListDlpJobsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListDlpJobsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.descriptors.page.listDlpJobs.createStream = stubPageStreamingCall(
        undefined,
        expectedError
      );
      const stream = client.listDlpJobsStream(request);
      const promise = new Promise((resolve, reject) => {
        const responses: protos.google.privacy.dlp.v2.DlpJob[] = [];
        stream.on('data', (response: protos.google.privacy.dlp.v2.DlpJob) => {
          responses.push(response);
        });
        stream.on('end', () => {
          resolve(responses);
        });
        stream.on('error', (err: Error) => {
          reject(err);
        });
      });
      await assert.rejects(promise, expectedError);
      assert(
        (client.descriptors.page.listDlpJobs.createStream as SinonStub)
          .getCall(0)
          .calledWith(client.innerApiCalls.listDlpJobs, request)
      );
      assert(
        (client.descriptors.page.listDlpJobs.createStream as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers[
            'x-goog-request-params'
          ].includes(expectedHeaderRequestParams)
      );
    });

    it('uses async iteration with listDlpJobs without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListDlpJobsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListDlpJobsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(new protos.google.privacy.dlp.v2.DlpJob()),
        generateSampleMessage(new protos.google.privacy.dlp.v2.DlpJob()),
        generateSampleMessage(new protos.google.privacy.dlp.v2.DlpJob()),
      ];
      client.descriptors.page.listDlpJobs.asyncIterate =
        stubAsyncIterationCall(expectedResponse);
      const responses: protos.google.privacy.dlp.v2.IDlpJob[] = [];
      const iterable = client.listDlpJobsAsync(request);
      for await (const resource of iterable) {
        responses.push(resource!);
      }
      assert.deepStrictEqual(responses, expectedResponse);
      assert.deepStrictEqual(
        (client.descriptors.page.listDlpJobs.asyncIterate as SinonStub).getCall(
          0
        ).args[1],
        request
      );
      assert(
        (client.descriptors.page.listDlpJobs.asyncIterate as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers[
            'x-goog-request-params'
          ].includes(expectedHeaderRequestParams)
      );
    });

    it('uses async iteration with listDlpJobs with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListDlpJobsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListDlpJobsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.descriptors.page.listDlpJobs.asyncIterate = stubAsyncIterationCall(
        undefined,
        expectedError
      );
      const iterable = client.listDlpJobsAsync(request);
      await assert.rejects(async () => {
        const responses: protos.google.privacy.dlp.v2.IDlpJob[] = [];
        for await (const resource of iterable) {
          responses.push(resource!);
        }
      });
      assert.deepStrictEqual(
        (client.descriptors.page.listDlpJobs.asyncIterate as SinonStub).getCall(
          0
        ).args[1],
        request
      );
      assert(
        (client.descriptors.page.listDlpJobs.asyncIterate as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers[
            'x-goog-request-params'
          ].includes(expectedHeaderRequestParams)
      );
    });
  });

  describe('listStoredInfoTypes', () => {
    it('invokes listStoredInfoTypes without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListStoredInfoTypesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListStoredInfoTypesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.StoredInfoType()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.StoredInfoType()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.StoredInfoType()
        ),
      ];
      client.innerApiCalls.listStoredInfoTypes =
        stubSimpleCall(expectedResponse);
      const [response] = await client.listStoredInfoTypes(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.listStoredInfoTypes as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listStoredInfoTypes as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listStoredInfoTypes without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListStoredInfoTypesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListStoredInfoTypesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.StoredInfoType()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.StoredInfoType()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.StoredInfoType()
        ),
      ];
      client.innerApiCalls.listStoredInfoTypes =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.listStoredInfoTypes(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IStoredInfoType[] | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.listStoredInfoTypes as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listStoredInfoTypes as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listStoredInfoTypes with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListStoredInfoTypesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListStoredInfoTypesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.listStoredInfoTypes = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.listStoredInfoTypes(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.listStoredInfoTypes as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listStoredInfoTypes as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listStoredInfoTypesStream without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListStoredInfoTypesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListStoredInfoTypesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.StoredInfoType()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.StoredInfoType()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.StoredInfoType()
        ),
      ];
      client.descriptors.page.listStoredInfoTypes.createStream =
        stubPageStreamingCall(expectedResponse);
      const stream = client.listStoredInfoTypesStream(request);
      const promise = new Promise((resolve, reject) => {
        const responses: protos.google.privacy.dlp.v2.StoredInfoType[] = [];
        stream.on(
          'data',
          (response: protos.google.privacy.dlp.v2.StoredInfoType) => {
            responses.push(response);
          }
        );
        stream.on('end', () => {
          resolve(responses);
        });
        stream.on('error', (err: Error) => {
          reject(err);
        });
      });
      const responses = await promise;
      assert.deepStrictEqual(responses, expectedResponse);
      assert(
        (client.descriptors.page.listStoredInfoTypes.createStream as SinonStub)
          .getCall(0)
          .calledWith(client.innerApiCalls.listStoredInfoTypes, request)
      );
      assert(
        (client.descriptors.page.listStoredInfoTypes.createStream as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers[
            'x-goog-request-params'
          ].includes(expectedHeaderRequestParams)
      );
    });

    it('invokes listStoredInfoTypesStream with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListStoredInfoTypesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListStoredInfoTypesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.descriptors.page.listStoredInfoTypes.createStream =
        stubPageStreamingCall(undefined, expectedError);
      const stream = client.listStoredInfoTypesStream(request);
      const promise = new Promise((resolve, reject) => {
        const responses: protos.google.privacy.dlp.v2.StoredInfoType[] = [];
        stream.on(
          'data',
          (response: protos.google.privacy.dlp.v2.StoredInfoType) => {
            responses.push(response);
          }
        );
        stream.on('end', () => {
          resolve(responses);
        });
        stream.on('error', (err: Error) => {
          reject(err);
        });
      });
      await assert.rejects(promise, expectedError);
      assert(
        (client.descriptors.page.listStoredInfoTypes.createStream as SinonStub)
          .getCall(0)
          .calledWith(client.innerApiCalls.listStoredInfoTypes, request)
      );
      assert(
        (client.descriptors.page.listStoredInfoTypes.createStream as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers[
            'x-goog-request-params'
          ].includes(expectedHeaderRequestParams)
      );
    });

    it('uses async iteration with listStoredInfoTypes without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListStoredInfoTypesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListStoredInfoTypesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.StoredInfoType()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.StoredInfoType()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.StoredInfoType()
        ),
      ];
      client.descriptors.page.listStoredInfoTypes.asyncIterate =
        stubAsyncIterationCall(expectedResponse);
      const responses: protos.google.privacy.dlp.v2.IStoredInfoType[] = [];
      const iterable = client.listStoredInfoTypesAsync(request);
      for await (const resource of iterable) {
        responses.push(resource!);
      }
      assert.deepStrictEqual(responses, expectedResponse);
      assert.deepStrictEqual(
        (
          client.descriptors.page.listStoredInfoTypes.asyncIterate as SinonStub
        ).getCall(0).args[1],
        request
      );
      assert(
        (client.descriptors.page.listStoredInfoTypes.asyncIterate as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers[
            'x-goog-request-params'
          ].includes(expectedHeaderRequestParams)
      );
    });

    it('uses async iteration with listStoredInfoTypes with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListStoredInfoTypesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListStoredInfoTypesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.descriptors.page.listStoredInfoTypes.asyncIterate =
        stubAsyncIterationCall(undefined, expectedError);
      const iterable = client.listStoredInfoTypesAsync(request);
      await assert.rejects(async () => {
        const responses: protos.google.privacy.dlp.v2.IStoredInfoType[] = [];
        for await (const resource of iterable) {
          responses.push(resource!);
        }
      });
      assert.deepStrictEqual(
        (
          client.descriptors.page.listStoredInfoTypes.asyncIterate as SinonStub
        ).getCall(0).args[1],
        request
      );
      assert(
        (client.descriptors.page.listStoredInfoTypes.asyncIterate as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers[
            'x-goog-request-params'
          ].includes(expectedHeaderRequestParams)
      );
    });
  });

  describe('listProjectDataProfiles', () => {
    it('invokes listProjectDataProfiles without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListProjectDataProfilesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListProjectDataProfilesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.ProjectDataProfile()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.ProjectDataProfile()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.ProjectDataProfile()
        ),
      ];
      client.innerApiCalls.listProjectDataProfiles =
        stubSimpleCall(expectedResponse);
      const [response] = await client.listProjectDataProfiles(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.listProjectDataProfiles as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listProjectDataProfiles as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listProjectDataProfiles without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListProjectDataProfilesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListProjectDataProfilesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.ProjectDataProfile()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.ProjectDataProfile()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.ProjectDataProfile()
        ),
      ];
      client.innerApiCalls.listProjectDataProfiles =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.listProjectDataProfiles(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IProjectDataProfile[] | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.listProjectDataProfiles as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listProjectDataProfiles as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listProjectDataProfiles with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListProjectDataProfilesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListProjectDataProfilesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.listProjectDataProfiles = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(
        client.listProjectDataProfiles(request),
        expectedError
      );
      const actualRequest = (
        client.innerApiCalls.listProjectDataProfiles as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listProjectDataProfiles as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listProjectDataProfilesStream without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListProjectDataProfilesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListProjectDataProfilesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.ProjectDataProfile()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.ProjectDataProfile()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.ProjectDataProfile()
        ),
      ];
      client.descriptors.page.listProjectDataProfiles.createStream =
        stubPageStreamingCall(expectedResponse);
      const stream = client.listProjectDataProfilesStream(request);
      const promise = new Promise((resolve, reject) => {
        const responses: protos.google.privacy.dlp.v2.ProjectDataProfile[] = [];
        stream.on(
          'data',
          (response: protos.google.privacy.dlp.v2.ProjectDataProfile) => {
            responses.push(response);
          }
        );
        stream.on('end', () => {
          resolve(responses);
        });
        stream.on('error', (err: Error) => {
          reject(err);
        });
      });
      const responses = await promise;
      assert.deepStrictEqual(responses, expectedResponse);
      assert(
        (
          client.descriptors.page.listProjectDataProfiles
            .createStream as SinonStub
        )
          .getCall(0)
          .calledWith(client.innerApiCalls.listProjectDataProfiles, request)
      );
      assert(
        (
          client.descriptors.page.listProjectDataProfiles
            .createStream as SinonStub
        )
          .getCall(0)
          .args[2].otherArgs.headers['x-goog-request-params'].includes(
            expectedHeaderRequestParams
          )
      );
    });

    it('invokes listProjectDataProfilesStream with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListProjectDataProfilesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListProjectDataProfilesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.descriptors.page.listProjectDataProfiles.createStream =
        stubPageStreamingCall(undefined, expectedError);
      const stream = client.listProjectDataProfilesStream(request);
      const promise = new Promise((resolve, reject) => {
        const responses: protos.google.privacy.dlp.v2.ProjectDataProfile[] = [];
        stream.on(
          'data',
          (response: protos.google.privacy.dlp.v2.ProjectDataProfile) => {
            responses.push(response);
          }
        );
        stream.on('end', () => {
          resolve(responses);
        });
        stream.on('error', (err: Error) => {
          reject(err);
        });
      });
      await assert.rejects(promise, expectedError);
      assert(
        (
          client.descriptors.page.listProjectDataProfiles
            .createStream as SinonStub
        )
          .getCall(0)
          .calledWith(client.innerApiCalls.listProjectDataProfiles, request)
      );
      assert(
        (
          client.descriptors.page.listProjectDataProfiles
            .createStream as SinonStub
        )
          .getCall(0)
          .args[2].otherArgs.headers['x-goog-request-params'].includes(
            expectedHeaderRequestParams
          )
      );
    });

    it('uses async iteration with listProjectDataProfiles without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListProjectDataProfilesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListProjectDataProfilesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.ProjectDataProfile()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.ProjectDataProfile()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.ProjectDataProfile()
        ),
      ];
      client.descriptors.page.listProjectDataProfiles.asyncIterate =
        stubAsyncIterationCall(expectedResponse);
      const responses: protos.google.privacy.dlp.v2.IProjectDataProfile[] = [];
      const iterable = client.listProjectDataProfilesAsync(request);
      for await (const resource of iterable) {
        responses.push(resource!);
      }
      assert.deepStrictEqual(responses, expectedResponse);
      assert.deepStrictEqual(
        (
          client.descriptors.page.listProjectDataProfiles
            .asyncIterate as SinonStub
        ).getCall(0).args[1],
        request
      );
      assert(
        (
          client.descriptors.page.listProjectDataProfiles
            .asyncIterate as SinonStub
        )
          .getCall(0)
          .args[2].otherArgs.headers['x-goog-request-params'].includes(
            expectedHeaderRequestParams
          )
      );
    });

    it('uses async iteration with listProjectDataProfiles with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListProjectDataProfilesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListProjectDataProfilesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.descriptors.page.listProjectDataProfiles.asyncIterate =
        stubAsyncIterationCall(undefined, expectedError);
      const iterable = client.listProjectDataProfilesAsync(request);
      await assert.rejects(async () => {
        const responses: protos.google.privacy.dlp.v2.IProjectDataProfile[] =
          [];
        for await (const resource of iterable) {
          responses.push(resource!);
        }
      });
      assert.deepStrictEqual(
        (
          client.descriptors.page.listProjectDataProfiles
            .asyncIterate as SinonStub
        ).getCall(0).args[1],
        request
      );
      assert(
        (
          client.descriptors.page.listProjectDataProfiles
            .asyncIterate as SinonStub
        )
          .getCall(0)
          .args[2].otherArgs.headers['x-goog-request-params'].includes(
            expectedHeaderRequestParams
          )
      );
    });
  });

  describe('listTableDataProfiles', () => {
    it('invokes listTableDataProfiles without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListTableDataProfilesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListTableDataProfilesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.TableDataProfile()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.TableDataProfile()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.TableDataProfile()
        ),
      ];
      client.innerApiCalls.listTableDataProfiles =
        stubSimpleCall(expectedResponse);
      const [response] = await client.listTableDataProfiles(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.listTableDataProfiles as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listTableDataProfiles as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listTableDataProfiles without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListTableDataProfilesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListTableDataProfilesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.TableDataProfile()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.TableDataProfile()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.TableDataProfile()
        ),
      ];
      client.innerApiCalls.listTableDataProfiles =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.listTableDataProfiles(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.ITableDataProfile[] | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.listTableDataProfiles as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listTableDataProfiles as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listTableDataProfiles with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListTableDataProfilesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListTableDataProfilesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.listTableDataProfiles = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(
        client.listTableDataProfiles(request),
        expectedError
      );
      const actualRequest = (
        client.innerApiCalls.listTableDataProfiles as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listTableDataProfiles as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listTableDataProfilesStream without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListTableDataProfilesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListTableDataProfilesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.TableDataProfile()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.TableDataProfile()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.TableDataProfile()
        ),
      ];
      client.descriptors.page.listTableDataProfiles.createStream =
        stubPageStreamingCall(expectedResponse);
      const stream = client.listTableDataProfilesStream(request);
      const promise = new Promise((resolve, reject) => {
        const responses: protos.google.privacy.dlp.v2.TableDataProfile[] = [];
        stream.on(
          'data',
          (response: protos.google.privacy.dlp.v2.TableDataProfile) => {
            responses.push(response);
          }
        );
        stream.on('end', () => {
          resolve(responses);
        });
        stream.on('error', (err: Error) => {
          reject(err);
        });
      });
      const responses = await promise;
      assert.deepStrictEqual(responses, expectedResponse);
      assert(
        (
          client.descriptors.page.listTableDataProfiles
            .createStream as SinonStub
        )
          .getCall(0)
          .calledWith(client.innerApiCalls.listTableDataProfiles, request)
      );
      assert(
        (
          client.descriptors.page.listTableDataProfiles
            .createStream as SinonStub
        )
          .getCall(0)
          .args[2].otherArgs.headers['x-goog-request-params'].includes(
            expectedHeaderRequestParams
          )
      );
    });

    it('invokes listTableDataProfilesStream with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListTableDataProfilesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListTableDataProfilesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.descriptors.page.listTableDataProfiles.createStream =
        stubPageStreamingCall(undefined, expectedError);
      const stream = client.listTableDataProfilesStream(request);
      const promise = new Promise((resolve, reject) => {
        const responses: protos.google.privacy.dlp.v2.TableDataProfile[] = [];
        stream.on(
          'data',
          (response: protos.google.privacy.dlp.v2.TableDataProfile) => {
            responses.push(response);
          }
        );
        stream.on('end', () => {
          resolve(responses);
        });
        stream.on('error', (err: Error) => {
          reject(err);
        });
      });
      await assert.rejects(promise, expectedError);
      assert(
        (
          client.descriptors.page.listTableDataProfiles
            .createStream as SinonStub
        )
          .getCall(0)
          .calledWith(client.innerApiCalls.listTableDataProfiles, request)
      );
      assert(
        (
          client.descriptors.page.listTableDataProfiles
            .createStream as SinonStub
        )
          .getCall(0)
          .args[2].otherArgs.headers['x-goog-request-params'].includes(
            expectedHeaderRequestParams
          )
      );
    });

    it('uses async iteration with listTableDataProfiles without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListTableDataProfilesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListTableDataProfilesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.TableDataProfile()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.TableDataProfile()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.TableDataProfile()
        ),
      ];
      client.descriptors.page.listTableDataProfiles.asyncIterate =
        stubAsyncIterationCall(expectedResponse);
      const responses: protos.google.privacy.dlp.v2.ITableDataProfile[] = [];
      const iterable = client.listTableDataProfilesAsync(request);
      for await (const resource of iterable) {
        responses.push(resource!);
      }
      assert.deepStrictEqual(responses, expectedResponse);
      assert.deepStrictEqual(
        (
          client.descriptors.page.listTableDataProfiles
            .asyncIterate as SinonStub
        ).getCall(0).args[1],
        request
      );
      assert(
        (
          client.descriptors.page.listTableDataProfiles
            .asyncIterate as SinonStub
        )
          .getCall(0)
          .args[2].otherArgs.headers['x-goog-request-params'].includes(
            expectedHeaderRequestParams
          )
      );
    });

    it('uses async iteration with listTableDataProfiles with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListTableDataProfilesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListTableDataProfilesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.descriptors.page.listTableDataProfiles.asyncIterate =
        stubAsyncIterationCall(undefined, expectedError);
      const iterable = client.listTableDataProfilesAsync(request);
      await assert.rejects(async () => {
        const responses: protos.google.privacy.dlp.v2.ITableDataProfile[] = [];
        for await (const resource of iterable) {
          responses.push(resource!);
        }
      });
      assert.deepStrictEqual(
        (
          client.descriptors.page.listTableDataProfiles
            .asyncIterate as SinonStub
        ).getCall(0).args[1],
        request
      );
      assert(
        (
          client.descriptors.page.listTableDataProfiles
            .asyncIterate as SinonStub
        )
          .getCall(0)
          .args[2].otherArgs.headers['x-goog-request-params'].includes(
            expectedHeaderRequestParams
          )
      );
    });
  });

  describe('listColumnDataProfiles', () => {
    it('invokes listColumnDataProfiles without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListColumnDataProfilesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListColumnDataProfilesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.ColumnDataProfile()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.ColumnDataProfile()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.ColumnDataProfile()
        ),
      ];
      client.innerApiCalls.listColumnDataProfiles =
        stubSimpleCall(expectedResponse);
      const [response] = await client.listColumnDataProfiles(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.listColumnDataProfiles as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listColumnDataProfiles as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listColumnDataProfiles without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListColumnDataProfilesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListColumnDataProfilesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.ColumnDataProfile()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.ColumnDataProfile()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.ColumnDataProfile()
        ),
      ];
      client.innerApiCalls.listColumnDataProfiles =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.listColumnDataProfiles(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IColumnDataProfile[] | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.listColumnDataProfiles as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listColumnDataProfiles as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listColumnDataProfiles with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListColumnDataProfilesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListColumnDataProfilesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.listColumnDataProfiles = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(
        client.listColumnDataProfiles(request),
        expectedError
      );
      const actualRequest = (
        client.innerApiCalls.listColumnDataProfiles as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listColumnDataProfiles as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listColumnDataProfilesStream without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListColumnDataProfilesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListColumnDataProfilesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.ColumnDataProfile()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.ColumnDataProfile()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.ColumnDataProfile()
        ),
      ];
      client.descriptors.page.listColumnDataProfiles.createStream =
        stubPageStreamingCall(expectedResponse);
      const stream = client.listColumnDataProfilesStream(request);
      const promise = new Promise((resolve, reject) => {
        const responses: protos.google.privacy.dlp.v2.ColumnDataProfile[] = [];
        stream.on(
          'data',
          (response: protos.google.privacy.dlp.v2.ColumnDataProfile) => {
            responses.push(response);
          }
        );
        stream.on('end', () => {
          resolve(responses);
        });
        stream.on('error', (err: Error) => {
          reject(err);
        });
      });
      const responses = await promise;
      assert.deepStrictEqual(responses, expectedResponse);
      assert(
        (
          client.descriptors.page.listColumnDataProfiles
            .createStream as SinonStub
        )
          .getCall(0)
          .calledWith(client.innerApiCalls.listColumnDataProfiles, request)
      );
      assert(
        (
          client.descriptors.page.listColumnDataProfiles
            .createStream as SinonStub
        )
          .getCall(0)
          .args[2].otherArgs.headers['x-goog-request-params'].includes(
            expectedHeaderRequestParams
          )
      );
    });

    it('invokes listColumnDataProfilesStream with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListColumnDataProfilesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListColumnDataProfilesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.descriptors.page.listColumnDataProfiles.createStream =
        stubPageStreamingCall(undefined, expectedError);
      const stream = client.listColumnDataProfilesStream(request);
      const promise = new Promise((resolve, reject) => {
        const responses: protos.google.privacy.dlp.v2.ColumnDataProfile[] = [];
        stream.on(
          'data',
          (response: protos.google.privacy.dlp.v2.ColumnDataProfile) => {
            responses.push(response);
          }
        );
        stream.on('end', () => {
          resolve(responses);
        });
        stream.on('error', (err: Error) => {
          reject(err);
        });
      });
      await assert.rejects(promise, expectedError);
      assert(
        (
          client.descriptors.page.listColumnDataProfiles
            .createStream as SinonStub
        )
          .getCall(0)
          .calledWith(client.innerApiCalls.listColumnDataProfiles, request)
      );
      assert(
        (
          client.descriptors.page.listColumnDataProfiles
            .createStream as SinonStub
        )
          .getCall(0)
          .args[2].otherArgs.headers['x-goog-request-params'].includes(
            expectedHeaderRequestParams
          )
      );
    });

    it('uses async iteration with listColumnDataProfiles without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListColumnDataProfilesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListColumnDataProfilesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.ColumnDataProfile()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.ColumnDataProfile()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.ColumnDataProfile()
        ),
      ];
      client.descriptors.page.listColumnDataProfiles.asyncIterate =
        stubAsyncIterationCall(expectedResponse);
      const responses: protos.google.privacy.dlp.v2.IColumnDataProfile[] = [];
      const iterable = client.listColumnDataProfilesAsync(request);
      for await (const resource of iterable) {
        responses.push(resource!);
      }
      assert.deepStrictEqual(responses, expectedResponse);
      assert.deepStrictEqual(
        (
          client.descriptors.page.listColumnDataProfiles
            .asyncIterate as SinonStub
        ).getCall(0).args[1],
        request
      );
      assert(
        (
          client.descriptors.page.listColumnDataProfiles
            .asyncIterate as SinonStub
        )
          .getCall(0)
          .args[2].otherArgs.headers['x-goog-request-params'].includes(
            expectedHeaderRequestParams
          )
      );
    });

    it('uses async iteration with listColumnDataProfiles with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListColumnDataProfilesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListColumnDataProfilesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.descriptors.page.listColumnDataProfiles.asyncIterate =
        stubAsyncIterationCall(undefined, expectedError);
      const iterable = client.listColumnDataProfilesAsync(request);
      await assert.rejects(async () => {
        const responses: protos.google.privacy.dlp.v2.IColumnDataProfile[] = [];
        for await (const resource of iterable) {
          responses.push(resource!);
        }
      });
      assert.deepStrictEqual(
        (
          client.descriptors.page.listColumnDataProfiles
            .asyncIterate as SinonStub
        ).getCall(0).args[1],
        request
      );
      assert(
        (
          client.descriptors.page.listColumnDataProfiles
            .asyncIterate as SinonStub
        )
          .getCall(0)
          .args[2].otherArgs.headers['x-goog-request-params'].includes(
            expectedHeaderRequestParams
          )
      );
    });
  });

  describe('listFileStoreDataProfiles', () => {
    it('invokes listFileStoreDataProfiles without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListFileStoreDataProfilesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListFileStoreDataProfilesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.FileStoreDataProfile()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.FileStoreDataProfile()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.FileStoreDataProfile()
        ),
      ];
      client.innerApiCalls.listFileStoreDataProfiles =
        stubSimpleCall(expectedResponse);
      const [response] = await client.listFileStoreDataProfiles(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.listFileStoreDataProfiles as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listFileStoreDataProfiles as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listFileStoreDataProfiles without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListFileStoreDataProfilesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListFileStoreDataProfilesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.FileStoreDataProfile()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.FileStoreDataProfile()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.FileStoreDataProfile()
        ),
      ];
      client.innerApiCalls.listFileStoreDataProfiles =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.listFileStoreDataProfiles(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IFileStoreDataProfile[] | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.listFileStoreDataProfiles as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listFileStoreDataProfiles as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listFileStoreDataProfiles with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListFileStoreDataProfilesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListFileStoreDataProfilesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.listFileStoreDataProfiles = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(
        client.listFileStoreDataProfiles(request),
        expectedError
      );
      const actualRequest = (
        client.innerApiCalls.listFileStoreDataProfiles as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listFileStoreDataProfiles as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listFileStoreDataProfilesStream without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListFileStoreDataProfilesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListFileStoreDataProfilesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.FileStoreDataProfile()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.FileStoreDataProfile()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.FileStoreDataProfile()
        ),
      ];
      client.descriptors.page.listFileStoreDataProfiles.createStream =
        stubPageStreamingCall(expectedResponse);
      const stream = client.listFileStoreDataProfilesStream(request);
      const promise = new Promise((resolve, reject) => {
        const responses: protos.google.privacy.dlp.v2.FileStoreDataProfile[] =
          [];
        stream.on(
          'data',
          (response: protos.google.privacy.dlp.v2.FileStoreDataProfile) => {
            responses.push(response);
          }
        );
        stream.on('end', () => {
          resolve(responses);
        });
        stream.on('error', (err: Error) => {
          reject(err);
        });
      });
      const responses = await promise;
      assert.deepStrictEqual(responses, expectedResponse);
      assert(
        (
          client.descriptors.page.listFileStoreDataProfiles
            .createStream as SinonStub
        )
          .getCall(0)
          .calledWith(client.innerApiCalls.listFileStoreDataProfiles, request)
      );
      assert(
        (
          client.descriptors.page.listFileStoreDataProfiles
            .createStream as SinonStub
        )
          .getCall(0)
          .args[2].otherArgs.headers['x-goog-request-params'].includes(
            expectedHeaderRequestParams
          )
      );
    });

    it('invokes listFileStoreDataProfilesStream with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListFileStoreDataProfilesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListFileStoreDataProfilesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.descriptors.page.listFileStoreDataProfiles.createStream =
        stubPageStreamingCall(undefined, expectedError);
      const stream = client.listFileStoreDataProfilesStream(request);
      const promise = new Promise((resolve, reject) => {
        const responses: protos.google.privacy.dlp.v2.FileStoreDataProfile[] =
          [];
        stream.on(
          'data',
          (response: protos.google.privacy.dlp.v2.FileStoreDataProfile) => {
            responses.push(response);
          }
        );
        stream.on('end', () => {
          resolve(responses);
        });
        stream.on('error', (err: Error) => {
          reject(err);
        });
      });
      await assert.rejects(promise, expectedError);
      assert(
        (
          client.descriptors.page.listFileStoreDataProfiles
            .createStream as SinonStub
        )
          .getCall(0)
          .calledWith(client.innerApiCalls.listFileStoreDataProfiles, request)
      );
      assert(
        (
          client.descriptors.page.listFileStoreDataProfiles
            .createStream as SinonStub
        )
          .getCall(0)
          .args[2].otherArgs.headers['x-goog-request-params'].includes(
            expectedHeaderRequestParams
          )
      );
    });

    it('uses async iteration with listFileStoreDataProfiles without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListFileStoreDataProfilesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListFileStoreDataProfilesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.FileStoreDataProfile()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.FileStoreDataProfile()
        ),
        generateSampleMessage(
          new protos.google.privacy.dlp.v2.FileStoreDataProfile()
        ),
      ];
      client.descriptors.page.listFileStoreDataProfiles.asyncIterate =
        stubAsyncIterationCall(expectedResponse);
      const responses: protos.google.privacy.dlp.v2.IFileStoreDataProfile[] =
        [];
      const iterable = client.listFileStoreDataProfilesAsync(request);
      for await (const resource of iterable) {
        responses.push(resource!);
      }
      assert.deepStrictEqual(responses, expectedResponse);
      assert.deepStrictEqual(
        (
          client.descriptors.page.listFileStoreDataProfiles
            .asyncIterate as SinonStub
        ).getCall(0).args[1],
        request
      );
      assert(
        (
          client.descriptors.page.listFileStoreDataProfiles
            .asyncIterate as SinonStub
        )
          .getCall(0)
          .args[2].otherArgs.headers['x-goog-request-params'].includes(
            expectedHeaderRequestParams
          )
      );
    });

    it('uses async iteration with listFileStoreDataProfiles with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListFileStoreDataProfilesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListFileStoreDataProfilesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.descriptors.page.listFileStoreDataProfiles.asyncIterate =
        stubAsyncIterationCall(undefined, expectedError);
      const iterable = client.listFileStoreDataProfilesAsync(request);
      await assert.rejects(async () => {
        const responses: protos.google.privacy.dlp.v2.IFileStoreDataProfile[] =
          [];
        for await (const resource of iterable) {
          responses.push(resource!);
        }
      });
      assert.deepStrictEqual(
        (
          client.descriptors.page.listFileStoreDataProfiles
            .asyncIterate as SinonStub
        ).getCall(0).args[1],
        request
      );
      assert(
        (
          client.descriptors.page.listFileStoreDataProfiles
            .asyncIterate as SinonStub
        )
          .getCall(0)
          .args[2].otherArgs.headers['x-goog-request-params'].includes(
            expectedHeaderRequestParams
          )
      );
    });
  });

  describe('listConnections', () => {
    it('invokes listConnections without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListConnectionsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListConnectionsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(new protos.google.privacy.dlp.v2.Connection()),
        generateSampleMessage(new protos.google.privacy.dlp.v2.Connection()),
        generateSampleMessage(new protos.google.privacy.dlp.v2.Connection()),
      ];
      client.innerApiCalls.listConnections = stubSimpleCall(expectedResponse);
      const [response] = await client.listConnections(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.listConnections as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listConnections as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listConnections without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListConnectionsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListConnectionsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(new protos.google.privacy.dlp.v2.Connection()),
        generateSampleMessage(new protos.google.privacy.dlp.v2.Connection()),
        generateSampleMessage(new protos.google.privacy.dlp.v2.Connection()),
      ];
      client.innerApiCalls.listConnections =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.listConnections(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IConnection[] | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.listConnections as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listConnections as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listConnections with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListConnectionsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListConnectionsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.listConnections = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.listConnections(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.listConnections as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listConnections as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listConnectionsStream without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListConnectionsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListConnectionsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(new protos.google.privacy.dlp.v2.Connection()),
        generateSampleMessage(new protos.google.privacy.dlp.v2.Connection()),
        generateSampleMessage(new protos.google.privacy.dlp.v2.Connection()),
      ];
      client.descriptors.page.listConnections.createStream =
        stubPageStreamingCall(expectedResponse);
      const stream = client.listConnectionsStream(request);
      const promise = new Promise((resolve, reject) => {
        const responses: protos.google.privacy.dlp.v2.Connection[] = [];
        stream.on(
          'data',
          (response: protos.google.privacy.dlp.v2.Connection) => {
            responses.push(response);
          }
        );
        stream.on('end', () => {
          resolve(responses);
        });
        stream.on('error', (err: Error) => {
          reject(err);
        });
      });
      const responses = await promise;
      assert.deepStrictEqual(responses, expectedResponse);
      assert(
        (client.descriptors.page.listConnections.createStream as SinonStub)
          .getCall(0)
          .calledWith(client.innerApiCalls.listConnections, request)
      );
      assert(
        (client.descriptors.page.listConnections.createStream as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers[
            'x-goog-request-params'
          ].includes(expectedHeaderRequestParams)
      );
    });

    it('invokes listConnectionsStream with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListConnectionsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListConnectionsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.descriptors.page.listConnections.createStream =
        stubPageStreamingCall(undefined, expectedError);
      const stream = client.listConnectionsStream(request);
      const promise = new Promise((resolve, reject) => {
        const responses: protos.google.privacy.dlp.v2.Connection[] = [];
        stream.on(
          'data',
          (response: protos.google.privacy.dlp.v2.Connection) => {
            responses.push(response);
          }
        );
        stream.on('end', () => {
          resolve(responses);
        });
        stream.on('error', (err: Error) => {
          reject(err);
        });
      });
      await assert.rejects(promise, expectedError);
      assert(
        (client.descriptors.page.listConnections.createStream as SinonStub)
          .getCall(0)
          .calledWith(client.innerApiCalls.listConnections, request)
      );
      assert(
        (client.descriptors.page.listConnections.createStream as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers[
            'x-goog-request-params'
          ].includes(expectedHeaderRequestParams)
      );
    });

    it('uses async iteration with listConnections without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListConnectionsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListConnectionsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(new protos.google.privacy.dlp.v2.Connection()),
        generateSampleMessage(new protos.google.privacy.dlp.v2.Connection()),
        generateSampleMessage(new protos.google.privacy.dlp.v2.Connection()),
      ];
      client.descriptors.page.listConnections.asyncIterate =
        stubAsyncIterationCall(expectedResponse);
      const responses: protos.google.privacy.dlp.v2.IConnection[] = [];
      const iterable = client.listConnectionsAsync(request);
      for await (const resource of iterable) {
        responses.push(resource!);
      }
      assert.deepStrictEqual(responses, expectedResponse);
      assert.deepStrictEqual(
        (
          client.descriptors.page.listConnections.asyncIterate as SinonStub
        ).getCall(0).args[1],
        request
      );
      assert(
        (client.descriptors.page.listConnections.asyncIterate as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers[
            'x-goog-request-params'
          ].includes(expectedHeaderRequestParams)
      );
    });

    it('uses async iteration with listConnections with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.ListConnectionsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.ListConnectionsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.descriptors.page.listConnections.asyncIterate =
        stubAsyncIterationCall(undefined, expectedError);
      const iterable = client.listConnectionsAsync(request);
      await assert.rejects(async () => {
        const responses: protos.google.privacy.dlp.v2.IConnection[] = [];
        for await (const resource of iterable) {
          responses.push(resource!);
        }
      });
      assert.deepStrictEqual(
        (
          client.descriptors.page.listConnections.asyncIterate as SinonStub
        ).getCall(0).args[1],
        request
      );
      assert(
        (client.descriptors.page.listConnections.asyncIterate as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers[
            'x-goog-request-params'
          ].includes(expectedHeaderRequestParams)
      );
    });
  });

  describe('searchConnections', () => {
    it('invokes searchConnections without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.SearchConnectionsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.SearchConnectionsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(new protos.google.privacy.dlp.v2.Connection()),
        generateSampleMessage(new protos.google.privacy.dlp.v2.Connection()),
        generateSampleMessage(new protos.google.privacy.dlp.v2.Connection()),
      ];
      client.innerApiCalls.searchConnections = stubSimpleCall(expectedResponse);
      const [response] = await client.searchConnections(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.searchConnections as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.searchConnections as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes searchConnections without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.SearchConnectionsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.SearchConnectionsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(new protos.google.privacy.dlp.v2.Connection()),
        generateSampleMessage(new protos.google.privacy.dlp.v2.Connection()),
        generateSampleMessage(new protos.google.privacy.dlp.v2.Connection()),
      ];
      client.innerApiCalls.searchConnections =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.searchConnections(
          request,
          (
            err?: Error | null,
            result?: protos.google.privacy.dlp.v2.IConnection[] | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.searchConnections as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.searchConnections as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes searchConnections with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.SearchConnectionsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.SearchConnectionsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.searchConnections = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.searchConnections(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.searchConnections as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.searchConnections as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes searchConnectionsStream without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.SearchConnectionsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.SearchConnectionsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(new protos.google.privacy.dlp.v2.Connection()),
        generateSampleMessage(new protos.google.privacy.dlp.v2.Connection()),
        generateSampleMessage(new protos.google.privacy.dlp.v2.Connection()),
      ];
      client.descriptors.page.searchConnections.createStream =
        stubPageStreamingCall(expectedResponse);
      const stream = client.searchConnectionsStream(request);
      const promise = new Promise((resolve, reject) => {
        const responses: protos.google.privacy.dlp.v2.Connection[] = [];
        stream.on(
          'data',
          (response: protos.google.privacy.dlp.v2.Connection) => {
            responses.push(response);
          }
        );
        stream.on('end', () => {
          resolve(responses);
        });
        stream.on('error', (err: Error) => {
          reject(err);
        });
      });
      const responses = await promise;
      assert.deepStrictEqual(responses, expectedResponse);
      assert(
        (client.descriptors.page.searchConnections.createStream as SinonStub)
          .getCall(0)
          .calledWith(client.innerApiCalls.searchConnections, request)
      );
      assert(
        (client.descriptors.page.searchConnections.createStream as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers[
            'x-goog-request-params'
          ].includes(expectedHeaderRequestParams)
      );
    });

    it('invokes searchConnectionsStream with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.SearchConnectionsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.SearchConnectionsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.descriptors.page.searchConnections.createStream =
        stubPageStreamingCall(undefined, expectedError);
      const stream = client.searchConnectionsStream(request);
      const promise = new Promise((resolve, reject) => {
        const responses: protos.google.privacy.dlp.v2.Connection[] = [];
        stream.on(
          'data',
          (response: protos.google.privacy.dlp.v2.Connection) => {
            responses.push(response);
          }
        );
        stream.on('end', () => {
          resolve(responses);
        });
        stream.on('error', (err: Error) => {
          reject(err);
        });
      });
      await assert.rejects(promise, expectedError);
      assert(
        (client.descriptors.page.searchConnections.createStream as SinonStub)
          .getCall(0)
          .calledWith(client.innerApiCalls.searchConnections, request)
      );
      assert(
        (client.descriptors.page.searchConnections.createStream as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers[
            'x-goog-request-params'
          ].includes(expectedHeaderRequestParams)
      );
    });

    it('uses async iteration with searchConnections without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.SearchConnectionsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.SearchConnectionsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(new protos.google.privacy.dlp.v2.Connection()),
        generateSampleMessage(new protos.google.privacy.dlp.v2.Connection()),
        generateSampleMessage(new protos.google.privacy.dlp.v2.Connection()),
      ];
      client.descriptors.page.searchConnections.asyncIterate =
        stubAsyncIterationCall(expectedResponse);
      const responses: protos.google.privacy.dlp.v2.IConnection[] = [];
      const iterable = client.searchConnectionsAsync(request);
      for await (const resource of iterable) {
        responses.push(resource!);
      }
      assert.deepStrictEqual(responses, expectedResponse);
      assert.deepStrictEqual(
        (
          client.descriptors.page.searchConnections.asyncIterate as SinonStub
        ).getCall(0).args[1],
        request
      );
      assert(
        (client.descriptors.page.searchConnections.asyncIterate as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers[
            'x-goog-request-params'
          ].includes(expectedHeaderRequestParams)
      );
    });

    it('uses async iteration with searchConnections with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.privacy.dlp.v2.SearchConnectionsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.privacy.dlp.v2.SearchConnectionsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.descriptors.page.searchConnections.asyncIterate =
        stubAsyncIterationCall(undefined, expectedError);
      const iterable = client.searchConnectionsAsync(request);
      await assert.rejects(async () => {
        const responses: protos.google.privacy.dlp.v2.IConnection[] = [];
        for await (const resource of iterable) {
          responses.push(resource!);
        }
      });
      assert.deepStrictEqual(
        (
          client.descriptors.page.searchConnections.asyncIterate as SinonStub
        ).getCall(0).args[1],
        request
      );
      assert(
        (client.descriptors.page.searchConnections.asyncIterate as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers[
            'x-goog-request-params'
          ].includes(expectedHeaderRequestParams)
      );
    });
  });
  describe('getLocation', () => {
    it('invokes getLocation without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new LocationProtos.google.cloud.location.GetLocationRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new LocationProtos.google.cloud.location.Location()
      );
      client.locationsClient.getLocation = stubSimpleCall(expectedResponse);
      const response = await client.getLocation(request, expectedOptions);
      assert.deepStrictEqual(response, [expectedResponse]);
      assert(
        (client.locationsClient.getLocation as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });
    it('invokes getLocation without error using callback', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new LocationProtos.google.cloud.location.GetLocationRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedResponse = generateSampleMessage(
        new LocationProtos.google.cloud.location.Location()
      );
      client.locationsClient.getLocation = sinon
        .stub()
        .callsArgWith(2, null, expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.getLocation(
          request,
          expectedOptions,
          (
            err?: Error | null,
            result?: LocationProtos.google.cloud.location.ILocation | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      assert((client.locationsClient.getLocation as SinonStub).getCall(0));
    });
    it('invokes getLocation with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new LocationProtos.google.cloud.location.GetLocationRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedOptions = {
        otherArgs: {
          headers: {
            'x-goog-request-params': expectedHeaderRequestParams,
          },
        },
      };
      const expectedError = new Error('expected');
      client.locationsClient.getLocation = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(
        client.getLocation(request, expectedOptions),
        expectedError
      );
      assert(
        (client.locationsClient.getLocation as SinonStub)
          .getCall(0)
          .calledWith(request, expectedOptions, undefined)
      );
    });
  });
  describe('listLocationsAsync', () => {
    it('uses async iteration with listLocations without error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new LocationProtos.google.cloud.location.ListLocationsRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedResponse = [
        generateSampleMessage(
          new LocationProtos.google.cloud.location.Location()
        ),
        generateSampleMessage(
          new LocationProtos.google.cloud.location.Location()
        ),
        generateSampleMessage(
          new LocationProtos.google.cloud.location.Location()
        ),
      ];
      client.locationsClient.descriptors.page.listLocations.asyncIterate =
        stubAsyncIterationCall(expectedResponse);
      const responses: LocationProtos.google.cloud.location.ILocation[] = [];
      const iterable = client.listLocationsAsync(request);
      for await (const resource of iterable) {
        responses.push(resource!);
      }
      assert.deepStrictEqual(responses, expectedResponse);
      assert.deepStrictEqual(
        (
          client.locationsClient.descriptors.page.listLocations
            .asyncIterate as SinonStub
        ).getCall(0).args[1],
        request
      );
      assert(
        (
          client.locationsClient.descriptors.page.listLocations
            .asyncIterate as SinonStub
        )
          .getCall(0)
          .args[2].otherArgs.headers['x-goog-request-params'].includes(
            expectedHeaderRequestParams
          )
      );
    });
    it('uses async iteration with listLocations with error', async () => {
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new LocationProtos.google.cloud.location.ListLocationsRequest()
      );
      request.name = '';
      const expectedHeaderRequestParams = 'name=';
      const expectedError = new Error('expected');
      client.locationsClient.descriptors.page.listLocations.asyncIterate =
        stubAsyncIterationCall(undefined, expectedError);
      const iterable = client.listLocationsAsync(request);
      await assert.rejects(async () => {
        const responses: LocationProtos.google.cloud.location.ILocation[] = [];
        for await (const resource of iterable) {
          responses.push(resource!);
        }
      });
      assert.deepStrictEqual(
        (
          client.locationsClient.descriptors.page.listLocations
            .asyncIterate as SinonStub
        ).getCall(0).args[1],
        request
      );
      assert(
        (
          client.locationsClient.descriptors.page.listLocations
            .asyncIterate as SinonStub
        )
          .getCall(0)
          .args[2].otherArgs.headers['x-goog-request-params'].includes(
            expectedHeaderRequestParams
          )
      );
    });
  });

  describe('Path templates', () => {
    describe('discoveryConfig', () => {
      const fakePath = '/rendered/path/discoveryConfig';
      const expectedParameters = {
        project: 'projectValue',
        location: 'locationValue',
        discovery_config: 'discoveryConfigValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.discoveryConfigPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.discoveryConfigPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('discoveryConfigPath', () => {
        const result = client.discoveryConfigPath(
          'projectValue',
          'locationValue',
          'discoveryConfigValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (client.pathTemplates.discoveryConfigPathTemplate.render as SinonStub)
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchProjectFromDiscoveryConfigName', () => {
        const result = client.matchProjectFromDiscoveryConfigName(fakePath);
        assert.strictEqual(result, 'projectValue');
        assert(
          (client.pathTemplates.discoveryConfigPathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchLocationFromDiscoveryConfigName', () => {
        const result = client.matchLocationFromDiscoveryConfigName(fakePath);
        assert.strictEqual(result, 'locationValue');
        assert(
          (client.pathTemplates.discoveryConfigPathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchDiscoveryConfigFromDiscoveryConfigName', () => {
        const result =
          client.matchDiscoveryConfigFromDiscoveryConfigName(fakePath);
        assert.strictEqual(result, 'discoveryConfigValue');
        assert(
          (client.pathTemplates.discoveryConfigPathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('finding', () => {
      const fakePath = '/rendered/path/finding';
      const expectedParameters = {
        project: 'projectValue',
        location: 'locationValue',
        finding: 'findingValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.findingPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.findingPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('findingPath', () => {
        const result = client.findingPath(
          'projectValue',
          'locationValue',
          'findingValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (client.pathTemplates.findingPathTemplate.render as SinonStub)
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchProjectFromFindingName', () => {
        const result = client.matchProjectFromFindingName(fakePath);
        assert.strictEqual(result, 'projectValue');
        assert(
          (client.pathTemplates.findingPathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchLocationFromFindingName', () => {
        const result = client.matchLocationFromFindingName(fakePath);
        assert.strictEqual(result, 'locationValue');
        assert(
          (client.pathTemplates.findingPathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchFindingFromFindingName', () => {
        const result = client.matchFindingFromFindingName(fakePath);
        assert.strictEqual(result, 'findingValue');
        assert(
          (client.pathTemplates.findingPathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('location', () => {
      const fakePath = '/rendered/path/location';
      const expectedParameters = {
        project: 'projectValue',
        location: 'locationValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.locationPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.locationPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('locationPath', () => {
        const result = client.locationPath('projectValue', 'locationValue');
        assert.strictEqual(result, fakePath);
        assert(
          (client.pathTemplates.locationPathTemplate.render as SinonStub)
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchProjectFromLocationName', () => {
        const result = client.matchProjectFromLocationName(fakePath);
        assert.strictEqual(result, 'projectValue');
        assert(
          (client.pathTemplates.locationPathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchLocationFromLocationName', () => {
        const result = client.matchLocationFromLocationName(fakePath);
        assert.strictEqual(result, 'locationValue');
        assert(
          (client.pathTemplates.locationPathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('organization', () => {
      const fakePath = '/rendered/path/organization';
      const expectedParameters = {
        organization: 'organizationValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.organizationPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.organizationPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('organizationPath', () => {
        const result = client.organizationPath('organizationValue');
        assert.strictEqual(result, fakePath);
        assert(
          (client.pathTemplates.organizationPathTemplate.render as SinonStub)
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchOrganizationFromOrganizationName', () => {
        const result = client.matchOrganizationFromOrganizationName(fakePath);
        assert.strictEqual(result, 'organizationValue');
        assert(
          (client.pathTemplates.organizationPathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('organizationDeidentifyTemplate', () => {
      const fakePath = '/rendered/path/organizationDeidentifyTemplate';
      const expectedParameters = {
        organization: 'organizationValue',
        deidentify_template: 'deidentifyTemplateValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.organizationDeidentifyTemplatePathTemplate.render =
        sinon.stub().returns(fakePath);
      client.pathTemplates.organizationDeidentifyTemplatePathTemplate.match =
        sinon.stub().returns(expectedParameters);

      it('organizationDeidentifyTemplatePath', () => {
        const result = client.organizationDeidentifyTemplatePath(
          'organizationValue',
          'deidentifyTemplateValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.organizationDeidentifyTemplatePathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchOrganizationFromOrganizationDeidentifyTemplateName', () => {
        const result =
          client.matchOrganizationFromOrganizationDeidentifyTemplateName(
            fakePath
          );
        assert.strictEqual(result, 'organizationValue');
        assert(
          (
            client.pathTemplates.organizationDeidentifyTemplatePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchDeidentifyTemplateFromOrganizationDeidentifyTemplateName', () => {
        const result =
          client.matchDeidentifyTemplateFromOrganizationDeidentifyTemplateName(
            fakePath
          );
        assert.strictEqual(result, 'deidentifyTemplateValue');
        assert(
          (
            client.pathTemplates.organizationDeidentifyTemplatePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('organizationInspectTemplate', () => {
      const fakePath = '/rendered/path/organizationInspectTemplate';
      const expectedParameters = {
        organization: 'organizationValue',
        inspect_template: 'inspectTemplateValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.organizationInspectTemplatePathTemplate.render =
        sinon.stub().returns(fakePath);
      client.pathTemplates.organizationInspectTemplatePathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('organizationInspectTemplatePath', () => {
        const result = client.organizationInspectTemplatePath(
          'organizationValue',
          'inspectTemplateValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.organizationInspectTemplatePathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchOrganizationFromOrganizationInspectTemplateName', () => {
        const result =
          client.matchOrganizationFromOrganizationInspectTemplateName(fakePath);
        assert.strictEqual(result, 'organizationValue');
        assert(
          (
            client.pathTemplates.organizationInspectTemplatePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchInspectTemplateFromOrganizationInspectTemplateName', () => {
        const result =
          client.matchInspectTemplateFromOrganizationInspectTemplateName(
            fakePath
          );
        assert.strictEqual(result, 'inspectTemplateValue');
        assert(
          (
            client.pathTemplates.organizationInspectTemplatePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('organizationLocation', () => {
      const fakePath = '/rendered/path/organizationLocation';
      const expectedParameters = {
        organization: 'organizationValue',
        location: 'locationValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.organizationLocationPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.organizationLocationPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('organizationLocationPath', () => {
        const result = client.organizationLocationPath(
          'organizationValue',
          'locationValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.organizationLocationPathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchOrganizationFromOrganizationLocationName', () => {
        const result =
          client.matchOrganizationFromOrganizationLocationName(fakePath);
        assert.strictEqual(result, 'organizationValue');
        assert(
          (
            client.pathTemplates.organizationLocationPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchLocationFromOrganizationLocationName', () => {
        const result =
          client.matchLocationFromOrganizationLocationName(fakePath);
        assert.strictEqual(result, 'locationValue');
        assert(
          (
            client.pathTemplates.organizationLocationPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('organizationLocationColumnDataProfile', () => {
      const fakePath = '/rendered/path/organizationLocationColumnDataProfile';
      const expectedParameters = {
        organization: 'organizationValue',
        location: 'locationValue',
        column_data_profile: 'columnDataProfileValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.organizationLocationColumnDataProfilePathTemplate.render =
        sinon.stub().returns(fakePath);
      client.pathTemplates.organizationLocationColumnDataProfilePathTemplate.match =
        sinon.stub().returns(expectedParameters);

      it('organizationLocationColumnDataProfilePath', () => {
        const result = client.organizationLocationColumnDataProfilePath(
          'organizationValue',
          'locationValue',
          'columnDataProfileValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates
              .organizationLocationColumnDataProfilePathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchOrganizationFromOrganizationLocationColumnDataProfileName', () => {
        const result =
          client.matchOrganizationFromOrganizationLocationColumnDataProfileName(
            fakePath
          );
        assert.strictEqual(result, 'organizationValue');
        assert(
          (
            client.pathTemplates
              .organizationLocationColumnDataProfilePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchLocationFromOrganizationLocationColumnDataProfileName', () => {
        const result =
          client.matchLocationFromOrganizationLocationColumnDataProfileName(
            fakePath
          );
        assert.strictEqual(result, 'locationValue');
        assert(
          (
            client.pathTemplates
              .organizationLocationColumnDataProfilePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchColumnDataProfileFromOrganizationLocationColumnDataProfileName', () => {
        const result =
          client.matchColumnDataProfileFromOrganizationLocationColumnDataProfileName(
            fakePath
          );
        assert.strictEqual(result, 'columnDataProfileValue');
        assert(
          (
            client.pathTemplates
              .organizationLocationColumnDataProfilePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('organizationLocationConnection', () => {
      const fakePath = '/rendered/path/organizationLocationConnection';
      const expectedParameters = {
        organization: 'organizationValue',
        location: 'locationValue',
        connection: 'connectionValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.organizationLocationConnectionPathTemplate.render =
        sinon.stub().returns(fakePath);
      client.pathTemplates.organizationLocationConnectionPathTemplate.match =
        sinon.stub().returns(expectedParameters);

      it('organizationLocationConnectionPath', () => {
        const result = client.organizationLocationConnectionPath(
          'organizationValue',
          'locationValue',
          'connectionValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.organizationLocationConnectionPathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchOrganizationFromOrganizationLocationConnectionName', () => {
        const result =
          client.matchOrganizationFromOrganizationLocationConnectionName(
            fakePath
          );
        assert.strictEqual(result, 'organizationValue');
        assert(
          (
            client.pathTemplates.organizationLocationConnectionPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchLocationFromOrganizationLocationConnectionName', () => {
        const result =
          client.matchLocationFromOrganizationLocationConnectionName(fakePath);
        assert.strictEqual(result, 'locationValue');
        assert(
          (
            client.pathTemplates.organizationLocationConnectionPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchConnectionFromOrganizationLocationConnectionName', () => {
        const result =
          client.matchConnectionFromOrganizationLocationConnectionName(
            fakePath
          );
        assert.strictEqual(result, 'connectionValue');
        assert(
          (
            client.pathTemplates.organizationLocationConnectionPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('organizationLocationDeidentifyTemplate', () => {
      const fakePath = '/rendered/path/organizationLocationDeidentifyTemplate';
      const expectedParameters = {
        organization: 'organizationValue',
        location: 'locationValue',
        deidentify_template: 'deidentifyTemplateValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.organizationLocationDeidentifyTemplatePathTemplate.render =
        sinon.stub().returns(fakePath);
      client.pathTemplates.organizationLocationDeidentifyTemplatePathTemplate.match =
        sinon.stub().returns(expectedParameters);

      it('organizationLocationDeidentifyTemplatePath', () => {
        const result = client.organizationLocationDeidentifyTemplatePath(
          'organizationValue',
          'locationValue',
          'deidentifyTemplateValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates
              .organizationLocationDeidentifyTemplatePathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchOrganizationFromOrganizationLocationDeidentifyTemplateName', () => {
        const result =
          client.matchOrganizationFromOrganizationLocationDeidentifyTemplateName(
            fakePath
          );
        assert.strictEqual(result, 'organizationValue');
        assert(
          (
            client.pathTemplates
              .organizationLocationDeidentifyTemplatePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchLocationFromOrganizationLocationDeidentifyTemplateName', () => {
        const result =
          client.matchLocationFromOrganizationLocationDeidentifyTemplateName(
            fakePath
          );
        assert.strictEqual(result, 'locationValue');
        assert(
          (
            client.pathTemplates
              .organizationLocationDeidentifyTemplatePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchDeidentifyTemplateFromOrganizationLocationDeidentifyTemplateName', () => {
        const result =
          client.matchDeidentifyTemplateFromOrganizationLocationDeidentifyTemplateName(
            fakePath
          );
        assert.strictEqual(result, 'deidentifyTemplateValue');
        assert(
          (
            client.pathTemplates
              .organizationLocationDeidentifyTemplatePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('organizationLocationFileStoreDataProfile', () => {
      const fakePath =
        '/rendered/path/organizationLocationFileStoreDataProfile';
      const expectedParameters = {
        organization: 'organizationValue',
        location: 'locationValue',
        file_store_data_profile: 'fileStoreDataProfileValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.organizationLocationFileStoreDataProfilePathTemplate.render =
        sinon.stub().returns(fakePath);
      client.pathTemplates.organizationLocationFileStoreDataProfilePathTemplate.match =
        sinon.stub().returns(expectedParameters);

      it('organizationLocationFileStoreDataProfilePath', () => {
        const result = client.organizationLocationFileStoreDataProfilePath(
          'organizationValue',
          'locationValue',
          'fileStoreDataProfileValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates
              .organizationLocationFileStoreDataProfilePathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchOrganizationFromOrganizationLocationFileStoreDataProfileName', () => {
        const result =
          client.matchOrganizationFromOrganizationLocationFileStoreDataProfileName(
            fakePath
          );
        assert.strictEqual(result, 'organizationValue');
        assert(
          (
            client.pathTemplates
              .organizationLocationFileStoreDataProfilePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchLocationFromOrganizationLocationFileStoreDataProfileName', () => {
        const result =
          client.matchLocationFromOrganizationLocationFileStoreDataProfileName(
            fakePath
          );
        assert.strictEqual(result, 'locationValue');
        assert(
          (
            client.pathTemplates
              .organizationLocationFileStoreDataProfilePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchFileStoreDataProfileFromOrganizationLocationFileStoreDataProfileName', () => {
        const result =
          client.matchFileStoreDataProfileFromOrganizationLocationFileStoreDataProfileName(
            fakePath
          );
        assert.strictEqual(result, 'fileStoreDataProfileValue');
        assert(
          (
            client.pathTemplates
              .organizationLocationFileStoreDataProfilePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('organizationLocationInspectTemplate', () => {
      const fakePath = '/rendered/path/organizationLocationInspectTemplate';
      const expectedParameters = {
        organization: 'organizationValue',
        location: 'locationValue',
        inspect_template: 'inspectTemplateValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.organizationLocationInspectTemplatePathTemplate.render =
        sinon.stub().returns(fakePath);
      client.pathTemplates.organizationLocationInspectTemplatePathTemplate.match =
        sinon.stub().returns(expectedParameters);

      it('organizationLocationInspectTemplatePath', () => {
        const result = client.organizationLocationInspectTemplatePath(
          'organizationValue',
          'locationValue',
          'inspectTemplateValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.organizationLocationInspectTemplatePathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchOrganizationFromOrganizationLocationInspectTemplateName', () => {
        const result =
          client.matchOrganizationFromOrganizationLocationInspectTemplateName(
            fakePath
          );
        assert.strictEqual(result, 'organizationValue');
        assert(
          (
            client.pathTemplates.organizationLocationInspectTemplatePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchLocationFromOrganizationLocationInspectTemplateName', () => {
        const result =
          client.matchLocationFromOrganizationLocationInspectTemplateName(
            fakePath
          );
        assert.strictEqual(result, 'locationValue');
        assert(
          (
            client.pathTemplates.organizationLocationInspectTemplatePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchInspectTemplateFromOrganizationLocationInspectTemplateName', () => {
        const result =
          client.matchInspectTemplateFromOrganizationLocationInspectTemplateName(
            fakePath
          );
        assert.strictEqual(result, 'inspectTemplateValue');
        assert(
          (
            client.pathTemplates.organizationLocationInspectTemplatePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('organizationLocationProjectDataProfile', () => {
      const fakePath = '/rendered/path/organizationLocationProjectDataProfile';
      const expectedParameters = {
        organization: 'organizationValue',
        location: 'locationValue',
        project_data_profile: 'projectDataProfileValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.organizationLocationProjectDataProfilePathTemplate.render =
        sinon.stub().returns(fakePath);
      client.pathTemplates.organizationLocationProjectDataProfilePathTemplate.match =
        sinon.stub().returns(expectedParameters);

      it('organizationLocationProjectDataProfilePath', () => {
        const result = client.organizationLocationProjectDataProfilePath(
          'organizationValue',
          'locationValue',
          'projectDataProfileValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates
              .organizationLocationProjectDataProfilePathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchOrganizationFromOrganizationLocationProjectDataProfileName', () => {
        const result =
          client.matchOrganizationFromOrganizationLocationProjectDataProfileName(
            fakePath
          );
        assert.strictEqual(result, 'organizationValue');
        assert(
          (
            client.pathTemplates
              .organizationLocationProjectDataProfilePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchLocationFromOrganizationLocationProjectDataProfileName', () => {
        const result =
          client.matchLocationFromOrganizationLocationProjectDataProfileName(
            fakePath
          );
        assert.strictEqual(result, 'locationValue');
        assert(
          (
            client.pathTemplates
              .organizationLocationProjectDataProfilePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchProjectDataProfileFromOrganizationLocationProjectDataProfileName', () => {
        const result =
          client.matchProjectDataProfileFromOrganizationLocationProjectDataProfileName(
            fakePath
          );
        assert.strictEqual(result, 'projectDataProfileValue');
        assert(
          (
            client.pathTemplates
              .organizationLocationProjectDataProfilePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('organizationLocationStoredInfoType', () => {
      const fakePath = '/rendered/path/organizationLocationStoredInfoType';
      const expectedParameters = {
        organization: 'organizationValue',
        location: 'locationValue',
        stored_info_type: 'storedInfoTypeValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.organizationLocationStoredInfoTypePathTemplate.render =
        sinon.stub().returns(fakePath);
      client.pathTemplates.organizationLocationStoredInfoTypePathTemplate.match =
        sinon.stub().returns(expectedParameters);

      it('organizationLocationStoredInfoTypePath', () => {
        const result = client.organizationLocationStoredInfoTypePath(
          'organizationValue',
          'locationValue',
          'storedInfoTypeValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.organizationLocationStoredInfoTypePathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchOrganizationFromOrganizationLocationStoredInfoTypeName', () => {
        const result =
          client.matchOrganizationFromOrganizationLocationStoredInfoTypeName(
            fakePath
          );
        assert.strictEqual(result, 'organizationValue');
        assert(
          (
            client.pathTemplates.organizationLocationStoredInfoTypePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchLocationFromOrganizationLocationStoredInfoTypeName', () => {
        const result =
          client.matchLocationFromOrganizationLocationStoredInfoTypeName(
            fakePath
          );
        assert.strictEqual(result, 'locationValue');
        assert(
          (
            client.pathTemplates.organizationLocationStoredInfoTypePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchStoredInfoTypeFromOrganizationLocationStoredInfoTypeName', () => {
        const result =
          client.matchStoredInfoTypeFromOrganizationLocationStoredInfoTypeName(
            fakePath
          );
        assert.strictEqual(result, 'storedInfoTypeValue');
        assert(
          (
            client.pathTemplates.organizationLocationStoredInfoTypePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('organizationLocationTableDataProfile', () => {
      const fakePath = '/rendered/path/organizationLocationTableDataProfile';
      const expectedParameters = {
        organization: 'organizationValue',
        location: 'locationValue',
        table_data_profile: 'tableDataProfileValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.organizationLocationTableDataProfilePathTemplate.render =
        sinon.stub().returns(fakePath);
      client.pathTemplates.organizationLocationTableDataProfilePathTemplate.match =
        sinon.stub().returns(expectedParameters);

      it('organizationLocationTableDataProfilePath', () => {
        const result = client.organizationLocationTableDataProfilePath(
          'organizationValue',
          'locationValue',
          'tableDataProfileValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates
              .organizationLocationTableDataProfilePathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchOrganizationFromOrganizationLocationTableDataProfileName', () => {
        const result =
          client.matchOrganizationFromOrganizationLocationTableDataProfileName(
            fakePath
          );
        assert.strictEqual(result, 'organizationValue');
        assert(
          (
            client.pathTemplates
              .organizationLocationTableDataProfilePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchLocationFromOrganizationLocationTableDataProfileName', () => {
        const result =
          client.matchLocationFromOrganizationLocationTableDataProfileName(
            fakePath
          );
        assert.strictEqual(result, 'locationValue');
        assert(
          (
            client.pathTemplates
              .organizationLocationTableDataProfilePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchTableDataProfileFromOrganizationLocationTableDataProfileName', () => {
        const result =
          client.matchTableDataProfileFromOrganizationLocationTableDataProfileName(
            fakePath
          );
        assert.strictEqual(result, 'tableDataProfileValue');
        assert(
          (
            client.pathTemplates
              .organizationLocationTableDataProfilePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('organizationStoredInfoType', () => {
      const fakePath = '/rendered/path/organizationStoredInfoType';
      const expectedParameters = {
        organization: 'organizationValue',
        stored_info_type: 'storedInfoTypeValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.organizationStoredInfoTypePathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.organizationStoredInfoTypePathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('organizationStoredInfoTypePath', () => {
        const result = client.organizationStoredInfoTypePath(
          'organizationValue',
          'storedInfoTypeValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.organizationStoredInfoTypePathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchOrganizationFromOrganizationStoredInfoTypeName', () => {
        const result =
          client.matchOrganizationFromOrganizationStoredInfoTypeName(fakePath);
        assert.strictEqual(result, 'organizationValue');
        assert(
          (
            client.pathTemplates.organizationStoredInfoTypePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchStoredInfoTypeFromOrganizationStoredInfoTypeName', () => {
        const result =
          client.matchStoredInfoTypeFromOrganizationStoredInfoTypeName(
            fakePath
          );
        assert.strictEqual(result, 'storedInfoTypeValue');
        assert(
          (
            client.pathTemplates.organizationStoredInfoTypePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('project', () => {
      const fakePath = '/rendered/path/project';
      const expectedParameters = {
        project: 'projectValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.projectPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.projectPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('projectPath', () => {
        const result = client.projectPath('projectValue');
        assert.strictEqual(result, fakePath);
        assert(
          (client.pathTemplates.projectPathTemplate.render as SinonStub)
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchProjectFromProjectName', () => {
        const result = client.matchProjectFromProjectName(fakePath);
        assert.strictEqual(result, 'projectValue');
        assert(
          (client.pathTemplates.projectPathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('projectDeidentifyTemplate', () => {
      const fakePath = '/rendered/path/projectDeidentifyTemplate';
      const expectedParameters = {
        project: 'projectValue',
        deidentify_template: 'deidentifyTemplateValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.projectDeidentifyTemplatePathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.projectDeidentifyTemplatePathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('projectDeidentifyTemplatePath', () => {
        const result = client.projectDeidentifyTemplatePath(
          'projectValue',
          'deidentifyTemplateValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.projectDeidentifyTemplatePathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchProjectFromProjectDeidentifyTemplateName', () => {
        const result =
          client.matchProjectFromProjectDeidentifyTemplateName(fakePath);
        assert.strictEqual(result, 'projectValue');
        assert(
          (
            client.pathTemplates.projectDeidentifyTemplatePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchDeidentifyTemplateFromProjectDeidentifyTemplateName', () => {
        const result =
          client.matchDeidentifyTemplateFromProjectDeidentifyTemplateName(
            fakePath
          );
        assert.strictEqual(result, 'deidentifyTemplateValue');
        assert(
          (
            client.pathTemplates.projectDeidentifyTemplatePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('projectDlpContent', () => {
      const fakePath = '/rendered/path/projectDlpContent';
      const expectedParameters = {
        project: 'projectValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.projectDlpContentPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.projectDlpContentPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('projectDlpContentPath', () => {
        const result = client.projectDlpContentPath('projectValue');
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.projectDlpContentPathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchProjectFromProjectDlpContentName', () => {
        const result = client.matchProjectFromProjectDlpContentName(fakePath);
        assert.strictEqual(result, 'projectValue');
        assert(
          (
            client.pathTemplates.projectDlpContentPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('projectDlpJob', () => {
      const fakePath = '/rendered/path/projectDlpJob';
      const expectedParameters = {
        project: 'projectValue',
        dlp_job: 'dlpJobValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.projectDlpJobPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.projectDlpJobPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('projectDlpJobPath', () => {
        const result = client.projectDlpJobPath('projectValue', 'dlpJobValue');
        assert.strictEqual(result, fakePath);
        assert(
          (client.pathTemplates.projectDlpJobPathTemplate.render as SinonStub)
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchProjectFromProjectDlpJobName', () => {
        const result = client.matchProjectFromProjectDlpJobName(fakePath);
        assert.strictEqual(result, 'projectValue');
        assert(
          (client.pathTemplates.projectDlpJobPathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchDlpJobFromProjectDlpJobName', () => {
        const result = client.matchDlpJobFromProjectDlpJobName(fakePath);
        assert.strictEqual(result, 'dlpJobValue');
        assert(
          (client.pathTemplates.projectDlpJobPathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('projectInspectTemplate', () => {
      const fakePath = '/rendered/path/projectInspectTemplate';
      const expectedParameters = {
        project: 'projectValue',
        inspect_template: 'inspectTemplateValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.projectInspectTemplatePathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.projectInspectTemplatePathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('projectInspectTemplatePath', () => {
        const result = client.projectInspectTemplatePath(
          'projectValue',
          'inspectTemplateValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.projectInspectTemplatePathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchProjectFromProjectInspectTemplateName', () => {
        const result =
          client.matchProjectFromProjectInspectTemplateName(fakePath);
        assert.strictEqual(result, 'projectValue');
        assert(
          (
            client.pathTemplates.projectInspectTemplatePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchInspectTemplateFromProjectInspectTemplateName', () => {
        const result =
          client.matchInspectTemplateFromProjectInspectTemplateName(fakePath);
        assert.strictEqual(result, 'inspectTemplateValue');
        assert(
          (
            client.pathTemplates.projectInspectTemplatePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('projectJobTrigger', () => {
      const fakePath = '/rendered/path/projectJobTrigger';
      const expectedParameters = {
        project: 'projectValue',
        job_trigger: 'jobTriggerValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.projectJobTriggerPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.projectJobTriggerPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('projectJobTriggerPath', () => {
        const result = client.projectJobTriggerPath(
          'projectValue',
          'jobTriggerValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.projectJobTriggerPathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchProjectFromProjectJobTriggerName', () => {
        const result = client.matchProjectFromProjectJobTriggerName(fakePath);
        assert.strictEqual(result, 'projectValue');
        assert(
          (
            client.pathTemplates.projectJobTriggerPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchJobTriggerFromProjectJobTriggerName', () => {
        const result =
          client.matchJobTriggerFromProjectJobTriggerName(fakePath);
        assert.strictEqual(result, 'jobTriggerValue');
        assert(
          (
            client.pathTemplates.projectJobTriggerPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('projectLocationColumnDataProfile', () => {
      const fakePath = '/rendered/path/projectLocationColumnDataProfile';
      const expectedParameters = {
        project: 'projectValue',
        location: 'locationValue',
        column_data_profile: 'columnDataProfileValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.projectLocationColumnDataProfilePathTemplate.render =
        sinon.stub().returns(fakePath);
      client.pathTemplates.projectLocationColumnDataProfilePathTemplate.match =
        sinon.stub().returns(expectedParameters);

      it('projectLocationColumnDataProfilePath', () => {
        const result = client.projectLocationColumnDataProfilePath(
          'projectValue',
          'locationValue',
          'columnDataProfileValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.projectLocationColumnDataProfilePathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchProjectFromProjectLocationColumnDataProfileName', () => {
        const result =
          client.matchProjectFromProjectLocationColumnDataProfileName(fakePath);
        assert.strictEqual(result, 'projectValue');
        assert(
          (
            client.pathTemplates.projectLocationColumnDataProfilePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchLocationFromProjectLocationColumnDataProfileName', () => {
        const result =
          client.matchLocationFromProjectLocationColumnDataProfileName(
            fakePath
          );
        assert.strictEqual(result, 'locationValue');
        assert(
          (
            client.pathTemplates.projectLocationColumnDataProfilePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchColumnDataProfileFromProjectLocationColumnDataProfileName', () => {
        const result =
          client.matchColumnDataProfileFromProjectLocationColumnDataProfileName(
            fakePath
          );
        assert.strictEqual(result, 'columnDataProfileValue');
        assert(
          (
            client.pathTemplates.projectLocationColumnDataProfilePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('projectLocationConnection', () => {
      const fakePath = '/rendered/path/projectLocationConnection';
      const expectedParameters = {
        project: 'projectValue',
        location: 'locationValue',
        connection: 'connectionValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.projectLocationConnectionPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.projectLocationConnectionPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('projectLocationConnectionPath', () => {
        const result = client.projectLocationConnectionPath(
          'projectValue',
          'locationValue',
          'connectionValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.projectLocationConnectionPathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchProjectFromProjectLocationConnectionName', () => {
        const result =
          client.matchProjectFromProjectLocationConnectionName(fakePath);
        assert.strictEqual(result, 'projectValue');
        assert(
          (
            client.pathTemplates.projectLocationConnectionPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchLocationFromProjectLocationConnectionName', () => {
        const result =
          client.matchLocationFromProjectLocationConnectionName(fakePath);
        assert.strictEqual(result, 'locationValue');
        assert(
          (
            client.pathTemplates.projectLocationConnectionPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchConnectionFromProjectLocationConnectionName', () => {
        const result =
          client.matchConnectionFromProjectLocationConnectionName(fakePath);
        assert.strictEqual(result, 'connectionValue');
        assert(
          (
            client.pathTemplates.projectLocationConnectionPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('projectLocationDeidentifyTemplate', () => {
      const fakePath = '/rendered/path/projectLocationDeidentifyTemplate';
      const expectedParameters = {
        project: 'projectValue',
        location: 'locationValue',
        deidentify_template: 'deidentifyTemplateValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.projectLocationDeidentifyTemplatePathTemplate.render =
        sinon.stub().returns(fakePath);
      client.pathTemplates.projectLocationDeidentifyTemplatePathTemplate.match =
        sinon.stub().returns(expectedParameters);

      it('projectLocationDeidentifyTemplatePath', () => {
        const result = client.projectLocationDeidentifyTemplatePath(
          'projectValue',
          'locationValue',
          'deidentifyTemplateValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.projectLocationDeidentifyTemplatePathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchProjectFromProjectLocationDeidentifyTemplateName', () => {
        const result =
          client.matchProjectFromProjectLocationDeidentifyTemplateName(
            fakePath
          );
        assert.strictEqual(result, 'projectValue');
        assert(
          (
            client.pathTemplates.projectLocationDeidentifyTemplatePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchLocationFromProjectLocationDeidentifyTemplateName', () => {
        const result =
          client.matchLocationFromProjectLocationDeidentifyTemplateName(
            fakePath
          );
        assert.strictEqual(result, 'locationValue');
        assert(
          (
            client.pathTemplates.projectLocationDeidentifyTemplatePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchDeidentifyTemplateFromProjectLocationDeidentifyTemplateName', () => {
        const result =
          client.matchDeidentifyTemplateFromProjectLocationDeidentifyTemplateName(
            fakePath
          );
        assert.strictEqual(result, 'deidentifyTemplateValue');
        assert(
          (
            client.pathTemplates.projectLocationDeidentifyTemplatePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('projectLocationDlpJob', () => {
      const fakePath = '/rendered/path/projectLocationDlpJob';
      const expectedParameters = {
        project: 'projectValue',
        location: 'locationValue',
        dlp_job: 'dlpJobValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.projectLocationDlpJobPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.projectLocationDlpJobPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('projectLocationDlpJobPath', () => {
        const result = client.projectLocationDlpJobPath(
          'projectValue',
          'locationValue',
          'dlpJobValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.projectLocationDlpJobPathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchProjectFromProjectLocationDlpJobName', () => {
        const result =
          client.matchProjectFromProjectLocationDlpJobName(fakePath);
        assert.strictEqual(result, 'projectValue');
        assert(
          (
            client.pathTemplates.projectLocationDlpJobPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchLocationFromProjectLocationDlpJobName', () => {
        const result =
          client.matchLocationFromProjectLocationDlpJobName(fakePath);
        assert.strictEqual(result, 'locationValue');
        assert(
          (
            client.pathTemplates.projectLocationDlpJobPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchDlpJobFromProjectLocationDlpJobName', () => {
        const result =
          client.matchDlpJobFromProjectLocationDlpJobName(fakePath);
        assert.strictEqual(result, 'dlpJobValue');
        assert(
          (
            client.pathTemplates.projectLocationDlpJobPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('projectLocationFileStoreDataProfile', () => {
      const fakePath = '/rendered/path/projectLocationFileStoreDataProfile';
      const expectedParameters = {
        project: 'projectValue',
        location: 'locationValue',
        file_store_data_profile: 'fileStoreDataProfileValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.projectLocationFileStoreDataProfilePathTemplate.render =
        sinon.stub().returns(fakePath);
      client.pathTemplates.projectLocationFileStoreDataProfilePathTemplate.match =
        sinon.stub().returns(expectedParameters);

      it('projectLocationFileStoreDataProfilePath', () => {
        const result = client.projectLocationFileStoreDataProfilePath(
          'projectValue',
          'locationValue',
          'fileStoreDataProfileValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.projectLocationFileStoreDataProfilePathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchProjectFromProjectLocationFileStoreDataProfileName', () => {
        const result =
          client.matchProjectFromProjectLocationFileStoreDataProfileName(
            fakePath
          );
        assert.strictEqual(result, 'projectValue');
        assert(
          (
            client.pathTemplates.projectLocationFileStoreDataProfilePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchLocationFromProjectLocationFileStoreDataProfileName', () => {
        const result =
          client.matchLocationFromProjectLocationFileStoreDataProfileName(
            fakePath
          );
        assert.strictEqual(result, 'locationValue');
        assert(
          (
            client.pathTemplates.projectLocationFileStoreDataProfilePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchFileStoreDataProfileFromProjectLocationFileStoreDataProfileName', () => {
        const result =
          client.matchFileStoreDataProfileFromProjectLocationFileStoreDataProfileName(
            fakePath
          );
        assert.strictEqual(result, 'fileStoreDataProfileValue');
        assert(
          (
            client.pathTemplates.projectLocationFileStoreDataProfilePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('projectLocationInspectTemplate', () => {
      const fakePath = '/rendered/path/projectLocationInspectTemplate';
      const expectedParameters = {
        project: 'projectValue',
        location: 'locationValue',
        inspect_template: 'inspectTemplateValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.projectLocationInspectTemplatePathTemplate.render =
        sinon.stub().returns(fakePath);
      client.pathTemplates.projectLocationInspectTemplatePathTemplate.match =
        sinon.stub().returns(expectedParameters);

      it('projectLocationInspectTemplatePath', () => {
        const result = client.projectLocationInspectTemplatePath(
          'projectValue',
          'locationValue',
          'inspectTemplateValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.projectLocationInspectTemplatePathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchProjectFromProjectLocationInspectTemplateName', () => {
        const result =
          client.matchProjectFromProjectLocationInspectTemplateName(fakePath);
        assert.strictEqual(result, 'projectValue');
        assert(
          (
            client.pathTemplates.projectLocationInspectTemplatePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchLocationFromProjectLocationInspectTemplateName', () => {
        const result =
          client.matchLocationFromProjectLocationInspectTemplateName(fakePath);
        assert.strictEqual(result, 'locationValue');
        assert(
          (
            client.pathTemplates.projectLocationInspectTemplatePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchInspectTemplateFromProjectLocationInspectTemplateName', () => {
        const result =
          client.matchInspectTemplateFromProjectLocationInspectTemplateName(
            fakePath
          );
        assert.strictEqual(result, 'inspectTemplateValue');
        assert(
          (
            client.pathTemplates.projectLocationInspectTemplatePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('projectLocationJobTrigger', () => {
      const fakePath = '/rendered/path/projectLocationJobTrigger';
      const expectedParameters = {
        project: 'projectValue',
        location: 'locationValue',
        job_trigger: 'jobTriggerValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.projectLocationJobTriggerPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.projectLocationJobTriggerPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('projectLocationJobTriggerPath', () => {
        const result = client.projectLocationJobTriggerPath(
          'projectValue',
          'locationValue',
          'jobTriggerValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.projectLocationJobTriggerPathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchProjectFromProjectLocationJobTriggerName', () => {
        const result =
          client.matchProjectFromProjectLocationJobTriggerName(fakePath);
        assert.strictEqual(result, 'projectValue');
        assert(
          (
            client.pathTemplates.projectLocationJobTriggerPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchLocationFromProjectLocationJobTriggerName', () => {
        const result =
          client.matchLocationFromProjectLocationJobTriggerName(fakePath);
        assert.strictEqual(result, 'locationValue');
        assert(
          (
            client.pathTemplates.projectLocationJobTriggerPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchJobTriggerFromProjectLocationJobTriggerName', () => {
        const result =
          client.matchJobTriggerFromProjectLocationJobTriggerName(fakePath);
        assert.strictEqual(result, 'jobTriggerValue');
        assert(
          (
            client.pathTemplates.projectLocationJobTriggerPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('projectLocationProjectDataProfile', () => {
      const fakePath = '/rendered/path/projectLocationProjectDataProfile';
      const expectedParameters = {
        project: 'projectValue',
        location: 'locationValue',
        project_data_profile: 'projectDataProfileValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.projectLocationProjectDataProfilePathTemplate.render =
        sinon.stub().returns(fakePath);
      client.pathTemplates.projectLocationProjectDataProfilePathTemplate.match =
        sinon.stub().returns(expectedParameters);

      it('projectLocationProjectDataProfilePath', () => {
        const result = client.projectLocationProjectDataProfilePath(
          'projectValue',
          'locationValue',
          'projectDataProfileValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.projectLocationProjectDataProfilePathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchProjectFromProjectLocationProjectDataProfileName', () => {
        const result =
          client.matchProjectFromProjectLocationProjectDataProfileName(
            fakePath
          );
        assert.strictEqual(result, 'projectValue');
        assert(
          (
            client.pathTemplates.projectLocationProjectDataProfilePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchLocationFromProjectLocationProjectDataProfileName', () => {
        const result =
          client.matchLocationFromProjectLocationProjectDataProfileName(
            fakePath
          );
        assert.strictEqual(result, 'locationValue');
        assert(
          (
            client.pathTemplates.projectLocationProjectDataProfilePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchProjectDataProfileFromProjectLocationProjectDataProfileName', () => {
        const result =
          client.matchProjectDataProfileFromProjectLocationProjectDataProfileName(
            fakePath
          );
        assert.strictEqual(result, 'projectDataProfileValue');
        assert(
          (
            client.pathTemplates.projectLocationProjectDataProfilePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('projectLocationStoredInfoType', () => {
      const fakePath = '/rendered/path/projectLocationStoredInfoType';
      const expectedParameters = {
        project: 'projectValue',
        location: 'locationValue',
        stored_info_type: 'storedInfoTypeValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.projectLocationStoredInfoTypePathTemplate.render =
        sinon.stub().returns(fakePath);
      client.pathTemplates.projectLocationStoredInfoTypePathTemplate.match =
        sinon.stub().returns(expectedParameters);

      it('projectLocationStoredInfoTypePath', () => {
        const result = client.projectLocationStoredInfoTypePath(
          'projectValue',
          'locationValue',
          'storedInfoTypeValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.projectLocationStoredInfoTypePathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchProjectFromProjectLocationStoredInfoTypeName', () => {
        const result =
          client.matchProjectFromProjectLocationStoredInfoTypeName(fakePath);
        assert.strictEqual(result, 'projectValue');
        assert(
          (
            client.pathTemplates.projectLocationStoredInfoTypePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchLocationFromProjectLocationStoredInfoTypeName', () => {
        const result =
          client.matchLocationFromProjectLocationStoredInfoTypeName(fakePath);
        assert.strictEqual(result, 'locationValue');
        assert(
          (
            client.pathTemplates.projectLocationStoredInfoTypePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchStoredInfoTypeFromProjectLocationStoredInfoTypeName', () => {
        const result =
          client.matchStoredInfoTypeFromProjectLocationStoredInfoTypeName(
            fakePath
          );
        assert.strictEqual(result, 'storedInfoTypeValue');
        assert(
          (
            client.pathTemplates.projectLocationStoredInfoTypePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('projectLocationTableDataProfile', () => {
      const fakePath = '/rendered/path/projectLocationTableDataProfile';
      const expectedParameters = {
        project: 'projectValue',
        location: 'locationValue',
        table_data_profile: 'tableDataProfileValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.projectLocationTableDataProfilePathTemplate.render =
        sinon.stub().returns(fakePath);
      client.pathTemplates.projectLocationTableDataProfilePathTemplate.match =
        sinon.stub().returns(expectedParameters);

      it('projectLocationTableDataProfilePath', () => {
        const result = client.projectLocationTableDataProfilePath(
          'projectValue',
          'locationValue',
          'tableDataProfileValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.projectLocationTableDataProfilePathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchProjectFromProjectLocationTableDataProfileName', () => {
        const result =
          client.matchProjectFromProjectLocationTableDataProfileName(fakePath);
        assert.strictEqual(result, 'projectValue');
        assert(
          (
            client.pathTemplates.projectLocationTableDataProfilePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchLocationFromProjectLocationTableDataProfileName', () => {
        const result =
          client.matchLocationFromProjectLocationTableDataProfileName(fakePath);
        assert.strictEqual(result, 'locationValue');
        assert(
          (
            client.pathTemplates.projectLocationTableDataProfilePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchTableDataProfileFromProjectLocationTableDataProfileName', () => {
        const result =
          client.matchTableDataProfileFromProjectLocationTableDataProfileName(
            fakePath
          );
        assert.strictEqual(result, 'tableDataProfileValue');
        assert(
          (
            client.pathTemplates.projectLocationTableDataProfilePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('projectStoredInfoType', () => {
      const fakePath = '/rendered/path/projectStoredInfoType';
      const expectedParameters = {
        project: 'projectValue',
        stored_info_type: 'storedInfoTypeValue',
      };
      const client = new dlpserviceModule.v2.DlpServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.projectStoredInfoTypePathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.projectStoredInfoTypePathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('projectStoredInfoTypePath', () => {
        const result = client.projectStoredInfoTypePath(
          'projectValue',
          'storedInfoTypeValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.projectStoredInfoTypePathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchProjectFromProjectStoredInfoTypeName', () => {
        const result =
          client.matchProjectFromProjectStoredInfoTypeName(fakePath);
        assert.strictEqual(result, 'projectValue');
        assert(
          (
            client.pathTemplates.projectStoredInfoTypePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchStoredInfoTypeFromProjectStoredInfoTypeName', () => {
        const result =
          client.matchStoredInfoTypeFromProjectStoredInfoTypeName(fakePath);
        assert.strictEqual(result, 'storedInfoTypeValue');
        assert(
          (
            client.pathTemplates.projectStoredInfoTypePathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });
  });
});
