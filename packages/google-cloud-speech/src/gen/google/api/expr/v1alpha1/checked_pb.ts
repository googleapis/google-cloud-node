// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file google/api/expr/v1alpha1/checked.proto (package google.api.expr.v1alpha1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Empty, Message, NullValue, proto3 } from "@bufbuild/protobuf";
import { Constant, Expr, SourceInfo } from "./syntax_pb.js";

/**
 * A CEL expression which has been successfully type checked.
 *
 * @generated from message google.api.expr.v1alpha1.CheckedExpr
 */
export class CheckedExpr extends Message<CheckedExpr> {
  /**
   * A map from expression ids to resolved references.
   *
   * The following entries are in this table:
   *
   * - An Ident or Select expression is represented here if it resolves to a
   *   declaration. For instance, if `a.b.c` is represented by
   *   `select(select(id(a), b), c)`, and `a.b` resolves to a declaration,
   *   while `c` is a field selection, then the reference is attached to the
   *   nested select expression (but not to the id or or the outer select).
   *   In turn, if `a` resolves to a declaration and `b.c` are field selections,
   *   the reference is attached to the ident expression.
   * - Every Call expression has an entry here, identifying the function being
   *   called.
   * - Every CreateStruct expression for a message has an entry, identifying
   *   the message.
   *
   * @generated from field: map<int64, google.api.expr.v1alpha1.Reference> reference_map = 2;
   */
  referenceMap: { [key: string]: Reference } = {};

  /**
   * A map from expression ids to types.
   *
   * Every expression node which has a type different than DYN has a mapping
   * here. If an expression has type DYN, it is omitted from this map to save
   * space.
   *
   * @generated from field: map<int64, google.api.expr.v1alpha1.Type> type_map = 3;
   */
  typeMap: { [key: string]: Type } = {};

  /**
   * The source info derived from input that generated the parsed `expr` and
   * any optimizations made during the type-checking pass.
   *
   * @generated from field: google.api.expr.v1alpha1.SourceInfo source_info = 5;
   */
  sourceInfo?: SourceInfo;

  /**
   * The expr version indicates the major / minor version number of the `expr`
   * representation.
   *
   * The most common reason for a version change will be to indicate to the CEL
   * runtimes that transformations have been performed on the expr during static
   * analysis. In some cases, this will save the runtime the work of applying
   * the same or similar transformations prior to evaluation.
   *
   * @generated from field: string expr_version = 6;
   */
  exprVersion = "";

  /**
   * The checked expression. Semantically equivalent to the parsed `expr`, but
   * may have structural differences.
   *
   * @generated from field: google.api.expr.v1alpha1.Expr expr = 4;
   */
  expr?: Expr;

  constructor(data?: PartialMessage<CheckedExpr>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.api.expr.v1alpha1.CheckedExpr";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "reference_map", kind: "map", K: 3 /* ScalarType.INT64 */, V: {kind: "message", T: Reference} },
    { no: 3, name: "type_map", kind: "map", K: 3 /* ScalarType.INT64 */, V: {kind: "message", T: Type} },
    { no: 5, name: "source_info", kind: "message", T: SourceInfo },
    { no: 6, name: "expr_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "expr", kind: "message", T: Expr },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CheckedExpr {
    return new CheckedExpr().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CheckedExpr {
    return new CheckedExpr().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CheckedExpr {
    return new CheckedExpr().fromJsonString(jsonString, options);
  }

  static equals(a: CheckedExpr | PlainMessage<CheckedExpr> | undefined, b: CheckedExpr | PlainMessage<CheckedExpr> | undefined): boolean {
    return proto3.util.equals(CheckedExpr, a, b);
  }
}

/**
 * Represents a CEL type.
 *
 * @generated from message google.api.expr.v1alpha1.Type
 */
export class Type extends Message<Type> {
  /**
   * The kind of type.
   *
   * @generated from oneof google.api.expr.v1alpha1.Type.type_kind
   */
  typeKind: {
    /**
     * Dynamic type.
     *
     * @generated from field: google.protobuf.Empty dyn = 1;
     */
    value: Empty;
    case: "dyn";
  } | {
    /**
     * Null value.
     *
     * @generated from field: google.protobuf.NullValue null = 2;
     */
    value: NullValue;
    case: "null";
  } | {
    /**
     * Primitive types: `true`, `1u`, `-2.0`, `'string'`, `b'bytes'`.
     *
     * @generated from field: google.api.expr.v1alpha1.Type.PrimitiveType primitive = 3;
     */
    value: Type_PrimitiveType;
    case: "primitive";
  } | {
    /**
     * Wrapper of a primitive type, e.g. `google.protobuf.Int64Value`.
     *
     * @generated from field: google.api.expr.v1alpha1.Type.PrimitiveType wrapper = 4;
     */
    value: Type_PrimitiveType;
    case: "wrapper";
  } | {
    /**
     * Well-known protobuf type such as `google.protobuf.Timestamp`.
     *
     * @generated from field: google.api.expr.v1alpha1.Type.WellKnownType well_known = 5;
     */
    value: Type_WellKnownType;
    case: "wellKnown";
  } | {
    /**
     * Parameterized list with elements of `list_type`, e.g. `list<timestamp>`.
     *
     * @generated from field: google.api.expr.v1alpha1.Type.ListType list_type = 6;
     */
    value: Type_ListType;
    case: "listType";
  } | {
    /**
     * Parameterized map with typed keys and values.
     *
     * @generated from field: google.api.expr.v1alpha1.Type.MapType map_type = 7;
     */
    value: Type_MapType;
    case: "mapType";
  } | {
    /**
     * Function type.
     *
     * @generated from field: google.api.expr.v1alpha1.Type.FunctionType function = 8;
     */
    value: Type_FunctionType;
    case: "function";
  } | {
    /**
     * Protocol buffer message type.
     *
     * The `message_type` string specifies the qualified message type name. For
     * example, `google.plus.Profile`.
     *
     * @generated from field: string message_type = 9;
     */
    value: string;
    case: "messageType";
  } | {
    /**
     * Type param type.
     *
     * The `type_param` string specifies the type parameter name, e.g. `list<E>`
     * would be a `list_type` whose element type was a `type_param` type
     * named `E`.
     *
     * @generated from field: string type_param = 10;
     */
    value: string;
    case: "typeParam";
  } | {
    /**
     * Type type.
     *
     * The `type` value specifies the target type. e.g. int is type with a
     * target type of `Primitive.INT`.
     *
     * @generated from field: google.api.expr.v1alpha1.Type type = 11;
     */
    value: Type;
    case: "type";
  } | {
    /**
     * Error type.
     *
     * During type-checking if an expression is an error, its type is propagated
     * as the `ERROR` type. This permits the type-checker to discover other
     * errors present in the expression.
     *
     * @generated from field: google.protobuf.Empty error = 12;
     */
    value: Empty;
    case: "error";
  } | {
    /**
     * Abstract, application defined type.
     *
     * @generated from field: google.api.expr.v1alpha1.Type.AbstractType abstract_type = 14;
     */
    value: Type_AbstractType;
    case: "abstractType";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Type>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.api.expr.v1alpha1.Type";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "dyn", kind: "message", T: Empty, oneof: "type_kind" },
    { no: 2, name: "null", kind: "enum", T: proto3.getEnumType(NullValue), oneof: "type_kind" },
    { no: 3, name: "primitive", kind: "enum", T: proto3.getEnumType(Type_PrimitiveType), oneof: "type_kind" },
    { no: 4, name: "wrapper", kind: "enum", T: proto3.getEnumType(Type_PrimitiveType), oneof: "type_kind" },
    { no: 5, name: "well_known", kind: "enum", T: proto3.getEnumType(Type_WellKnownType), oneof: "type_kind" },
    { no: 6, name: "list_type", kind: "message", T: Type_ListType, oneof: "type_kind" },
    { no: 7, name: "map_type", kind: "message", T: Type_MapType, oneof: "type_kind" },
    { no: 8, name: "function", kind: "message", T: Type_FunctionType, oneof: "type_kind" },
    { no: 9, name: "message_type", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "type_kind" },
    { no: 10, name: "type_param", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "type_kind" },
    { no: 11, name: "type", kind: "message", T: Type, oneof: "type_kind" },
    { no: 12, name: "error", kind: "message", T: Empty, oneof: "type_kind" },
    { no: 14, name: "abstract_type", kind: "message", T: Type_AbstractType, oneof: "type_kind" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Type {
    return new Type().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Type {
    return new Type().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Type {
    return new Type().fromJsonString(jsonString, options);
  }

  static equals(a: Type | PlainMessage<Type> | undefined, b: Type | PlainMessage<Type> | undefined): boolean {
    return proto3.util.equals(Type, a, b);
  }
}

/**
 * CEL primitive types.
 *
 * @generated from enum google.api.expr.v1alpha1.Type.PrimitiveType
 */
export enum Type_PrimitiveType {
  /**
   * Unspecified type.
   *
   * @generated from enum value: PRIMITIVE_TYPE_UNSPECIFIED = 0;
   */
  PRIMITIVE_TYPE_UNSPECIFIED = 0,

  /**
   * Boolean type.
   *
   * @generated from enum value: BOOL = 1;
   */
  BOOL = 1,

  /**
   * Int64 type.
   *
   * Proto-based integer values are widened to int64.
   *
   * @generated from enum value: INT64 = 2;
   */
  INT64 = 2,

  /**
   * Uint64 type.
   *
   * Proto-based unsigned integer values are widened to uint64.
   *
   * @generated from enum value: UINT64 = 3;
   */
  UINT64 = 3,

  /**
   * Double type.
   *
   * Proto-based float values are widened to double values.
   *
   * @generated from enum value: DOUBLE = 4;
   */
  DOUBLE = 4,

  /**
   * String type.
   *
   * @generated from enum value: STRING = 5;
   */
  STRING = 5,

  /**
   * Bytes type.
   *
   * @generated from enum value: BYTES = 6;
   */
  BYTES = 6,
}
// Retrieve enum metadata with: proto3.getEnumType(Type_PrimitiveType)
proto3.util.setEnumType(Type_PrimitiveType, "google.api.expr.v1alpha1.Type.PrimitiveType", [
  { no: 0, name: "PRIMITIVE_TYPE_UNSPECIFIED" },
  { no: 1, name: "BOOL" },
  { no: 2, name: "INT64" },
  { no: 3, name: "UINT64" },
  { no: 4, name: "DOUBLE" },
  { no: 5, name: "STRING" },
  { no: 6, name: "BYTES" },
]);

/**
 * Well-known protobuf types treated with first-class support in CEL.
 *
 * @generated from enum google.api.expr.v1alpha1.Type.WellKnownType
 */
export enum Type_WellKnownType {
  /**
   * Unspecified type.
   *
   * @generated from enum value: WELL_KNOWN_TYPE_UNSPECIFIED = 0;
   */
  WELL_KNOWN_TYPE_UNSPECIFIED = 0,

  /**
   * Well-known protobuf.Any type.
   *
   * Any types are a polymorphic message type. During type-checking they are
   * treated like `DYN` types, but at runtime they are resolved to a specific
   * message type specified at evaluation time.
   *
   * @generated from enum value: ANY = 1;
   */
  ANY = 1,

  /**
   * Well-known protobuf.Timestamp type, internally referenced as `timestamp`.
   *
   * @generated from enum value: TIMESTAMP = 2;
   */
  TIMESTAMP = 2,

  /**
   * Well-known protobuf.Duration type, internally referenced as `duration`.
   *
   * @generated from enum value: DURATION = 3;
   */
  DURATION = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(Type_WellKnownType)
proto3.util.setEnumType(Type_WellKnownType, "google.api.expr.v1alpha1.Type.WellKnownType", [
  { no: 0, name: "WELL_KNOWN_TYPE_UNSPECIFIED" },
  { no: 1, name: "ANY" },
  { no: 2, name: "TIMESTAMP" },
  { no: 3, name: "DURATION" },
]);

/**
 * List type with typed elements, e.g. `list<example.proto.MyMessage>`.
 *
 * @generated from message google.api.expr.v1alpha1.Type.ListType
 */
export class Type_ListType extends Message<Type_ListType> {
  /**
   * The element type.
   *
   * @generated from field: google.api.expr.v1alpha1.Type elem_type = 1;
   */
  elemType?: Type;

  constructor(data?: PartialMessage<Type_ListType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.api.expr.v1alpha1.Type.ListType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "elem_type", kind: "message", T: Type },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Type_ListType {
    return new Type_ListType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Type_ListType {
    return new Type_ListType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Type_ListType {
    return new Type_ListType().fromJsonString(jsonString, options);
  }

  static equals(a: Type_ListType | PlainMessage<Type_ListType> | undefined, b: Type_ListType | PlainMessage<Type_ListType> | undefined): boolean {
    return proto3.util.equals(Type_ListType, a, b);
  }
}

/**
 * Map type with parameterized key and value types, e.g. `map<string, int>`.
 *
 * @generated from message google.api.expr.v1alpha1.Type.MapType
 */
export class Type_MapType extends Message<Type_MapType> {
  /**
   * The type of the key.
   *
   * @generated from field: google.api.expr.v1alpha1.Type key_type = 1;
   */
  keyType?: Type;

  /**
   * The type of the value.
   *
   * @generated from field: google.api.expr.v1alpha1.Type value_type = 2;
   */
  valueType?: Type;

  constructor(data?: PartialMessage<Type_MapType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.api.expr.v1alpha1.Type.MapType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key_type", kind: "message", T: Type },
    { no: 2, name: "value_type", kind: "message", T: Type },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Type_MapType {
    return new Type_MapType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Type_MapType {
    return new Type_MapType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Type_MapType {
    return new Type_MapType().fromJsonString(jsonString, options);
  }

  static equals(a: Type_MapType | PlainMessage<Type_MapType> | undefined, b: Type_MapType | PlainMessage<Type_MapType> | undefined): boolean {
    return proto3.util.equals(Type_MapType, a, b);
  }
}

/**
 * Function type with result and arg types.
 *
 * @generated from message google.api.expr.v1alpha1.Type.FunctionType
 */
export class Type_FunctionType extends Message<Type_FunctionType> {
  /**
   * Result type of the function.
   *
   * @generated from field: google.api.expr.v1alpha1.Type result_type = 1;
   */
  resultType?: Type;

  /**
   * Argument types of the function.
   *
   * @generated from field: repeated google.api.expr.v1alpha1.Type arg_types = 2;
   */
  argTypes: Type[] = [];

  constructor(data?: PartialMessage<Type_FunctionType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.api.expr.v1alpha1.Type.FunctionType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result_type", kind: "message", T: Type },
    { no: 2, name: "arg_types", kind: "message", T: Type, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Type_FunctionType {
    return new Type_FunctionType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Type_FunctionType {
    return new Type_FunctionType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Type_FunctionType {
    return new Type_FunctionType().fromJsonString(jsonString, options);
  }

  static equals(a: Type_FunctionType | PlainMessage<Type_FunctionType> | undefined, b: Type_FunctionType | PlainMessage<Type_FunctionType> | undefined): boolean {
    return proto3.util.equals(Type_FunctionType, a, b);
  }
}

/**
 * Application defined abstract type.
 *
 * @generated from message google.api.expr.v1alpha1.Type.AbstractType
 */
export class Type_AbstractType extends Message<Type_AbstractType> {
  /**
   * The fully qualified name of this abstract type.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Parameter types for this abstract type.
   *
   * @generated from field: repeated google.api.expr.v1alpha1.Type parameter_types = 2;
   */
  parameterTypes: Type[] = [];

  constructor(data?: PartialMessage<Type_AbstractType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.api.expr.v1alpha1.Type.AbstractType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "parameter_types", kind: "message", T: Type, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Type_AbstractType {
    return new Type_AbstractType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Type_AbstractType {
    return new Type_AbstractType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Type_AbstractType {
    return new Type_AbstractType().fromJsonString(jsonString, options);
  }

  static equals(a: Type_AbstractType | PlainMessage<Type_AbstractType> | undefined, b: Type_AbstractType | PlainMessage<Type_AbstractType> | undefined): boolean {
    return proto3.util.equals(Type_AbstractType, a, b);
  }
}

/**
 * Represents a declaration of a named value or function.
 *
 * A declaration is part of the contract between the expression, the agent
 * evaluating that expression, and the caller requesting evaluation.
 *
 * @generated from message google.api.expr.v1alpha1.Decl
 */
export class Decl extends Message<Decl> {
  /**
   * The fully qualified name of the declaration.
   *
   * Declarations are organized in containers and this represents the full path
   * to the declaration in its container, as in `google.api.expr.Decl`.
   *
   * Declarations used as
   * [FunctionDecl.Overload][google.api.expr.v1alpha1.Decl.FunctionDecl.Overload]
   * parameters may or may not have a name depending on whether the overload is
   * function declaration or a function definition containing a result
   * [Expr][google.api.expr.v1alpha1.Expr].
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Required. The declaration kind.
   *
   * @generated from oneof google.api.expr.v1alpha1.Decl.decl_kind
   */
  declKind: {
    /**
     * Identifier declaration.
     *
     * @generated from field: google.api.expr.v1alpha1.Decl.IdentDecl ident = 2;
     */
    value: Decl_IdentDecl;
    case: "ident";
  } | {
    /**
     * Function declaration.
     *
     * @generated from field: google.api.expr.v1alpha1.Decl.FunctionDecl function = 3;
     */
    value: Decl_FunctionDecl;
    case: "function";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Decl>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.api.expr.v1alpha1.Decl";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "ident", kind: "message", T: Decl_IdentDecl, oneof: "decl_kind" },
    { no: 3, name: "function", kind: "message", T: Decl_FunctionDecl, oneof: "decl_kind" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Decl {
    return new Decl().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Decl {
    return new Decl().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Decl {
    return new Decl().fromJsonString(jsonString, options);
  }

  static equals(a: Decl | PlainMessage<Decl> | undefined, b: Decl | PlainMessage<Decl> | undefined): boolean {
    return proto3.util.equals(Decl, a, b);
  }
}

/**
 * Identifier declaration which specifies its type and optional `Expr` value.
 *
 * An identifier without a value is a declaration that must be provided at
 * evaluation time. An identifier with a value should resolve to a constant,
 * but may be used in conjunction with other identifiers bound at evaluation
 * time.
 *
 * @generated from message google.api.expr.v1alpha1.Decl.IdentDecl
 */
export class Decl_IdentDecl extends Message<Decl_IdentDecl> {
  /**
   * Required. The type of the identifier.
   *
   * @generated from field: google.api.expr.v1alpha1.Type type = 1;
   */
  type?: Type;

  /**
   * The constant value of the identifier. If not specified, the identifier
   * must be supplied at evaluation time.
   *
   * @generated from field: google.api.expr.v1alpha1.Constant value = 2;
   */
  value?: Constant;

  /**
   * Documentation string for the identifier.
   *
   * @generated from field: string doc = 3;
   */
  doc = "";

  constructor(data?: PartialMessage<Decl_IdentDecl>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.api.expr.v1alpha1.Decl.IdentDecl";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "message", T: Type },
    { no: 2, name: "value", kind: "message", T: Constant },
    { no: 3, name: "doc", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Decl_IdentDecl {
    return new Decl_IdentDecl().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Decl_IdentDecl {
    return new Decl_IdentDecl().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Decl_IdentDecl {
    return new Decl_IdentDecl().fromJsonString(jsonString, options);
  }

  static equals(a: Decl_IdentDecl | PlainMessage<Decl_IdentDecl> | undefined, b: Decl_IdentDecl | PlainMessage<Decl_IdentDecl> | undefined): boolean {
    return proto3.util.equals(Decl_IdentDecl, a, b);
  }
}

/**
 * Function declaration specifies one or more overloads which indicate the
 * function's parameter types and return type.
 *
 * Functions have no observable side-effects (there may be side-effects like
 * logging which are not observable from CEL).
 *
 * @generated from message google.api.expr.v1alpha1.Decl.FunctionDecl
 */
export class Decl_FunctionDecl extends Message<Decl_FunctionDecl> {
  /**
   * Required. List of function overloads, must contain at least one overload.
   *
   * @generated from field: repeated google.api.expr.v1alpha1.Decl.FunctionDecl.Overload overloads = 1;
   */
  overloads: Decl_FunctionDecl_Overload[] = [];

  constructor(data?: PartialMessage<Decl_FunctionDecl>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.api.expr.v1alpha1.Decl.FunctionDecl";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "overloads", kind: "message", T: Decl_FunctionDecl_Overload, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Decl_FunctionDecl {
    return new Decl_FunctionDecl().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Decl_FunctionDecl {
    return new Decl_FunctionDecl().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Decl_FunctionDecl {
    return new Decl_FunctionDecl().fromJsonString(jsonString, options);
  }

  static equals(a: Decl_FunctionDecl | PlainMessage<Decl_FunctionDecl> | undefined, b: Decl_FunctionDecl | PlainMessage<Decl_FunctionDecl> | undefined): boolean {
    return proto3.util.equals(Decl_FunctionDecl, a, b);
  }
}

/**
 * An overload indicates a function's parameter types and return type, and
 * may optionally include a function body described in terms of
 * [Expr][google.api.expr.v1alpha1.Expr] values.
 *
 * Functions overloads are declared in either a function or method
 * call-style. For methods, the `params[0]` is the expected type of the
 * target receiver.
 *
 * Overloads must have non-overlapping argument types after erasure of all
 * parameterized type variables (similar as type erasure in Java).
 *
 * @generated from message google.api.expr.v1alpha1.Decl.FunctionDecl.Overload
 */
export class Decl_FunctionDecl_Overload extends Message<Decl_FunctionDecl_Overload> {
  /**
   * Required. Globally unique overload name of the function which reflects
   * the function name and argument types.
   *
   * This will be used by a [Reference][google.api.expr.v1alpha1.Reference]
   * to indicate the `overload_id` that was resolved for the function
   * `name`.
   *
   * @generated from field: string overload_id = 1;
   */
  overloadId = "";

  /**
   * List of function parameter [Type][google.api.expr.v1alpha1.Type]
   * values.
   *
   * Param types are disjoint after generic type parameters have been
   * replaced with the type `DYN`. Since the `DYN` type is compatible with
   * any other type, this means that if `A` is a type parameter, the
   * function types `int<A>` and `int<int>` are not disjoint. Likewise,
   * `map<string, string>` is not disjoint from `map<K, V>`.
   *
   * When the `result_type` of a function is a generic type param, the
   * type param name also appears as the `type` of on at least one params.
   *
   * @generated from field: repeated google.api.expr.v1alpha1.Type params = 2;
   */
  params: Type[] = [];

  /**
   * The type param names associated with the function declaration.
   *
   * For example, `function ex<K,V>(K key, map<K, V> map) : V` would yield
   * the type params of `K, V`.
   *
   * @generated from field: repeated string type_params = 3;
   */
  typeParams: string[] = [];

  /**
   * Required. The result type of the function. For example, the operator
   * `string.isEmpty()` would have `result_type` of `kind: BOOL`.
   *
   * @generated from field: google.api.expr.v1alpha1.Type result_type = 4;
   */
  resultType?: Type;

  /**
   * Whether the function is to be used in a method call-style `x.f(...)`
   * or a function call-style `f(x, ...)`.
   *
   * For methods, the first parameter declaration, `params[0]` is the
   * expected type of the target receiver.
   *
   * @generated from field: bool is_instance_function = 5;
   */
  isInstanceFunction = false;

  /**
   * Documentation string for the overload.
   *
   * @generated from field: string doc = 6;
   */
  doc = "";

  constructor(data?: PartialMessage<Decl_FunctionDecl_Overload>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.api.expr.v1alpha1.Decl.FunctionDecl.Overload";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "overload_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "params", kind: "message", T: Type, repeated: true },
    { no: 3, name: "type_params", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "result_type", kind: "message", T: Type },
    { no: 5, name: "is_instance_function", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "doc", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Decl_FunctionDecl_Overload {
    return new Decl_FunctionDecl_Overload().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Decl_FunctionDecl_Overload {
    return new Decl_FunctionDecl_Overload().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Decl_FunctionDecl_Overload {
    return new Decl_FunctionDecl_Overload().fromJsonString(jsonString, options);
  }

  static equals(a: Decl_FunctionDecl_Overload | PlainMessage<Decl_FunctionDecl_Overload> | undefined, b: Decl_FunctionDecl_Overload | PlainMessage<Decl_FunctionDecl_Overload> | undefined): boolean {
    return proto3.util.equals(Decl_FunctionDecl_Overload, a, b);
  }
}

/**
 * Describes a resolved reference to a declaration.
 *
 * @generated from message google.api.expr.v1alpha1.Reference
 */
export class Reference extends Message<Reference> {
  /**
   * The fully qualified name of the declaration.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * For references to functions, this is a list of `Overload.overload_id`
   * values which match according to typing rules.
   *
   * If the list has more than one element, overload resolution among the
   * presented candidates must happen at runtime because of dynamic types. The
   * type checker attempts to narrow down this list as much as possible.
   *
   * Empty if this is not a reference to a
   * [Decl.FunctionDecl][google.api.expr.v1alpha1.Decl.FunctionDecl].
   *
   * @generated from field: repeated string overload_id = 3;
   */
  overloadId: string[] = [];

  /**
   * For references to constants, this may contain the value of the
   * constant if known at compile time.
   *
   * @generated from field: google.api.expr.v1alpha1.Constant value = 4;
   */
  value?: Constant;

  constructor(data?: PartialMessage<Reference>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.api.expr.v1alpha1.Reference";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "overload_id", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "value", kind: "message", T: Constant },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Reference {
    return new Reference().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Reference {
    return new Reference().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Reference {
    return new Reference().fromJsonString(jsonString, options);
  }

  static equals(a: Reference | PlainMessage<Reference> | undefined, b: Reference | PlainMessage<Reference> | undefined): boolean {
    return proto3.util.equals(Reference, a, b);
  }
}

