// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file google/api/servicecontrol/v1/quota_controller.proto (package google.api.servicecontrol.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { MetricValueSet } from "./metric_value_pb.js";
import { Status } from "../../../rpc/status_pb.js";

/**
 * Request message for the AllocateQuota method.
 *
 * @generated from message google.api.servicecontrol.v1.AllocateQuotaRequest
 */
export class AllocateQuotaRequest extends Message<AllocateQuotaRequest> {
  /**
   * Name of the service as specified in the service configuration. For example,
   * `"pubsub.googleapis.com"`.
   *
   * See [google.api.Service][google.api.Service] for the definition of a service name.
   *
   * @generated from field: string service_name = 1;
   */
  serviceName = "";

  /**
   * Operation that describes the quota allocation.
   *
   * @generated from field: google.api.servicecontrol.v1.QuotaOperation allocate_operation = 2;
   */
  allocateOperation?: QuotaOperation;

  /**
   * Specifies which version of service configuration should be used to process
   * the request. If unspecified or no matching version can be found, the latest
   * one will be used.
   *
   * @generated from field: string service_config_id = 4;
   */
  serviceConfigId = "";

  constructor(data?: PartialMessage<AllocateQuotaRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.api.servicecontrol.v1.AllocateQuotaRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "service_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "allocate_operation", kind: "message", T: QuotaOperation },
    { no: 4, name: "service_config_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AllocateQuotaRequest {
    return new AllocateQuotaRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AllocateQuotaRequest {
    return new AllocateQuotaRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AllocateQuotaRequest {
    return new AllocateQuotaRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AllocateQuotaRequest | PlainMessage<AllocateQuotaRequest> | undefined, b: AllocateQuotaRequest | PlainMessage<AllocateQuotaRequest> | undefined): boolean {
    return proto3.util.equals(AllocateQuotaRequest, a, b);
  }
}

/**
 * Represents information regarding a quota operation.
 *
 * @generated from message google.api.servicecontrol.v1.QuotaOperation
 */
export class QuotaOperation extends Message<QuotaOperation> {
  /**
   * Identity of the operation. This is expected to be unique within the scope
   * of the service that generated the operation, and guarantees idempotency in
   * case of retries.
   *
   * In order to ensure best performance and latency in the Quota backends,
   * operation_ids are optimally associated with time, so that related
   * operations can be accessed fast in storage. For this reason, the
   * recommended token for services that intend to operate at a high QPS is
   * Unix time in nanos + UUID
   *
   * @generated from field: string operation_id = 1;
   */
  operationId = "";

  /**
   * Fully qualified name of the API method for which this quota operation is
   * requested. This name is used for matching quota rules or metric rules and
   * billing status rules defined in service configuration.
   *
   * This field should not be set if any of the following is true:
   * (1) the quota operation is performed on non-API resources.
   * (2) quota_metrics is set because the caller is doing quota override.
   *
   *
   * Example of an RPC method name:
   *     google.example.library.v1.LibraryService.CreateShelf
   *
   * @generated from field: string method_name = 2;
   */
  methodName = "";

  /**
   * Identity of the consumer for whom this quota operation is being performed.
   *
   * This can be in one of the following formats:
   *   project:<project_id>,
   *   project_number:<project_number>,
   *   api_key:<api_key>.
   *
   * @generated from field: string consumer_id = 3;
   */
  consumerId = "";

  /**
   * Labels describing the operation.
   *
   * @generated from field: map<string, string> labels = 4;
   */
  labels: { [key: string]: string } = {};

  /**
   * Represents information about this operation. Each MetricValueSet
   * corresponds to a metric defined in the service configuration.
   * The data type used in the MetricValueSet must agree with
   * the data type specified in the metric definition.
   *
   * Within a single operation, it is not allowed to have more than one
   * MetricValue instances that have the same metric names and identical
   * label value combinations. If a request has such duplicated MetricValue
   * instances, the entire request is rejected with
   * an invalid argument error.
   *
   * This field is mutually exclusive with method_name.
   *
   * @generated from field: repeated google.api.servicecontrol.v1.MetricValueSet quota_metrics = 5;
   */
  quotaMetrics: MetricValueSet[] = [];

  /**
   * Quota mode for this operation.
   *
   * @generated from field: google.api.servicecontrol.v1.QuotaOperation.QuotaMode quota_mode = 6;
   */
  quotaMode = QuotaOperation_QuotaMode.UNSPECIFIED;

  constructor(data?: PartialMessage<QuotaOperation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.api.servicecontrol.v1.QuotaOperation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "operation_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "method_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "consumer_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "labels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 5, name: "quota_metrics", kind: "message", T: MetricValueSet, repeated: true },
    { no: 6, name: "quota_mode", kind: "enum", T: proto3.getEnumType(QuotaOperation_QuotaMode) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QuotaOperation {
    return new QuotaOperation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QuotaOperation {
    return new QuotaOperation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QuotaOperation {
    return new QuotaOperation().fromJsonString(jsonString, options);
  }

  static equals(a: QuotaOperation | PlainMessage<QuotaOperation> | undefined, b: QuotaOperation | PlainMessage<QuotaOperation> | undefined): boolean {
    return proto3.util.equals(QuotaOperation, a, b);
  }
}

/**
 * Supported quota modes.
 *
 * @generated from enum google.api.servicecontrol.v1.QuotaOperation.QuotaMode
 */
export enum QuotaOperation_QuotaMode {
  /**
   * Guard against implicit default. Must not be used.
   *
   * @generated from enum value: UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * For AllocateQuota request, allocates quota for the amount specified in
   * the service configuration or specified using the quota metrics. If the
   * amount is higher than the available quota, allocation error will be
   * returned and no quota will be allocated.
   * If multiple quotas are part of the request, and one fails, none of the
   * quotas are allocated or released.
   *
   * @generated from enum value: NORMAL = 1;
   */
  NORMAL = 1,

  /**
   * The operation allocates quota for the amount specified in the service
   * configuration or specified using the quota metrics. If the amount is
   * higher than the available quota, request does not fail but all available
   * quota will be allocated.
   * For rate quota, BEST_EFFORT will continue to deduct from other groups
   * even if one does not have enough quota. For allocation, it will find the
   * minimum available amount across all groups and deduct that amount from
   * all the affected groups.
   *
   * @generated from enum value: BEST_EFFORT = 2;
   */
  BEST_EFFORT = 2,

  /**
   * For AllocateQuota request, only checks if there is enough quota
   * available and does not change the available quota. No lock is placed on
   * the available quota either.
   *
   * @generated from enum value: CHECK_ONLY = 3;
   */
  CHECK_ONLY = 3,

  /**
   * Unimplemented. When used in AllocateQuotaRequest, this returns the
   * effective quota limit(s) in the response, and no quota check will be
   * performed. Not supported for other requests, and even for
   * AllocateQuotaRequest, this is currently supported only for allowlisted
   * services.
   *
   * @generated from enum value: QUERY_ONLY = 4;
   */
  QUERY_ONLY = 4,

  /**
   * The operation allocates quota for the amount specified in the service
   * configuration or specified using the quota metrics. If the requested
   * amount is higher than the available quota, request does not fail and
   * remaining quota would become negative (going over the limit).
   * Not supported for Rate Quota.
   *
   * @generated from enum value: ADJUST_ONLY = 5;
   */
  ADJUST_ONLY = 5,
}
// Retrieve enum metadata with: proto3.getEnumType(QuotaOperation_QuotaMode)
proto3.util.setEnumType(QuotaOperation_QuotaMode, "google.api.servicecontrol.v1.QuotaOperation.QuotaMode", [
  { no: 0, name: "UNSPECIFIED" },
  { no: 1, name: "NORMAL" },
  { no: 2, name: "BEST_EFFORT" },
  { no: 3, name: "CHECK_ONLY" },
  { no: 4, name: "QUERY_ONLY" },
  { no: 5, name: "ADJUST_ONLY" },
]);

/**
 * Response message for the AllocateQuota method.
 *
 * @generated from message google.api.servicecontrol.v1.AllocateQuotaResponse
 */
export class AllocateQuotaResponse extends Message<AllocateQuotaResponse> {
  /**
   * The same operation_id value used in the AllocateQuotaRequest. Used for
   * logging and diagnostics purposes.
   *
   * @generated from field: string operation_id = 1;
   */
  operationId = "";

  /**
   * Indicates the decision of the allocate.
   *
   * @generated from field: repeated google.api.servicecontrol.v1.QuotaError allocate_errors = 2;
   */
  allocateErrors: QuotaError[] = [];

  /**
   * Quota metrics to indicate the result of allocation. Depending on the
   * request, one or more of the following metrics will be included:
   *
   * 1. Per quota group or per quota metric incremental usage will be specified
   * using the following delta metric :
   *   "serviceruntime.googleapis.com/api/consumer/quota_used_count"
   *
   * 2. The quota limit reached condition will be specified using the following
   * boolean metric :
   *   "serviceruntime.googleapis.com/quota/exceeded"
   *
   * @generated from field: repeated google.api.servicecontrol.v1.MetricValueSet quota_metrics = 3;
   */
  quotaMetrics: MetricValueSet[] = [];

  /**
   * ID of the actual config used to process the request.
   *
   * @generated from field: string service_config_id = 4;
   */
  serviceConfigId = "";

  constructor(data?: PartialMessage<AllocateQuotaResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.api.servicecontrol.v1.AllocateQuotaResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "operation_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "allocate_errors", kind: "message", T: QuotaError, repeated: true },
    { no: 3, name: "quota_metrics", kind: "message", T: MetricValueSet, repeated: true },
    { no: 4, name: "service_config_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AllocateQuotaResponse {
    return new AllocateQuotaResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AllocateQuotaResponse {
    return new AllocateQuotaResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AllocateQuotaResponse {
    return new AllocateQuotaResponse().fromJsonString(jsonString, options);
  }

  static equals(a: AllocateQuotaResponse | PlainMessage<AllocateQuotaResponse> | undefined, b: AllocateQuotaResponse | PlainMessage<AllocateQuotaResponse> | undefined): boolean {
    return proto3.util.equals(AllocateQuotaResponse, a, b);
  }
}

/**
 * Represents error information for [QuotaOperation][google.api.servicecontrol.v1.QuotaOperation].
 *
 * @generated from message google.api.servicecontrol.v1.QuotaError
 */
export class QuotaError extends Message<QuotaError> {
  /**
   * Error code.
   *
   * @generated from field: google.api.servicecontrol.v1.QuotaError.Code code = 1;
   */
  code = QuotaError_Code.UNSPECIFIED;

  /**
   * Subject to whom this error applies. See the specific enum for more details
   * on this field. For example, "clientip:<ip address of client>" or
   * "project:<Google developer project id>".
   *
   * @generated from field: string subject = 2;
   */
  subject = "";

  /**
   * Free-form text that provides details on the cause of the error.
   *
   * @generated from field: string description = 3;
   */
  description = "";

  /**
   * Contains additional information about the quota error.
   * If available, `status.code` will be non zero.
   *
   * @generated from field: google.rpc.Status status = 4;
   */
  status?: Status;

  constructor(data?: PartialMessage<QuotaError>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.api.servicecontrol.v1.QuotaError";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "code", kind: "enum", T: proto3.getEnumType(QuotaError_Code) },
    { no: 2, name: "subject", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "status", kind: "message", T: Status },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QuotaError {
    return new QuotaError().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QuotaError {
    return new QuotaError().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QuotaError {
    return new QuotaError().fromJsonString(jsonString, options);
  }

  static equals(a: QuotaError | PlainMessage<QuotaError> | undefined, b: QuotaError | PlainMessage<QuotaError> | undefined): boolean {
    return proto3.util.equals(QuotaError, a, b);
  }
}

/**
 * Error codes related to project config validations are deprecated since the
 * quota controller methods do not perform these validations. Instead services
 * have to call the Check method, without quota_properties field, to perform
 * these validations before calling the quota controller methods. These
 * methods check only for project deletion to be wipe out compliant.
 *
 * @generated from enum google.api.servicecontrol.v1.QuotaError.Code
 */
export enum QuotaError_Code {
  /**
   * This is never used.
   *
   * @generated from enum value: UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Quota allocation failed.
   * Same as [google.rpc.Code.RESOURCE_EXHAUSTED][google.rpc.Code.RESOURCE_EXHAUSTED].
   *
   * @generated from enum value: RESOURCE_EXHAUSTED = 8;
   */
  RESOURCE_EXHAUSTED = 8,

  /**
   * Consumer cannot access the service because the service requires active
   * billing.
   *
   * @generated from enum value: BILLING_NOT_ACTIVE = 107;
   */
  BILLING_NOT_ACTIVE = 107,

  /**
   * Consumer's project has been marked as deleted (soft deletion).
   *
   * @generated from enum value: PROJECT_DELETED = 108;
   */
  PROJECT_DELETED = 108,

  /**
   * Specified API key is invalid.
   *
   * @generated from enum value: API_KEY_INVALID = 105;
   */
  API_KEY_INVALID = 105,

  /**
   * Specified API Key has expired.
   *
   * @generated from enum value: API_KEY_EXPIRED = 112;
   */
  API_KEY_EXPIRED = 112,
}
// Retrieve enum metadata with: proto3.getEnumType(QuotaError_Code)
proto3.util.setEnumType(QuotaError_Code, "google.api.servicecontrol.v1.QuotaError.Code", [
  { no: 0, name: "UNSPECIFIED" },
  { no: 8, name: "RESOURCE_EXHAUSTED" },
  { no: 107, name: "BILLING_NOT_ACTIVE" },
  { no: 108, name: "PROJECT_DELETED" },
  { no: 105, name: "API_KEY_INVALID" },
  { no: 112, name: "API_KEY_EXPIRED" },
]);

