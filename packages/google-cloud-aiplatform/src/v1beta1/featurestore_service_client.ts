// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// ** This file is automatically generated by gapic-generator-typescript. **
// ** https://github.com/googleapis/gapic-generator-typescript **
// ** All changes to this file may be overwritten. **

/* global window */
import * as gax from 'google-gax';
import {
  Callback,
  CallOptions,
  Descriptors,
  ClientOptions,
  LROperation,
  PaginationCallback,
  GaxCall,
} from 'google-gax';
import * as path from 'path';

import {Transform} from 'stream';
import {RequestType} from 'google-gax/build/src/apitypes';
import * as protos from '../../protos/protos';
/**
 * Client JSON configuration object, loaded from
 * `src/v1beta1/featurestore_service_client_config.json`.
 * This file defines retry strategy and timeouts for all API methods in this library.
 */
import * as gapicConfig from './featurestore_service_client_config.json';
import {operationsProtos} from 'google-gax';
const version = require('../../../package.json').version;

/**
 *  The service that handles CRUD and List for resources for Featurestore.
 * @class
 * @memberof v1beta1
 */
export class FeaturestoreServiceClient {
  private _terminated = false;
  private _opts: ClientOptions;
  private _gaxModule: typeof gax | typeof gax.fallback;
  private _gaxGrpc: gax.GrpcClient | gax.fallback.GrpcClient;
  private _protos: {};
  private _defaults: {[method: string]: gax.CallSettings};
  auth: gax.GoogleAuth;
  descriptors: Descriptors = {
    page: {},
    stream: {},
    longrunning: {},
    batching: {},
  };
  innerApiCalls: {[name: string]: Function};
  pathTemplates: {[name: string]: gax.PathTemplate};
  operationsClient: gax.OperationsClient;
  featurestoreServiceStub?: Promise<{[name: string]: Function}>;

  /**
   * Construct an instance of FeaturestoreServiceClient.
   *
   * @param {object} [options] - The configuration object.
   * The options accepted by the constructor are described in detail
   * in [this document](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#creating-the-client-instance).
   * The common options are:
   * @param {object} [options.credentials] - Credentials object.
   * @param {string} [options.credentials.client_email]
   * @param {string} [options.credentials.private_key]
   * @param {string} [options.email] - Account email address. Required when
   *     using a .pem or .p12 keyFilename.
   * @param {string} [options.keyFilename] - Full path to the a .json, .pem, or
   *     .p12 key downloaded from the Google Developers Console. If you provide
   *     a path to a JSON file, the projectId option below is not necessary.
   *     NOTE: .pem and .p12 require you to specify options.email as well.
   * @param {number} [options.port] - The port on which to connect to
   *     the remote host.
   * @param {string} [options.projectId] - The project ID from the Google
   *     Developer's Console, e.g. 'grape-spaceship-123'. We will also check
   *     the environment variable GCLOUD_PROJECT for your project ID. If your
   *     app is running in an environment which supports
   *     {@link https://developers.google.com/identity/protocols/application-default-credentials Application Default Credentials},
   *     your project ID will be detected automatically.
   * @param {string} [options.apiEndpoint] - The domain name of the
   *     API remote host.
   * @param {gax.ClientConfig} [options.clientConfig] - Client configuration override.
   *     Follows the structure of {@link gapicConfig}.
   * @param {boolean} [options.fallback] - Use HTTP fallback mode.
   *     In fallback mode, a special browser-compatible transport implementation is used
   *     instead of gRPC transport. In browser context (if the `window` object is defined)
   *     the fallback mode is enabled automatically; set `options.fallback` to `false`
   *     if you need to override this behavior.
   */
  constructor(opts?: ClientOptions) {
    // Ensure that options include all the required fields.
    const staticMembers = this.constructor as typeof FeaturestoreServiceClient;
    const servicePath =
      opts?.servicePath || opts?.apiEndpoint || staticMembers.servicePath;
    const port = opts?.port || staticMembers.port;
    const clientConfig = opts?.clientConfig ?? {};
    const fallback =
      opts?.fallback ??
      (typeof window !== 'undefined' && typeof window?.fetch === 'function');
    opts = Object.assign({servicePath, port, clientConfig, fallback}, opts);

    // If scopes are unset in options and we're connecting to a non-default endpoint, set scopes just in case.
    if (servicePath !== staticMembers.servicePath && !('scopes' in opts)) {
      opts['scopes'] = staticMembers.scopes;
    }

    // Choose either gRPC or proto-over-HTTP implementation of google-gax.
    this._gaxModule = opts.fallback ? gax.fallback : gax;

    // Create a `gaxGrpc` object, with any grpc-specific options sent to the client.
    this._gaxGrpc = new this._gaxModule.GrpcClient(opts);

    // Save options to use in initialize() method.
    this._opts = opts;

    // Save the auth object to the client, for use by other methods.
    this.auth = this._gaxGrpc.auth as gax.GoogleAuth;

    // Set the default scopes in auth client if needed.
    if (servicePath === staticMembers.servicePath) {
      this.auth.defaultScopes = staticMembers.scopes;
    }

    // Determine the client header string.
    const clientHeader = [`gax/${this._gaxModule.version}`, `gapic/${version}`];
    if (typeof process !== 'undefined' && 'versions' in process) {
      clientHeader.push(`gl-node/${process.versions.node}`);
    } else {
      clientHeader.push(`gl-web/${this._gaxModule.version}`);
    }
    if (!opts.fallback) {
      clientHeader.push(`grpc/${this._gaxGrpc.grpcVersion}`);
    }
    if (opts.libName && opts.libVersion) {
      clientHeader.push(`${opts.libName}/${opts.libVersion}`);
    }
    // Load the applicable protos.
    // For Node.js, pass the path to JSON proto file.
    // For browsers, pass the JSON content.

    const nodejsProtoPath = path.join(
      __dirname,
      '..',
      '..',
      'protos',
      'protos.json'
    );
    this._protos = this._gaxGrpc.loadProto(
      opts.fallback
        ? // eslint-disable-next-line @typescript-eslint/no-var-requires
          require('../../protos/protos.json')
        : nodejsProtoPath
    );

    // This API contains "path templates"; forward-slash-separated
    // identifiers to uniquely identify resources within the API.
    // Create useful helper objects for these.
    this.pathTemplates = {
      annotationPathTemplate: new this._gaxModule.PathTemplate(
        'projects/{project}/locations/{location}/datasets/{dataset}/dataItems/{data_item}/annotations/{annotation}'
      ),
      annotationSpecPathTemplate: new this._gaxModule.PathTemplate(
        'projects/{project}/locations/{location}/datasets/{dataset}/annotationSpecs/{annotation_spec}'
      ),
      artifactPathTemplate: new this._gaxModule.PathTemplate(
        'projects/{project}/locations/{location}/metadataStores/{metadata_store}/artifacts/{artifact}'
      ),
      batchPredictionJobPathTemplate: new this._gaxModule.PathTemplate(
        'projects/{project}/locations/{location}/batchPredictionJobs/{batch_prediction_job}'
      ),
      contextPathTemplate: new this._gaxModule.PathTemplate(
        'projects/{project}/locations/{location}/metadataStores/{metadata_store}/contexts/{context}'
      ),
      customJobPathTemplate: new this._gaxModule.PathTemplate(
        'projects/{project}/locations/{location}/customJobs/{custom_job}'
      ),
      dataItemPathTemplate: new this._gaxModule.PathTemplate(
        'projects/{project}/locations/{location}/datasets/{dataset}/dataItems/{data_item}'
      ),
      dataLabelingJobPathTemplate: new this._gaxModule.PathTemplate(
        'projects/{project}/locations/{location}/dataLabelingJobs/{data_labeling_job}'
      ),
      datasetPathTemplate: new this._gaxModule.PathTemplate(
        'projects/{project}/locations/{location}/datasets/{dataset}'
      ),
      endpointPathTemplate: new this._gaxModule.PathTemplate(
        'projects/{project}/locations/{location}/endpoints/{endpoint}'
      ),
      entityTypePathTemplate: new this._gaxModule.PathTemplate(
        'projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}'
      ),
      executionPathTemplate: new this._gaxModule.PathTemplate(
        'projects/{project}/locations/{location}/metadataStores/{metadata_store}/executions/{execution}'
      ),
      featurePathTemplate: new this._gaxModule.PathTemplate(
        'projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}/features/{feature}'
      ),
      featurestorePathTemplate: new this._gaxModule.PathTemplate(
        'projects/{project}/locations/{location}/featurestores/{featurestore}'
      ),
      hyperparameterTuningJobPathTemplate: new this._gaxModule.PathTemplate(
        'projects/{project}/locations/{location}/hyperparameterTuningJobs/{hyperparameter_tuning_job}'
      ),
      indexPathTemplate: new this._gaxModule.PathTemplate(
        'projects/{project}/locations/{location}/indexes/{index}'
      ),
      indexEndpointPathTemplate: new this._gaxModule.PathTemplate(
        'projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}'
      ),
      locationPathTemplate: new this._gaxModule.PathTemplate(
        'projects/{project}/locations/{location}'
      ),
      metadataSchemaPathTemplate: new this._gaxModule.PathTemplate(
        'projects/{project}/locations/{location}/metadataStores/{metadata_store}/metadataSchemas/{metadata_schema}'
      ),
      metadataStorePathTemplate: new this._gaxModule.PathTemplate(
        'projects/{project}/locations/{location}/metadataStores/{metadata_store}'
      ),
      modelPathTemplate: new this._gaxModule.PathTemplate(
        'projects/{project}/locations/{location}/models/{model}'
      ),
      modelDeploymentMonitoringJobPathTemplate:
        new this._gaxModule.PathTemplate(
          'projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}'
        ),
      modelEvaluationPathTemplate: new this._gaxModule.PathTemplate(
        'projects/{project}/locations/{location}/models/{model}/evaluations/{evaluation}'
      ),
      modelEvaluationSlicePathTemplate: new this._gaxModule.PathTemplate(
        'projects/{project}/locations/{location}/models/{model}/evaluations/{evaluation}/slices/{slice}'
      ),
      pipelineJobPathTemplate: new this._gaxModule.PathTemplate(
        'projects/{project}/locations/{location}/pipelineJobs/{pipeline_job}'
      ),
      projectPathTemplate: new this._gaxModule.PathTemplate(
        'projects/{project}'
      ),
      specialistPoolPathTemplate: new this._gaxModule.PathTemplate(
        'projects/{project}/locations/{location}/specialistPools/{specialist_pool}'
      ),
      studyPathTemplate: new this._gaxModule.PathTemplate(
        'projects/{project}/locations/{location}/studies/{study}'
      ),
      tensorboardPathTemplate: new this._gaxModule.PathTemplate(
        'projects/{project}/locations/{location}/tensorboards/{tensorboard}'
      ),
      tensorboardExperimentPathTemplate: new this._gaxModule.PathTemplate(
        'projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}'
      ),
      tensorboardRunPathTemplate: new this._gaxModule.PathTemplate(
        'projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}'
      ),
      tensorboardTimeSeriesPathTemplate: new this._gaxModule.PathTemplate(
        'projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}/timeSeries/{time_series}'
      ),
      trainingPipelinePathTemplate: new this._gaxModule.PathTemplate(
        'projects/{project}/locations/{location}/trainingPipelines/{training_pipeline}'
      ),
      trialPathTemplate: new this._gaxModule.PathTemplate(
        'projects/{project}/locations/{location}/studies/{study}/trials/{trial}'
      ),
    };

    // Some of the methods on this service return "paged" results,
    // (e.g. 50 results at a time, with tokens to get subsequent
    // pages). Denote the keys used for pagination and results.
    this.descriptors.page = {
      listFeaturestores: new this._gaxModule.PageDescriptor(
        'pageToken',
        'nextPageToken',
        'featurestores'
      ),
      listEntityTypes: new this._gaxModule.PageDescriptor(
        'pageToken',
        'nextPageToken',
        'entityTypes'
      ),
      listFeatures: new this._gaxModule.PageDescriptor(
        'pageToken',
        'nextPageToken',
        'features'
      ),
      searchFeatures: new this._gaxModule.PageDescriptor(
        'pageToken',
        'nextPageToken',
        'features'
      ),
    };

    // This API contains "long-running operations", which return a
    // an Operation object that allows for tracking of the operation,
    // rather than holding a request open.
    const protoFilesRoot = opts.fallback
      ? this._gaxModule.protobuf.Root.fromJSON(
          // eslint-disable-next-line @typescript-eslint/no-var-requires
          require('../../protos/protos.json')
        )
      : this._gaxModule.protobuf.loadSync(nodejsProtoPath);

    this.operationsClient = this._gaxModule
      .lro({
        auth: this.auth,
        grpc: 'grpc' in this._gaxGrpc ? this._gaxGrpc.grpc : undefined,
      })
      .operationsClient(opts);
    const createFeaturestoreResponse = protoFilesRoot.lookup(
      '.google.cloud.aiplatform.v1beta1.Featurestore'
    ) as gax.protobuf.Type;
    const createFeaturestoreMetadata = protoFilesRoot.lookup(
      '.google.cloud.aiplatform.v1beta1.CreateFeaturestoreOperationMetadata'
    ) as gax.protobuf.Type;
    const updateFeaturestoreResponse = protoFilesRoot.lookup(
      '.google.cloud.aiplatform.v1beta1.Featurestore'
    ) as gax.protobuf.Type;
    const updateFeaturestoreMetadata = protoFilesRoot.lookup(
      '.google.cloud.aiplatform.v1beta1.UpdateFeaturestoreOperationMetadata'
    ) as gax.protobuf.Type;
    const deleteFeaturestoreResponse = protoFilesRoot.lookup(
      '.google.protobuf.Empty'
    ) as gax.protobuf.Type;
    const deleteFeaturestoreMetadata = protoFilesRoot.lookup(
      '.google.cloud.aiplatform.v1beta1.DeleteOperationMetadata'
    ) as gax.protobuf.Type;
    const createEntityTypeResponse = protoFilesRoot.lookup(
      '.google.cloud.aiplatform.v1beta1.EntityType'
    ) as gax.protobuf.Type;
    const createEntityTypeMetadata = protoFilesRoot.lookup(
      '.google.cloud.aiplatform.v1beta1.CreateEntityTypeOperationMetadata'
    ) as gax.protobuf.Type;
    const deleteEntityTypeResponse = protoFilesRoot.lookup(
      '.google.protobuf.Empty'
    ) as gax.protobuf.Type;
    const deleteEntityTypeMetadata = protoFilesRoot.lookup(
      '.google.cloud.aiplatform.v1beta1.DeleteOperationMetadata'
    ) as gax.protobuf.Type;
    const createFeatureResponse = protoFilesRoot.lookup(
      '.google.cloud.aiplatform.v1beta1.Feature'
    ) as gax.protobuf.Type;
    const createFeatureMetadata = protoFilesRoot.lookup(
      '.google.cloud.aiplatform.v1beta1.CreateFeatureOperationMetadata'
    ) as gax.protobuf.Type;
    const batchCreateFeaturesResponse = protoFilesRoot.lookup(
      '.google.cloud.aiplatform.v1beta1.BatchCreateFeaturesResponse'
    ) as gax.protobuf.Type;
    const batchCreateFeaturesMetadata = protoFilesRoot.lookup(
      '.google.cloud.aiplatform.v1beta1.BatchCreateFeaturesOperationMetadata'
    ) as gax.protobuf.Type;
    const deleteFeatureResponse = protoFilesRoot.lookup(
      '.google.protobuf.Empty'
    ) as gax.protobuf.Type;
    const deleteFeatureMetadata = protoFilesRoot.lookup(
      '.google.cloud.aiplatform.v1beta1.DeleteOperationMetadata'
    ) as gax.protobuf.Type;
    const importFeatureValuesResponse = protoFilesRoot.lookup(
      '.google.cloud.aiplatform.v1beta1.ImportFeatureValuesResponse'
    ) as gax.protobuf.Type;
    const importFeatureValuesMetadata = protoFilesRoot.lookup(
      '.google.cloud.aiplatform.v1beta1.ImportFeatureValuesOperationMetadata'
    ) as gax.protobuf.Type;
    const batchReadFeatureValuesResponse = protoFilesRoot.lookup(
      '.google.cloud.aiplatform.v1beta1.BatchReadFeatureValuesResponse'
    ) as gax.protobuf.Type;
    const batchReadFeatureValuesMetadata = protoFilesRoot.lookup(
      '.google.cloud.aiplatform.v1beta1.BatchReadFeatureValuesOperationMetadata'
    ) as gax.protobuf.Type;
    const exportFeatureValuesResponse = protoFilesRoot.lookup(
      '.google.cloud.aiplatform.v1beta1.ExportFeatureValuesResponse'
    ) as gax.protobuf.Type;
    const exportFeatureValuesMetadata = protoFilesRoot.lookup(
      '.google.cloud.aiplatform.v1beta1.ExportFeatureValuesOperationMetadata'
    ) as gax.protobuf.Type;

    this.descriptors.longrunning = {
      createFeaturestore: new this._gaxModule.LongrunningDescriptor(
        this.operationsClient,
        createFeaturestoreResponse.decode.bind(createFeaturestoreResponse),
        createFeaturestoreMetadata.decode.bind(createFeaturestoreMetadata)
      ),
      updateFeaturestore: new this._gaxModule.LongrunningDescriptor(
        this.operationsClient,
        updateFeaturestoreResponse.decode.bind(updateFeaturestoreResponse),
        updateFeaturestoreMetadata.decode.bind(updateFeaturestoreMetadata)
      ),
      deleteFeaturestore: new this._gaxModule.LongrunningDescriptor(
        this.operationsClient,
        deleteFeaturestoreResponse.decode.bind(deleteFeaturestoreResponse),
        deleteFeaturestoreMetadata.decode.bind(deleteFeaturestoreMetadata)
      ),
      createEntityType: new this._gaxModule.LongrunningDescriptor(
        this.operationsClient,
        createEntityTypeResponse.decode.bind(createEntityTypeResponse),
        createEntityTypeMetadata.decode.bind(createEntityTypeMetadata)
      ),
      deleteEntityType: new this._gaxModule.LongrunningDescriptor(
        this.operationsClient,
        deleteEntityTypeResponse.decode.bind(deleteEntityTypeResponse),
        deleteEntityTypeMetadata.decode.bind(deleteEntityTypeMetadata)
      ),
      createFeature: new this._gaxModule.LongrunningDescriptor(
        this.operationsClient,
        createFeatureResponse.decode.bind(createFeatureResponse),
        createFeatureMetadata.decode.bind(createFeatureMetadata)
      ),
      batchCreateFeatures: new this._gaxModule.LongrunningDescriptor(
        this.operationsClient,
        batchCreateFeaturesResponse.decode.bind(batchCreateFeaturesResponse),
        batchCreateFeaturesMetadata.decode.bind(batchCreateFeaturesMetadata)
      ),
      deleteFeature: new this._gaxModule.LongrunningDescriptor(
        this.operationsClient,
        deleteFeatureResponse.decode.bind(deleteFeatureResponse),
        deleteFeatureMetadata.decode.bind(deleteFeatureMetadata)
      ),
      importFeatureValues: new this._gaxModule.LongrunningDescriptor(
        this.operationsClient,
        importFeatureValuesResponse.decode.bind(importFeatureValuesResponse),
        importFeatureValuesMetadata.decode.bind(importFeatureValuesMetadata)
      ),
      batchReadFeatureValues: new this._gaxModule.LongrunningDescriptor(
        this.operationsClient,
        batchReadFeatureValuesResponse.decode.bind(
          batchReadFeatureValuesResponse
        ),
        batchReadFeatureValuesMetadata.decode.bind(
          batchReadFeatureValuesMetadata
        )
      ),
      exportFeatureValues: new this._gaxModule.LongrunningDescriptor(
        this.operationsClient,
        exportFeatureValuesResponse.decode.bind(exportFeatureValuesResponse),
        exportFeatureValuesMetadata.decode.bind(exportFeatureValuesMetadata)
      ),
    };

    // Put together the default options sent with requests.
    this._defaults = this._gaxGrpc.constructSettings(
      'google.cloud.aiplatform.v1beta1.FeaturestoreService',
      gapicConfig as gax.ClientConfig,
      opts.clientConfig || {},
      {'x-goog-api-client': clientHeader.join(' ')}
    );

    // Set up a dictionary of "inner API calls"; the core implementation
    // of calling the API is handled in `google-gax`, with this code
    // merely providing the destination and request information.
    this.innerApiCalls = {};
  }

  /**
   * Initialize the client.
   * Performs asynchronous operations (such as authentication) and prepares the client.
   * This function will be called automatically when any class method is called for the
   * first time, but if you need to initialize it before calling an actual method,
   * feel free to call initialize() directly.
   *
   * You can await on this method if you want to make sure the client is initialized.
   *
   * @returns {Promise} A promise that resolves to an authenticated service stub.
   */
  initialize() {
    // If the client stub promise is already initialized, return immediately.
    if (this.featurestoreServiceStub) {
      return this.featurestoreServiceStub;
    }

    // Put together the "service stub" for
    // google.cloud.aiplatform.v1beta1.FeaturestoreService.
    this.featurestoreServiceStub = this._gaxGrpc.createStub(
      this._opts.fallback
        ? (this._protos as protobuf.Root).lookupService(
            'google.cloud.aiplatform.v1beta1.FeaturestoreService'
          )
        : // eslint-disable-next-line @typescript-eslint/no-explicit-any
          (this._protos as any).google.cloud.aiplatform.v1beta1
            .FeaturestoreService,
      this._opts
    ) as Promise<{[method: string]: Function}>;

    // Iterate over each of the methods that the service provides
    // and create an API call method for each.
    const featurestoreServiceStubMethods = [
      'createFeaturestore',
      'getFeaturestore',
      'listFeaturestores',
      'updateFeaturestore',
      'deleteFeaturestore',
      'createEntityType',
      'getEntityType',
      'listEntityTypes',
      'updateEntityType',
      'deleteEntityType',
      'createFeature',
      'batchCreateFeatures',
      'getFeature',
      'listFeatures',
      'updateFeature',
      'deleteFeature',
      'importFeatureValues',
      'batchReadFeatureValues',
      'exportFeatureValues',
      'searchFeatures',
    ];
    for (const methodName of featurestoreServiceStubMethods) {
      const callPromise = this.featurestoreServiceStub.then(
        stub =>
          (...args: Array<{}>) => {
            if (this._terminated) {
              return Promise.reject('The client has already been closed.');
            }
            const func = stub[methodName];
            return func.apply(stub, args);
          },
        (err: Error | null | undefined) => () => {
          throw err;
        }
      );

      const descriptor =
        this.descriptors.page[methodName] ||
        this.descriptors.longrunning[methodName] ||
        undefined;
      const apiCall = this._gaxModule.createApiCall(
        callPromise,
        this._defaults[methodName],
        descriptor
      );

      this.innerApiCalls[methodName] = apiCall;
    }

    return this.featurestoreServiceStub;
  }

  /**
   * The DNS address for this API service.
   * @returns {string} The DNS address for this service.
   */
  static get servicePath() {
    return 'aiplatform.googleapis.com';
  }

  /**
   * The DNS address for this API service - same as servicePath(),
   * exists for compatibility reasons.
   * @returns {string} The DNS address for this service.
   */
  static get apiEndpoint() {
    return 'aiplatform.googleapis.com';
  }

  /**
   * The port for this API service.
   * @returns {number} The default port for this service.
   */
  static get port() {
    return 443;
  }

  /**
   * The scopes needed to make gRPC calls for every method defined
   * in this service.
   * @returns {string[]} List of default scopes.
   */
  static get scopes() {
    return ['https://www.googleapis.com/auth/cloud-platform'];
  }

  getProjectId(): Promise<string>;
  getProjectId(callback: Callback<string, undefined, undefined>): void;
  /**
   * Return the project ID used by this class.
   * @returns {Promise} A promise that resolves to string containing the project ID.
   */
  getProjectId(
    callback?: Callback<string, undefined, undefined>
  ): Promise<string> | void {
    if (callback) {
      this.auth.getProjectId(callback);
      return;
    }
    return this.auth.getProjectId();
  }

  // -------------------
  // -- Service calls --
  // -------------------
  getFeaturestore(
    request: protos.google.cloud.aiplatform.v1beta1.IGetFeaturestoreRequest,
    options?: CallOptions
  ): Promise<
    [
      protos.google.cloud.aiplatform.v1beta1.IFeaturestore,
      (
        | protos.google.cloud.aiplatform.v1beta1.IGetFeaturestoreRequest
        | undefined
      ),
      {} | undefined
    ]
  >;
  getFeaturestore(
    request: protos.google.cloud.aiplatform.v1beta1.IGetFeaturestoreRequest,
    options: CallOptions,
    callback: Callback<
      protos.google.cloud.aiplatform.v1beta1.IFeaturestore,
      | protos.google.cloud.aiplatform.v1beta1.IGetFeaturestoreRequest
      | null
      | undefined,
      {} | null | undefined
    >
  ): void;
  getFeaturestore(
    request: protos.google.cloud.aiplatform.v1beta1.IGetFeaturestoreRequest,
    callback: Callback<
      protos.google.cloud.aiplatform.v1beta1.IFeaturestore,
      | protos.google.cloud.aiplatform.v1beta1.IGetFeaturestoreRequest
      | null
      | undefined,
      {} | null | undefined
    >
  ): void;
  /**
   * Gets details of a single Featurestore.
   *
   * @param {Object} request
   *   The request object that will be sent.
   * @param {string} request.name
   *   Required. The name of the Featurestore resource.
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
   * @returns {Promise} - The promise which resolves to an array.
   *   The first element of the array is an object representing [Featurestore]{@link google.cloud.aiplatform.v1beta1.Featurestore}.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods)
   *   for more details and examples.
   * @example
   * const [response] = await client.getFeaturestore(request);
   */
  getFeaturestore(
    request: protos.google.cloud.aiplatform.v1beta1.IGetFeaturestoreRequest,
    optionsOrCallback?:
      | CallOptions
      | Callback<
          protos.google.cloud.aiplatform.v1beta1.IFeaturestore,
          | protos.google.cloud.aiplatform.v1beta1.IGetFeaturestoreRequest
          | null
          | undefined,
          {} | null | undefined
        >,
    callback?: Callback<
      protos.google.cloud.aiplatform.v1beta1.IFeaturestore,
      | protos.google.cloud.aiplatform.v1beta1.IGetFeaturestoreRequest
      | null
      | undefined,
      {} | null | undefined
    >
  ): Promise<
    [
      protos.google.cloud.aiplatform.v1beta1.IFeaturestore,
      (
        | protos.google.cloud.aiplatform.v1beta1.IGetFeaturestoreRequest
        | undefined
      ),
      {} | undefined
    ]
  > | void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    } else {
      options = optionsOrCallback as CallOptions;
    }
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers['x-goog-request-params'] =
      gax.routingHeader.fromParams({
        name: request.name || '',
      });
    this.initialize();
    return this.innerApiCalls.getFeaturestore(request, options, callback);
  }
  getEntityType(
    request: protos.google.cloud.aiplatform.v1beta1.IGetEntityTypeRequest,
    options?: CallOptions
  ): Promise<
    [
      protos.google.cloud.aiplatform.v1beta1.IEntityType,
      protos.google.cloud.aiplatform.v1beta1.IGetEntityTypeRequest | undefined,
      {} | undefined
    ]
  >;
  getEntityType(
    request: protos.google.cloud.aiplatform.v1beta1.IGetEntityTypeRequest,
    options: CallOptions,
    callback: Callback<
      protos.google.cloud.aiplatform.v1beta1.IEntityType,
      | protos.google.cloud.aiplatform.v1beta1.IGetEntityTypeRequest
      | null
      | undefined,
      {} | null | undefined
    >
  ): void;
  getEntityType(
    request: protos.google.cloud.aiplatform.v1beta1.IGetEntityTypeRequest,
    callback: Callback<
      protos.google.cloud.aiplatform.v1beta1.IEntityType,
      | protos.google.cloud.aiplatform.v1beta1.IGetEntityTypeRequest
      | null
      | undefined,
      {} | null | undefined
    >
  ): void;
  /**
   * Gets details of a single EntityType.
   *
   * @param {Object} request
   *   The request object that will be sent.
   * @param {string} request.name
   *   Required. The name of the EntityType resource.
   *   Format:
   *   `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
   * @returns {Promise} - The promise which resolves to an array.
   *   The first element of the array is an object representing [EntityType]{@link google.cloud.aiplatform.v1beta1.EntityType}.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods)
   *   for more details and examples.
   * @example
   * const [response] = await client.getEntityType(request);
   */
  getEntityType(
    request: protos.google.cloud.aiplatform.v1beta1.IGetEntityTypeRequest,
    optionsOrCallback?:
      | CallOptions
      | Callback<
          protos.google.cloud.aiplatform.v1beta1.IEntityType,
          | protos.google.cloud.aiplatform.v1beta1.IGetEntityTypeRequest
          | null
          | undefined,
          {} | null | undefined
        >,
    callback?: Callback<
      protos.google.cloud.aiplatform.v1beta1.IEntityType,
      | protos.google.cloud.aiplatform.v1beta1.IGetEntityTypeRequest
      | null
      | undefined,
      {} | null | undefined
    >
  ): Promise<
    [
      protos.google.cloud.aiplatform.v1beta1.IEntityType,
      protos.google.cloud.aiplatform.v1beta1.IGetEntityTypeRequest | undefined,
      {} | undefined
    ]
  > | void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    } else {
      options = optionsOrCallback as CallOptions;
    }
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers['x-goog-request-params'] =
      gax.routingHeader.fromParams({
        name: request.name || '',
      });
    this.initialize();
    return this.innerApiCalls.getEntityType(request, options, callback);
  }
  updateEntityType(
    request: protos.google.cloud.aiplatform.v1beta1.IUpdateEntityTypeRequest,
    options?: CallOptions
  ): Promise<
    [
      protos.google.cloud.aiplatform.v1beta1.IEntityType,
      (
        | protos.google.cloud.aiplatform.v1beta1.IUpdateEntityTypeRequest
        | undefined
      ),
      {} | undefined
    ]
  >;
  updateEntityType(
    request: protos.google.cloud.aiplatform.v1beta1.IUpdateEntityTypeRequest,
    options: CallOptions,
    callback: Callback<
      protos.google.cloud.aiplatform.v1beta1.IEntityType,
      | protos.google.cloud.aiplatform.v1beta1.IUpdateEntityTypeRequest
      | null
      | undefined,
      {} | null | undefined
    >
  ): void;
  updateEntityType(
    request: protos.google.cloud.aiplatform.v1beta1.IUpdateEntityTypeRequest,
    callback: Callback<
      protos.google.cloud.aiplatform.v1beta1.IEntityType,
      | protos.google.cloud.aiplatform.v1beta1.IUpdateEntityTypeRequest
      | null
      | undefined,
      {} | null | undefined
    >
  ): void;
  /**
   * Updates the parameters of a single EntityType.
   *
   * @param {Object} request
   *   The request object that will be sent.
   * @param {google.cloud.aiplatform.v1beta1.EntityType} request.entityType
   *   Required. The EntityType's `name` field is used to identify the EntityType to be
   *   updated.
   *   Format:
   *   `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
   * @param {google.protobuf.FieldMask} request.updateMask
   *   Field mask is used to specify the fields to be overwritten in the
   *   EntityType resource by the update.
   *   The fields specified in the update_mask are relative to the resource, not
   *   the full request. A field will be overwritten if it is in the mask. If the
   *   user does not provide a mask then only the non-empty fields present in the
   *   request will be overwritten. Set the update_mask to `*` to override all
   *   fields.
   *
   *   Updatable fields:
   *
   *     * `description`
   *     * `labels`
   *     * `monitoring_config.snapshot_analysis.disabled`
   *     * `monitoring_config.snapshot_analysis.monitoring_interval`
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
   * @returns {Promise} - The promise which resolves to an array.
   *   The first element of the array is an object representing [EntityType]{@link google.cloud.aiplatform.v1beta1.EntityType}.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods)
   *   for more details and examples.
   * @example
   * const [response] = await client.updateEntityType(request);
   */
  updateEntityType(
    request: protos.google.cloud.aiplatform.v1beta1.IUpdateEntityTypeRequest,
    optionsOrCallback?:
      | CallOptions
      | Callback<
          protos.google.cloud.aiplatform.v1beta1.IEntityType,
          | protos.google.cloud.aiplatform.v1beta1.IUpdateEntityTypeRequest
          | null
          | undefined,
          {} | null | undefined
        >,
    callback?: Callback<
      protos.google.cloud.aiplatform.v1beta1.IEntityType,
      | protos.google.cloud.aiplatform.v1beta1.IUpdateEntityTypeRequest
      | null
      | undefined,
      {} | null | undefined
    >
  ): Promise<
    [
      protos.google.cloud.aiplatform.v1beta1.IEntityType,
      (
        | protos.google.cloud.aiplatform.v1beta1.IUpdateEntityTypeRequest
        | undefined
      ),
      {} | undefined
    ]
  > | void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    } else {
      options = optionsOrCallback as CallOptions;
    }
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers['x-goog-request-params'] =
      gax.routingHeader.fromParams({
        'entity_type.name': request.entityType!.name || '',
      });
    this.initialize();
    return this.innerApiCalls.updateEntityType(request, options, callback);
  }
  getFeature(
    request: protos.google.cloud.aiplatform.v1beta1.IGetFeatureRequest,
    options?: CallOptions
  ): Promise<
    [
      protos.google.cloud.aiplatform.v1beta1.IFeature,
      protos.google.cloud.aiplatform.v1beta1.IGetFeatureRequest | undefined,
      {} | undefined
    ]
  >;
  getFeature(
    request: protos.google.cloud.aiplatform.v1beta1.IGetFeatureRequest,
    options: CallOptions,
    callback: Callback<
      protos.google.cloud.aiplatform.v1beta1.IFeature,
      | protos.google.cloud.aiplatform.v1beta1.IGetFeatureRequest
      | null
      | undefined,
      {} | null | undefined
    >
  ): void;
  getFeature(
    request: protos.google.cloud.aiplatform.v1beta1.IGetFeatureRequest,
    callback: Callback<
      protos.google.cloud.aiplatform.v1beta1.IFeature,
      | protos.google.cloud.aiplatform.v1beta1.IGetFeatureRequest
      | null
      | undefined,
      {} | null | undefined
    >
  ): void;
  /**
   * Gets details of a single Feature.
   *
   * @param {Object} request
   *   The request object that will be sent.
   * @param {string} request.name
   *   Required. The name of the Feature resource.
   *   Format:
   *   `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
   * @returns {Promise} - The promise which resolves to an array.
   *   The first element of the array is an object representing [Feature]{@link google.cloud.aiplatform.v1beta1.Feature}.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods)
   *   for more details and examples.
   * @example
   * const [response] = await client.getFeature(request);
   */
  getFeature(
    request: protos.google.cloud.aiplatform.v1beta1.IGetFeatureRequest,
    optionsOrCallback?:
      | CallOptions
      | Callback<
          protos.google.cloud.aiplatform.v1beta1.IFeature,
          | protos.google.cloud.aiplatform.v1beta1.IGetFeatureRequest
          | null
          | undefined,
          {} | null | undefined
        >,
    callback?: Callback<
      protos.google.cloud.aiplatform.v1beta1.IFeature,
      | protos.google.cloud.aiplatform.v1beta1.IGetFeatureRequest
      | null
      | undefined,
      {} | null | undefined
    >
  ): Promise<
    [
      protos.google.cloud.aiplatform.v1beta1.IFeature,
      protos.google.cloud.aiplatform.v1beta1.IGetFeatureRequest | undefined,
      {} | undefined
    ]
  > | void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    } else {
      options = optionsOrCallback as CallOptions;
    }
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers['x-goog-request-params'] =
      gax.routingHeader.fromParams({
        name: request.name || '',
      });
    this.initialize();
    return this.innerApiCalls.getFeature(request, options, callback);
  }
  updateFeature(
    request: protos.google.cloud.aiplatform.v1beta1.IUpdateFeatureRequest,
    options?: CallOptions
  ): Promise<
    [
      protos.google.cloud.aiplatform.v1beta1.IFeature,
      protos.google.cloud.aiplatform.v1beta1.IUpdateFeatureRequest | undefined,
      {} | undefined
    ]
  >;
  updateFeature(
    request: protos.google.cloud.aiplatform.v1beta1.IUpdateFeatureRequest,
    options: CallOptions,
    callback: Callback<
      protos.google.cloud.aiplatform.v1beta1.IFeature,
      | protos.google.cloud.aiplatform.v1beta1.IUpdateFeatureRequest
      | null
      | undefined,
      {} | null | undefined
    >
  ): void;
  updateFeature(
    request: protos.google.cloud.aiplatform.v1beta1.IUpdateFeatureRequest,
    callback: Callback<
      protos.google.cloud.aiplatform.v1beta1.IFeature,
      | protos.google.cloud.aiplatform.v1beta1.IUpdateFeatureRequest
      | null
      | undefined,
      {} | null | undefined
    >
  ): void;
  /**
   * Updates the parameters of a single Feature.
   *
   * @param {Object} request
   *   The request object that will be sent.
   * @param {google.cloud.aiplatform.v1beta1.Feature} request.feature
   *   Required. The Feature's `name` field is used to identify the Feature to be
   *   updated.
   *   Format:
   *   `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}/features/{feature}`
   * @param {google.protobuf.FieldMask} request.updateMask
   *   Field mask is used to specify the fields to be overwritten in the
   *   Features resource by the update.
   *   The fields specified in the update_mask are relative to the resource, not
   *   the full request. A field will be overwritten if it is in the mask. If the
   *   user does not provide a mask then only the non-empty fields present in the
   *   request will be overwritten. Set the update_mask to `*` to override all
   *   fields.
   *
   *   Updatable fields:
   *
   *     * `description`
   *     * `labels`
   *     * `monitoring_config.snapshot_analysis.disabled`
   *     * `monitoring_config.snapshot_analysis.monitoring_interval`
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
   * @returns {Promise} - The promise which resolves to an array.
   *   The first element of the array is an object representing [Feature]{@link google.cloud.aiplatform.v1beta1.Feature}.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#regular-methods)
   *   for more details and examples.
   * @example
   * const [response] = await client.updateFeature(request);
   */
  updateFeature(
    request: protos.google.cloud.aiplatform.v1beta1.IUpdateFeatureRequest,
    optionsOrCallback?:
      | CallOptions
      | Callback<
          protos.google.cloud.aiplatform.v1beta1.IFeature,
          | protos.google.cloud.aiplatform.v1beta1.IUpdateFeatureRequest
          | null
          | undefined,
          {} | null | undefined
        >,
    callback?: Callback<
      protos.google.cloud.aiplatform.v1beta1.IFeature,
      | protos.google.cloud.aiplatform.v1beta1.IUpdateFeatureRequest
      | null
      | undefined,
      {} | null | undefined
    >
  ): Promise<
    [
      protos.google.cloud.aiplatform.v1beta1.IFeature,
      protos.google.cloud.aiplatform.v1beta1.IUpdateFeatureRequest | undefined,
      {} | undefined
    ]
  > | void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    } else {
      options = optionsOrCallback as CallOptions;
    }
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers['x-goog-request-params'] =
      gax.routingHeader.fromParams({
        'feature.name': request.feature!.name || '',
      });
    this.initialize();
    return this.innerApiCalls.updateFeature(request, options, callback);
  }

  createFeaturestore(
    request: protos.google.cloud.aiplatform.v1beta1.ICreateFeaturestoreRequest,
    options?: CallOptions
  ): Promise<
    [
      LROperation<
        protos.google.cloud.aiplatform.v1beta1.IFeaturestore,
        protos.google.cloud.aiplatform.v1beta1.ICreateFeaturestoreOperationMetadata
      >,
      protos.google.longrunning.IOperation | undefined,
      {} | undefined
    ]
  >;
  createFeaturestore(
    request: protos.google.cloud.aiplatform.v1beta1.ICreateFeaturestoreRequest,
    options: CallOptions,
    callback: Callback<
      LROperation<
        protos.google.cloud.aiplatform.v1beta1.IFeaturestore,
        protos.google.cloud.aiplatform.v1beta1.ICreateFeaturestoreOperationMetadata
      >,
      protos.google.longrunning.IOperation | null | undefined,
      {} | null | undefined
    >
  ): void;
  createFeaturestore(
    request: protos.google.cloud.aiplatform.v1beta1.ICreateFeaturestoreRequest,
    callback: Callback<
      LROperation<
        protos.google.cloud.aiplatform.v1beta1.IFeaturestore,
        protos.google.cloud.aiplatform.v1beta1.ICreateFeaturestoreOperationMetadata
      >,
      protos.google.longrunning.IOperation | null | undefined,
      {} | null | undefined
    >
  ): void;
  /**
   * Creates a new Featurestore in a given project and location.
   *
   * @param {Object} request
   *   The request object that will be sent.
   * @param {string} request.parent
   *   Required. The resource name of the Location to create Featurestores.
   *   Format:
   *   `projects/{project}/locations/{location}'`
   * @param {google.cloud.aiplatform.v1beta1.Featurestore} request.featurestore
   *   Required. The Featurestore to create.
   * @param {string} request.featurestoreId
   *   Required. The ID to use for this Featurestore, which will become the final component
   *   of the Featurestore's resource name.
   *
   *   This value may be up to 60 characters, and valid characters are
   *   `[a-z0-9_]`. The first character cannot be a number.
   *
   *   The value must be unique within the project and location.
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
   * @returns {Promise} - The promise which resolves to an array.
   *   The first element of the array is an object representing
   *   a long running operation. Its `promise()` method returns a promise
   *   you can `await` for.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#long-running-operations)
   *   for more details and examples.
   * @example
   * const [operation] = await client.createFeaturestore(request);
   * const [response] = await operation.promise();
   */
  createFeaturestore(
    request: protos.google.cloud.aiplatform.v1beta1.ICreateFeaturestoreRequest,
    optionsOrCallback?:
      | CallOptions
      | Callback<
          LROperation<
            protos.google.cloud.aiplatform.v1beta1.IFeaturestore,
            protos.google.cloud.aiplatform.v1beta1.ICreateFeaturestoreOperationMetadata
          >,
          protos.google.longrunning.IOperation | null | undefined,
          {} | null | undefined
        >,
    callback?: Callback<
      LROperation<
        protos.google.cloud.aiplatform.v1beta1.IFeaturestore,
        protos.google.cloud.aiplatform.v1beta1.ICreateFeaturestoreOperationMetadata
      >,
      protos.google.longrunning.IOperation | null | undefined,
      {} | null | undefined
    >
  ): Promise<
    [
      LROperation<
        protos.google.cloud.aiplatform.v1beta1.IFeaturestore,
        protos.google.cloud.aiplatform.v1beta1.ICreateFeaturestoreOperationMetadata
      >,
      protos.google.longrunning.IOperation | undefined,
      {} | undefined
    ]
  > | void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    } else {
      options = optionsOrCallback as CallOptions;
    }
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers['x-goog-request-params'] =
      gax.routingHeader.fromParams({
        parent: request.parent || '',
      });
    this.initialize();
    return this.innerApiCalls.createFeaturestore(request, options, callback);
  }
  /**
   * Check the status of the long running operation returned by `createFeaturestore()`.
   * @param {String} name
   *   The operation name that will be passed.
   * @returns {Promise} - The promise which resolves to an object.
   *   The decoded operation object has result and metadata field to get information from.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#long-running-operations)
   *   for more details and examples.
   * @example
   * const decodedOperation = await checkCreateFeaturestoreProgress(name);
   * console.log(decodedOperation.result);
   * console.log(decodedOperation.done);
   * console.log(decodedOperation.metadata);
   */
  async checkCreateFeaturestoreProgress(
    name: string
  ): Promise<
    LROperation<
      protos.google.cloud.aiplatform.v1beta1.Featurestore,
      protos.google.cloud.aiplatform.v1beta1.CreateFeaturestoreOperationMetadata
    >
  > {
    const request = new operationsProtos.google.longrunning.GetOperationRequest(
      {name}
    );
    const [operation] = await this.operationsClient.getOperation(request);
    const decodeOperation = new gax.Operation(
      operation,
      this.descriptors.longrunning.createFeaturestore,
      gax.createDefaultBackoffSettings()
    );
    return decodeOperation as LROperation<
      protos.google.cloud.aiplatform.v1beta1.Featurestore,
      protos.google.cloud.aiplatform.v1beta1.CreateFeaturestoreOperationMetadata
    >;
  }
  updateFeaturestore(
    request: protos.google.cloud.aiplatform.v1beta1.IUpdateFeaturestoreRequest,
    options?: CallOptions
  ): Promise<
    [
      LROperation<
        protos.google.cloud.aiplatform.v1beta1.IFeaturestore,
        protos.google.cloud.aiplatform.v1beta1.IUpdateFeaturestoreOperationMetadata
      >,
      protos.google.longrunning.IOperation | undefined,
      {} | undefined
    ]
  >;
  updateFeaturestore(
    request: protos.google.cloud.aiplatform.v1beta1.IUpdateFeaturestoreRequest,
    options: CallOptions,
    callback: Callback<
      LROperation<
        protos.google.cloud.aiplatform.v1beta1.IFeaturestore,
        protos.google.cloud.aiplatform.v1beta1.IUpdateFeaturestoreOperationMetadata
      >,
      protos.google.longrunning.IOperation | null | undefined,
      {} | null | undefined
    >
  ): void;
  updateFeaturestore(
    request: protos.google.cloud.aiplatform.v1beta1.IUpdateFeaturestoreRequest,
    callback: Callback<
      LROperation<
        protos.google.cloud.aiplatform.v1beta1.IFeaturestore,
        protos.google.cloud.aiplatform.v1beta1.IUpdateFeaturestoreOperationMetadata
      >,
      protos.google.longrunning.IOperation | null | undefined,
      {} | null | undefined
    >
  ): void;
  /**
   * Updates the parameters of a single Featurestore.
   *
   * @param {Object} request
   *   The request object that will be sent.
   * @param {google.cloud.aiplatform.v1beta1.Featurestore} request.featurestore
   *   Required. The Featurestore's `name` field is used to identify the Featurestore to be
   *   updated.
   *   Format:
   *   `projects/{project}/locations/{location}/featurestores/{featurestore}`
   * @param {google.protobuf.FieldMask} request.updateMask
   *   Field mask is used to specify the fields to be overwritten in the
   *   Featurestore resource by the update.
   *   The fields specified in the update_mask are relative to the resource, not
   *   the full request. A field will be overwritten if it is in the mask. If the
   *   user does not provide a mask then only the non-empty fields present in the
   *   request will be overwritten. Set the update_mask to `*` to override all
   *   fields.
   *
   *   Updatable fields:
   *
   *     * `display_name`
   *     * `labels`
   *     * `online_serving_config.fixed_node_count`
   *     * `online_serving_config.max_online_serving_size`
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
   * @returns {Promise} - The promise which resolves to an array.
   *   The first element of the array is an object representing
   *   a long running operation. Its `promise()` method returns a promise
   *   you can `await` for.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#long-running-operations)
   *   for more details and examples.
   * @example
   * const [operation] = await client.updateFeaturestore(request);
   * const [response] = await operation.promise();
   */
  updateFeaturestore(
    request: protos.google.cloud.aiplatform.v1beta1.IUpdateFeaturestoreRequest,
    optionsOrCallback?:
      | CallOptions
      | Callback<
          LROperation<
            protos.google.cloud.aiplatform.v1beta1.IFeaturestore,
            protos.google.cloud.aiplatform.v1beta1.IUpdateFeaturestoreOperationMetadata
          >,
          protos.google.longrunning.IOperation | null | undefined,
          {} | null | undefined
        >,
    callback?: Callback<
      LROperation<
        protos.google.cloud.aiplatform.v1beta1.IFeaturestore,
        protos.google.cloud.aiplatform.v1beta1.IUpdateFeaturestoreOperationMetadata
      >,
      protos.google.longrunning.IOperation | null | undefined,
      {} | null | undefined
    >
  ): Promise<
    [
      LROperation<
        protos.google.cloud.aiplatform.v1beta1.IFeaturestore,
        protos.google.cloud.aiplatform.v1beta1.IUpdateFeaturestoreOperationMetadata
      >,
      protos.google.longrunning.IOperation | undefined,
      {} | undefined
    ]
  > | void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    } else {
      options = optionsOrCallback as CallOptions;
    }
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers['x-goog-request-params'] =
      gax.routingHeader.fromParams({
        'featurestore.name': request.featurestore!.name || '',
      });
    this.initialize();
    return this.innerApiCalls.updateFeaturestore(request, options, callback);
  }
  /**
   * Check the status of the long running operation returned by `updateFeaturestore()`.
   * @param {String} name
   *   The operation name that will be passed.
   * @returns {Promise} - The promise which resolves to an object.
   *   The decoded operation object has result and metadata field to get information from.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#long-running-operations)
   *   for more details and examples.
   * @example
   * const decodedOperation = await checkUpdateFeaturestoreProgress(name);
   * console.log(decodedOperation.result);
   * console.log(decodedOperation.done);
   * console.log(decodedOperation.metadata);
   */
  async checkUpdateFeaturestoreProgress(
    name: string
  ): Promise<
    LROperation<
      protos.google.cloud.aiplatform.v1beta1.Featurestore,
      protos.google.cloud.aiplatform.v1beta1.UpdateFeaturestoreOperationMetadata
    >
  > {
    const request = new operationsProtos.google.longrunning.GetOperationRequest(
      {name}
    );
    const [operation] = await this.operationsClient.getOperation(request);
    const decodeOperation = new gax.Operation(
      operation,
      this.descriptors.longrunning.updateFeaturestore,
      gax.createDefaultBackoffSettings()
    );
    return decodeOperation as LROperation<
      protos.google.cloud.aiplatform.v1beta1.Featurestore,
      protos.google.cloud.aiplatform.v1beta1.UpdateFeaturestoreOperationMetadata
    >;
  }
  deleteFeaturestore(
    request: protos.google.cloud.aiplatform.v1beta1.IDeleteFeaturestoreRequest,
    options?: CallOptions
  ): Promise<
    [
      LROperation<
        protos.google.protobuf.IEmpty,
        protos.google.cloud.aiplatform.v1beta1.IDeleteOperationMetadata
      >,
      protos.google.longrunning.IOperation | undefined,
      {} | undefined
    ]
  >;
  deleteFeaturestore(
    request: protos.google.cloud.aiplatform.v1beta1.IDeleteFeaturestoreRequest,
    options: CallOptions,
    callback: Callback<
      LROperation<
        protos.google.protobuf.IEmpty,
        protos.google.cloud.aiplatform.v1beta1.IDeleteOperationMetadata
      >,
      protos.google.longrunning.IOperation | null | undefined,
      {} | null | undefined
    >
  ): void;
  deleteFeaturestore(
    request: protos.google.cloud.aiplatform.v1beta1.IDeleteFeaturestoreRequest,
    callback: Callback<
      LROperation<
        protos.google.protobuf.IEmpty,
        protos.google.cloud.aiplatform.v1beta1.IDeleteOperationMetadata
      >,
      protos.google.longrunning.IOperation | null | undefined,
      {} | null | undefined
    >
  ): void;
  /**
   * Deletes a single Featurestore. The Featurestore must not contain any
   * EntityTypes or `force` must be set to true for the request to succeed.
   *
   * @param {Object} request
   *   The request object that will be sent.
   * @param {string} request.name
   *   Required. The name of the Featurestore to be deleted.
   *   Format:
   *   `projects/{project}/locations/{location}/featurestores/{featurestore}`
   * @param {boolean} request.force
   *   If set to true, any EntityTypes and Features for this Featurestore will
   *   also be deleted. (Otherwise, the request will only work if the Featurestore
   *   has no EntityTypes.)
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
   * @returns {Promise} - The promise which resolves to an array.
   *   The first element of the array is an object representing
   *   a long running operation. Its `promise()` method returns a promise
   *   you can `await` for.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#long-running-operations)
   *   for more details and examples.
   * @example
   * const [operation] = await client.deleteFeaturestore(request);
   * const [response] = await operation.promise();
   */
  deleteFeaturestore(
    request: protos.google.cloud.aiplatform.v1beta1.IDeleteFeaturestoreRequest,
    optionsOrCallback?:
      | CallOptions
      | Callback<
          LROperation<
            protos.google.protobuf.IEmpty,
            protos.google.cloud.aiplatform.v1beta1.IDeleteOperationMetadata
          >,
          protos.google.longrunning.IOperation | null | undefined,
          {} | null | undefined
        >,
    callback?: Callback<
      LROperation<
        protos.google.protobuf.IEmpty,
        protos.google.cloud.aiplatform.v1beta1.IDeleteOperationMetadata
      >,
      protos.google.longrunning.IOperation | null | undefined,
      {} | null | undefined
    >
  ): Promise<
    [
      LROperation<
        protos.google.protobuf.IEmpty,
        protos.google.cloud.aiplatform.v1beta1.IDeleteOperationMetadata
      >,
      protos.google.longrunning.IOperation | undefined,
      {} | undefined
    ]
  > | void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    } else {
      options = optionsOrCallback as CallOptions;
    }
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers['x-goog-request-params'] =
      gax.routingHeader.fromParams({
        name: request.name || '',
      });
    this.initialize();
    return this.innerApiCalls.deleteFeaturestore(request, options, callback);
  }
  /**
   * Check the status of the long running operation returned by `deleteFeaturestore()`.
   * @param {String} name
   *   The operation name that will be passed.
   * @returns {Promise} - The promise which resolves to an object.
   *   The decoded operation object has result and metadata field to get information from.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#long-running-operations)
   *   for more details and examples.
   * @example
   * const decodedOperation = await checkDeleteFeaturestoreProgress(name);
   * console.log(decodedOperation.result);
   * console.log(decodedOperation.done);
   * console.log(decodedOperation.metadata);
   */
  async checkDeleteFeaturestoreProgress(
    name: string
  ): Promise<
    LROperation<
      protos.google.protobuf.Empty,
      protos.google.cloud.aiplatform.v1beta1.DeleteOperationMetadata
    >
  > {
    const request = new operationsProtos.google.longrunning.GetOperationRequest(
      {name}
    );
    const [operation] = await this.operationsClient.getOperation(request);
    const decodeOperation = new gax.Operation(
      operation,
      this.descriptors.longrunning.deleteFeaturestore,
      gax.createDefaultBackoffSettings()
    );
    return decodeOperation as LROperation<
      protos.google.protobuf.Empty,
      protos.google.cloud.aiplatform.v1beta1.DeleteOperationMetadata
    >;
  }
  createEntityType(
    request: protos.google.cloud.aiplatform.v1beta1.ICreateEntityTypeRequest,
    options?: CallOptions
  ): Promise<
    [
      LROperation<
        protos.google.cloud.aiplatform.v1beta1.IEntityType,
        protos.google.cloud.aiplatform.v1beta1.ICreateEntityTypeOperationMetadata
      >,
      protos.google.longrunning.IOperation | undefined,
      {} | undefined
    ]
  >;
  createEntityType(
    request: protos.google.cloud.aiplatform.v1beta1.ICreateEntityTypeRequest,
    options: CallOptions,
    callback: Callback<
      LROperation<
        protos.google.cloud.aiplatform.v1beta1.IEntityType,
        protos.google.cloud.aiplatform.v1beta1.ICreateEntityTypeOperationMetadata
      >,
      protos.google.longrunning.IOperation | null | undefined,
      {} | null | undefined
    >
  ): void;
  createEntityType(
    request: protos.google.cloud.aiplatform.v1beta1.ICreateEntityTypeRequest,
    callback: Callback<
      LROperation<
        protos.google.cloud.aiplatform.v1beta1.IEntityType,
        protos.google.cloud.aiplatform.v1beta1.ICreateEntityTypeOperationMetadata
      >,
      protos.google.longrunning.IOperation | null | undefined,
      {} | null | undefined
    >
  ): void;
  /**
   * Creates a new EntityType in a given Featurestore.
   *
   * @param {Object} request
   *   The request object that will be sent.
   * @param {string} request.parent
   *   Required. The resource name of the Featurestore to create EntityTypes.
   *   Format:
   *   `projects/{project}/locations/{location}/featurestores/{featurestore}`
   * @param {google.cloud.aiplatform.v1beta1.EntityType} request.entityType
   *   The EntityType to create.
   * @param {string} request.entityTypeId
   *   Required. The ID to use for the EntityType, which will become the final component of
   *   the EntityType's resource name.
   *
   *   This value may be up to 60 characters, and valid characters are
   *   `[a-z0-9_]`. The first character cannot be a number.
   *
   *   The value must be unique within a featurestore.
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
   * @returns {Promise} - The promise which resolves to an array.
   *   The first element of the array is an object representing
   *   a long running operation. Its `promise()` method returns a promise
   *   you can `await` for.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#long-running-operations)
   *   for more details and examples.
   * @example
   * const [operation] = await client.createEntityType(request);
   * const [response] = await operation.promise();
   */
  createEntityType(
    request: protos.google.cloud.aiplatform.v1beta1.ICreateEntityTypeRequest,
    optionsOrCallback?:
      | CallOptions
      | Callback<
          LROperation<
            protos.google.cloud.aiplatform.v1beta1.IEntityType,
            protos.google.cloud.aiplatform.v1beta1.ICreateEntityTypeOperationMetadata
          >,
          protos.google.longrunning.IOperation | null | undefined,
          {} | null | undefined
        >,
    callback?: Callback<
      LROperation<
        protos.google.cloud.aiplatform.v1beta1.IEntityType,
        protos.google.cloud.aiplatform.v1beta1.ICreateEntityTypeOperationMetadata
      >,
      protos.google.longrunning.IOperation | null | undefined,
      {} | null | undefined
    >
  ): Promise<
    [
      LROperation<
        protos.google.cloud.aiplatform.v1beta1.IEntityType,
        protos.google.cloud.aiplatform.v1beta1.ICreateEntityTypeOperationMetadata
      >,
      protos.google.longrunning.IOperation | undefined,
      {} | undefined
    ]
  > | void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    } else {
      options = optionsOrCallback as CallOptions;
    }
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers['x-goog-request-params'] =
      gax.routingHeader.fromParams({
        parent: request.parent || '',
      });
    this.initialize();
    return this.innerApiCalls.createEntityType(request, options, callback);
  }
  /**
   * Check the status of the long running operation returned by `createEntityType()`.
   * @param {String} name
   *   The operation name that will be passed.
   * @returns {Promise} - The promise which resolves to an object.
   *   The decoded operation object has result and metadata field to get information from.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#long-running-operations)
   *   for more details and examples.
   * @example
   * const decodedOperation = await checkCreateEntityTypeProgress(name);
   * console.log(decodedOperation.result);
   * console.log(decodedOperation.done);
   * console.log(decodedOperation.metadata);
   */
  async checkCreateEntityTypeProgress(
    name: string
  ): Promise<
    LROperation<
      protos.google.cloud.aiplatform.v1beta1.EntityType,
      protos.google.cloud.aiplatform.v1beta1.CreateEntityTypeOperationMetadata
    >
  > {
    const request = new operationsProtos.google.longrunning.GetOperationRequest(
      {name}
    );
    const [operation] = await this.operationsClient.getOperation(request);
    const decodeOperation = new gax.Operation(
      operation,
      this.descriptors.longrunning.createEntityType,
      gax.createDefaultBackoffSettings()
    );
    return decodeOperation as LROperation<
      protos.google.cloud.aiplatform.v1beta1.EntityType,
      protos.google.cloud.aiplatform.v1beta1.CreateEntityTypeOperationMetadata
    >;
  }
  deleteEntityType(
    request: protos.google.cloud.aiplatform.v1beta1.IDeleteEntityTypeRequest,
    options?: CallOptions
  ): Promise<
    [
      LROperation<
        protos.google.protobuf.IEmpty,
        protos.google.cloud.aiplatform.v1beta1.IDeleteOperationMetadata
      >,
      protos.google.longrunning.IOperation | undefined,
      {} | undefined
    ]
  >;
  deleteEntityType(
    request: protos.google.cloud.aiplatform.v1beta1.IDeleteEntityTypeRequest,
    options: CallOptions,
    callback: Callback<
      LROperation<
        protos.google.protobuf.IEmpty,
        protos.google.cloud.aiplatform.v1beta1.IDeleteOperationMetadata
      >,
      protos.google.longrunning.IOperation | null | undefined,
      {} | null | undefined
    >
  ): void;
  deleteEntityType(
    request: protos.google.cloud.aiplatform.v1beta1.IDeleteEntityTypeRequest,
    callback: Callback<
      LROperation<
        protos.google.protobuf.IEmpty,
        protos.google.cloud.aiplatform.v1beta1.IDeleteOperationMetadata
      >,
      protos.google.longrunning.IOperation | null | undefined,
      {} | null | undefined
    >
  ): void;
  /**
   * Deletes a single EntityType. The EntityType must not have any Features
   * or `force` must be set to true for the request to succeed.
   *
   * @param {Object} request
   *   The request object that will be sent.
   * @param {string} request.name
   *   Required. The name of the EntityType to be deleted.
   *   Format:
   *   `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
   * @param {boolean} request.force
   *   If set to true, any Features for this EntityType will also be deleted.
   *   (Otherwise, the request will only work if the EntityType has no Features.)
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
   * @returns {Promise} - The promise which resolves to an array.
   *   The first element of the array is an object representing
   *   a long running operation. Its `promise()` method returns a promise
   *   you can `await` for.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#long-running-operations)
   *   for more details and examples.
   * @example
   * const [operation] = await client.deleteEntityType(request);
   * const [response] = await operation.promise();
   */
  deleteEntityType(
    request: protos.google.cloud.aiplatform.v1beta1.IDeleteEntityTypeRequest,
    optionsOrCallback?:
      | CallOptions
      | Callback<
          LROperation<
            protos.google.protobuf.IEmpty,
            protos.google.cloud.aiplatform.v1beta1.IDeleteOperationMetadata
          >,
          protos.google.longrunning.IOperation | null | undefined,
          {} | null | undefined
        >,
    callback?: Callback<
      LROperation<
        protos.google.protobuf.IEmpty,
        protos.google.cloud.aiplatform.v1beta1.IDeleteOperationMetadata
      >,
      protos.google.longrunning.IOperation | null | undefined,
      {} | null | undefined
    >
  ): Promise<
    [
      LROperation<
        protos.google.protobuf.IEmpty,
        protos.google.cloud.aiplatform.v1beta1.IDeleteOperationMetadata
      >,
      protos.google.longrunning.IOperation | undefined,
      {} | undefined
    ]
  > | void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    } else {
      options = optionsOrCallback as CallOptions;
    }
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers['x-goog-request-params'] =
      gax.routingHeader.fromParams({
        name: request.name || '',
      });
    this.initialize();
    return this.innerApiCalls.deleteEntityType(request, options, callback);
  }
  /**
   * Check the status of the long running operation returned by `deleteEntityType()`.
   * @param {String} name
   *   The operation name that will be passed.
   * @returns {Promise} - The promise which resolves to an object.
   *   The decoded operation object has result and metadata field to get information from.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#long-running-operations)
   *   for more details and examples.
   * @example
   * const decodedOperation = await checkDeleteEntityTypeProgress(name);
   * console.log(decodedOperation.result);
   * console.log(decodedOperation.done);
   * console.log(decodedOperation.metadata);
   */
  async checkDeleteEntityTypeProgress(
    name: string
  ): Promise<
    LROperation<
      protos.google.protobuf.Empty,
      protos.google.cloud.aiplatform.v1beta1.DeleteOperationMetadata
    >
  > {
    const request = new operationsProtos.google.longrunning.GetOperationRequest(
      {name}
    );
    const [operation] = await this.operationsClient.getOperation(request);
    const decodeOperation = new gax.Operation(
      operation,
      this.descriptors.longrunning.deleteEntityType,
      gax.createDefaultBackoffSettings()
    );
    return decodeOperation as LROperation<
      protos.google.protobuf.Empty,
      protos.google.cloud.aiplatform.v1beta1.DeleteOperationMetadata
    >;
  }
  createFeature(
    request: protos.google.cloud.aiplatform.v1beta1.ICreateFeatureRequest,
    options?: CallOptions
  ): Promise<
    [
      LROperation<
        protos.google.cloud.aiplatform.v1beta1.IFeature,
        protos.google.cloud.aiplatform.v1beta1.ICreateFeatureOperationMetadata
      >,
      protos.google.longrunning.IOperation | undefined,
      {} | undefined
    ]
  >;
  createFeature(
    request: protos.google.cloud.aiplatform.v1beta1.ICreateFeatureRequest,
    options: CallOptions,
    callback: Callback<
      LROperation<
        protos.google.cloud.aiplatform.v1beta1.IFeature,
        protos.google.cloud.aiplatform.v1beta1.ICreateFeatureOperationMetadata
      >,
      protos.google.longrunning.IOperation | null | undefined,
      {} | null | undefined
    >
  ): void;
  createFeature(
    request: protos.google.cloud.aiplatform.v1beta1.ICreateFeatureRequest,
    callback: Callback<
      LROperation<
        protos.google.cloud.aiplatform.v1beta1.IFeature,
        protos.google.cloud.aiplatform.v1beta1.ICreateFeatureOperationMetadata
      >,
      protos.google.longrunning.IOperation | null | undefined,
      {} | null | undefined
    >
  ): void;
  /**
   * Creates a new Feature in a given EntityType.
   *
   * @param {Object} request
   *   The request object that will be sent.
   * @param {string} request.parent
   *   Required. The resource name of the EntityType to create a Feature.
   *   Format:
   *   `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
   * @param {google.cloud.aiplatform.v1beta1.Feature} request.feature
   *   Required. The Feature to create.
   * @param {string} request.featureId
   *   Required. The ID to use for the Feature, which will become the final component of
   *   the Feature's resource name.
   *
   *   This value may be up to 60 characters, and valid characters are
   *   `[a-z0-9_]`. The first character cannot be a number.
   *
   *   The value must be unique within an EntityType.
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
   * @returns {Promise} - The promise which resolves to an array.
   *   The first element of the array is an object representing
   *   a long running operation. Its `promise()` method returns a promise
   *   you can `await` for.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#long-running-operations)
   *   for more details and examples.
   * @example
   * const [operation] = await client.createFeature(request);
   * const [response] = await operation.promise();
   */
  createFeature(
    request: protos.google.cloud.aiplatform.v1beta1.ICreateFeatureRequest,
    optionsOrCallback?:
      | CallOptions
      | Callback<
          LROperation<
            protos.google.cloud.aiplatform.v1beta1.IFeature,
            protos.google.cloud.aiplatform.v1beta1.ICreateFeatureOperationMetadata
          >,
          protos.google.longrunning.IOperation | null | undefined,
          {} | null | undefined
        >,
    callback?: Callback<
      LROperation<
        protos.google.cloud.aiplatform.v1beta1.IFeature,
        protos.google.cloud.aiplatform.v1beta1.ICreateFeatureOperationMetadata
      >,
      protos.google.longrunning.IOperation | null | undefined,
      {} | null | undefined
    >
  ): Promise<
    [
      LROperation<
        protos.google.cloud.aiplatform.v1beta1.IFeature,
        protos.google.cloud.aiplatform.v1beta1.ICreateFeatureOperationMetadata
      >,
      protos.google.longrunning.IOperation | undefined,
      {} | undefined
    ]
  > | void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    } else {
      options = optionsOrCallback as CallOptions;
    }
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers['x-goog-request-params'] =
      gax.routingHeader.fromParams({
        parent: request.parent || '',
      });
    this.initialize();
    return this.innerApiCalls.createFeature(request, options, callback);
  }
  /**
   * Check the status of the long running operation returned by `createFeature()`.
   * @param {String} name
   *   The operation name that will be passed.
   * @returns {Promise} - The promise which resolves to an object.
   *   The decoded operation object has result and metadata field to get information from.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#long-running-operations)
   *   for more details and examples.
   * @example
   * const decodedOperation = await checkCreateFeatureProgress(name);
   * console.log(decodedOperation.result);
   * console.log(decodedOperation.done);
   * console.log(decodedOperation.metadata);
   */
  async checkCreateFeatureProgress(
    name: string
  ): Promise<
    LROperation<
      protos.google.cloud.aiplatform.v1beta1.Feature,
      protos.google.cloud.aiplatform.v1beta1.CreateFeatureOperationMetadata
    >
  > {
    const request = new operationsProtos.google.longrunning.GetOperationRequest(
      {name}
    );
    const [operation] = await this.operationsClient.getOperation(request);
    const decodeOperation = new gax.Operation(
      operation,
      this.descriptors.longrunning.createFeature,
      gax.createDefaultBackoffSettings()
    );
    return decodeOperation as LROperation<
      protos.google.cloud.aiplatform.v1beta1.Feature,
      protos.google.cloud.aiplatform.v1beta1.CreateFeatureOperationMetadata
    >;
  }
  batchCreateFeatures(
    request: protos.google.cloud.aiplatform.v1beta1.IBatchCreateFeaturesRequest,
    options?: CallOptions
  ): Promise<
    [
      LROperation<
        protos.google.cloud.aiplatform.v1beta1.IBatchCreateFeaturesResponse,
        protos.google.cloud.aiplatform.v1beta1.IBatchCreateFeaturesOperationMetadata
      >,
      protos.google.longrunning.IOperation | undefined,
      {} | undefined
    ]
  >;
  batchCreateFeatures(
    request: protos.google.cloud.aiplatform.v1beta1.IBatchCreateFeaturesRequest,
    options: CallOptions,
    callback: Callback<
      LROperation<
        protos.google.cloud.aiplatform.v1beta1.IBatchCreateFeaturesResponse,
        protos.google.cloud.aiplatform.v1beta1.IBatchCreateFeaturesOperationMetadata
      >,
      protos.google.longrunning.IOperation | null | undefined,
      {} | null | undefined
    >
  ): void;
  batchCreateFeatures(
    request: protos.google.cloud.aiplatform.v1beta1.IBatchCreateFeaturesRequest,
    callback: Callback<
      LROperation<
        protos.google.cloud.aiplatform.v1beta1.IBatchCreateFeaturesResponse,
        protos.google.cloud.aiplatform.v1beta1.IBatchCreateFeaturesOperationMetadata
      >,
      protos.google.longrunning.IOperation | null | undefined,
      {} | null | undefined
    >
  ): void;
  /**
   * Creates a batch of Features in a given EntityType.
   *
   * @param {Object} request
   *   The request object that will be sent.
   * @param {string} request.parent
   *   Required. The resource name of the EntityType to create the batch of Features under.
   *   Format:
   *   `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
   * @param {number[]} request.requests
   *   Required. The request message specifying the Features to create. All Features must be
   *   created under the same parent EntityType. The `parent` field in each child
   *   request message can be omitted. If `parent` is set in a child request, then
   *   the value must match the `parent` value in this request message.
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
   * @returns {Promise} - The promise which resolves to an array.
   *   The first element of the array is an object representing
   *   a long running operation. Its `promise()` method returns a promise
   *   you can `await` for.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#long-running-operations)
   *   for more details and examples.
   * @example
   * const [operation] = await client.batchCreateFeatures(request);
   * const [response] = await operation.promise();
   */
  batchCreateFeatures(
    request: protos.google.cloud.aiplatform.v1beta1.IBatchCreateFeaturesRequest,
    optionsOrCallback?:
      | CallOptions
      | Callback<
          LROperation<
            protos.google.cloud.aiplatform.v1beta1.IBatchCreateFeaturesResponse,
            protos.google.cloud.aiplatform.v1beta1.IBatchCreateFeaturesOperationMetadata
          >,
          protos.google.longrunning.IOperation | null | undefined,
          {} | null | undefined
        >,
    callback?: Callback<
      LROperation<
        protos.google.cloud.aiplatform.v1beta1.IBatchCreateFeaturesResponse,
        protos.google.cloud.aiplatform.v1beta1.IBatchCreateFeaturesOperationMetadata
      >,
      protos.google.longrunning.IOperation | null | undefined,
      {} | null | undefined
    >
  ): Promise<
    [
      LROperation<
        protos.google.cloud.aiplatform.v1beta1.IBatchCreateFeaturesResponse,
        protos.google.cloud.aiplatform.v1beta1.IBatchCreateFeaturesOperationMetadata
      >,
      protos.google.longrunning.IOperation | undefined,
      {} | undefined
    ]
  > | void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    } else {
      options = optionsOrCallback as CallOptions;
    }
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers['x-goog-request-params'] =
      gax.routingHeader.fromParams({
        parent: request.parent || '',
      });
    this.initialize();
    return this.innerApiCalls.batchCreateFeatures(request, options, callback);
  }
  /**
   * Check the status of the long running operation returned by `batchCreateFeatures()`.
   * @param {String} name
   *   The operation name that will be passed.
   * @returns {Promise} - The promise which resolves to an object.
   *   The decoded operation object has result and metadata field to get information from.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#long-running-operations)
   *   for more details and examples.
   * @example
   * const decodedOperation = await checkBatchCreateFeaturesProgress(name);
   * console.log(decodedOperation.result);
   * console.log(decodedOperation.done);
   * console.log(decodedOperation.metadata);
   */
  async checkBatchCreateFeaturesProgress(
    name: string
  ): Promise<
    LROperation<
      protos.google.cloud.aiplatform.v1beta1.BatchCreateFeaturesResponse,
      protos.google.cloud.aiplatform.v1beta1.BatchCreateFeaturesOperationMetadata
    >
  > {
    const request = new operationsProtos.google.longrunning.GetOperationRequest(
      {name}
    );
    const [operation] = await this.operationsClient.getOperation(request);
    const decodeOperation = new gax.Operation(
      operation,
      this.descriptors.longrunning.batchCreateFeatures,
      gax.createDefaultBackoffSettings()
    );
    return decodeOperation as LROperation<
      protos.google.cloud.aiplatform.v1beta1.BatchCreateFeaturesResponse,
      protos.google.cloud.aiplatform.v1beta1.BatchCreateFeaturesOperationMetadata
    >;
  }
  deleteFeature(
    request: protos.google.cloud.aiplatform.v1beta1.IDeleteFeatureRequest,
    options?: CallOptions
  ): Promise<
    [
      LROperation<
        protos.google.protobuf.IEmpty,
        protos.google.cloud.aiplatform.v1beta1.IDeleteOperationMetadata
      >,
      protos.google.longrunning.IOperation | undefined,
      {} | undefined
    ]
  >;
  deleteFeature(
    request: protos.google.cloud.aiplatform.v1beta1.IDeleteFeatureRequest,
    options: CallOptions,
    callback: Callback<
      LROperation<
        protos.google.protobuf.IEmpty,
        protos.google.cloud.aiplatform.v1beta1.IDeleteOperationMetadata
      >,
      protos.google.longrunning.IOperation | null | undefined,
      {} | null | undefined
    >
  ): void;
  deleteFeature(
    request: protos.google.cloud.aiplatform.v1beta1.IDeleteFeatureRequest,
    callback: Callback<
      LROperation<
        protos.google.protobuf.IEmpty,
        protos.google.cloud.aiplatform.v1beta1.IDeleteOperationMetadata
      >,
      protos.google.longrunning.IOperation | null | undefined,
      {} | null | undefined
    >
  ): void;
  /**
   * Deletes a single Feature.
   *
   * @param {Object} request
   *   The request object that will be sent.
   * @param {string} request.name
   *   Required. The name of the Features to be deleted.
   *   Format:
   *   `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}/features/{feature}`
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
   * @returns {Promise} - The promise which resolves to an array.
   *   The first element of the array is an object representing
   *   a long running operation. Its `promise()` method returns a promise
   *   you can `await` for.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#long-running-operations)
   *   for more details and examples.
   * @example
   * const [operation] = await client.deleteFeature(request);
   * const [response] = await operation.promise();
   */
  deleteFeature(
    request: protos.google.cloud.aiplatform.v1beta1.IDeleteFeatureRequest,
    optionsOrCallback?:
      | CallOptions
      | Callback<
          LROperation<
            protos.google.protobuf.IEmpty,
            protos.google.cloud.aiplatform.v1beta1.IDeleteOperationMetadata
          >,
          protos.google.longrunning.IOperation | null | undefined,
          {} | null | undefined
        >,
    callback?: Callback<
      LROperation<
        protos.google.protobuf.IEmpty,
        protos.google.cloud.aiplatform.v1beta1.IDeleteOperationMetadata
      >,
      protos.google.longrunning.IOperation | null | undefined,
      {} | null | undefined
    >
  ): Promise<
    [
      LROperation<
        protos.google.protobuf.IEmpty,
        protos.google.cloud.aiplatform.v1beta1.IDeleteOperationMetadata
      >,
      protos.google.longrunning.IOperation | undefined,
      {} | undefined
    ]
  > | void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    } else {
      options = optionsOrCallback as CallOptions;
    }
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers['x-goog-request-params'] =
      gax.routingHeader.fromParams({
        name: request.name || '',
      });
    this.initialize();
    return this.innerApiCalls.deleteFeature(request, options, callback);
  }
  /**
   * Check the status of the long running operation returned by `deleteFeature()`.
   * @param {String} name
   *   The operation name that will be passed.
   * @returns {Promise} - The promise which resolves to an object.
   *   The decoded operation object has result and metadata field to get information from.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#long-running-operations)
   *   for more details and examples.
   * @example
   * const decodedOperation = await checkDeleteFeatureProgress(name);
   * console.log(decodedOperation.result);
   * console.log(decodedOperation.done);
   * console.log(decodedOperation.metadata);
   */
  async checkDeleteFeatureProgress(
    name: string
  ): Promise<
    LROperation<
      protos.google.protobuf.Empty,
      protos.google.cloud.aiplatform.v1beta1.DeleteOperationMetadata
    >
  > {
    const request = new operationsProtos.google.longrunning.GetOperationRequest(
      {name}
    );
    const [operation] = await this.operationsClient.getOperation(request);
    const decodeOperation = new gax.Operation(
      operation,
      this.descriptors.longrunning.deleteFeature,
      gax.createDefaultBackoffSettings()
    );
    return decodeOperation as LROperation<
      protos.google.protobuf.Empty,
      protos.google.cloud.aiplatform.v1beta1.DeleteOperationMetadata
    >;
  }
  importFeatureValues(
    request: protos.google.cloud.aiplatform.v1beta1.IImportFeatureValuesRequest,
    options?: CallOptions
  ): Promise<
    [
      LROperation<
        protos.google.cloud.aiplatform.v1beta1.IImportFeatureValuesResponse,
        protos.google.cloud.aiplatform.v1beta1.IImportFeatureValuesOperationMetadata
      >,
      protos.google.longrunning.IOperation | undefined,
      {} | undefined
    ]
  >;
  importFeatureValues(
    request: protos.google.cloud.aiplatform.v1beta1.IImportFeatureValuesRequest,
    options: CallOptions,
    callback: Callback<
      LROperation<
        protos.google.cloud.aiplatform.v1beta1.IImportFeatureValuesResponse,
        protos.google.cloud.aiplatform.v1beta1.IImportFeatureValuesOperationMetadata
      >,
      protos.google.longrunning.IOperation | null | undefined,
      {} | null | undefined
    >
  ): void;
  importFeatureValues(
    request: protos.google.cloud.aiplatform.v1beta1.IImportFeatureValuesRequest,
    callback: Callback<
      LROperation<
        protos.google.cloud.aiplatform.v1beta1.IImportFeatureValuesResponse,
        protos.google.cloud.aiplatform.v1beta1.IImportFeatureValuesOperationMetadata
      >,
      protos.google.longrunning.IOperation | null | undefined,
      {} | null | undefined
    >
  ): void;
  /**
   * Imports Feature values into the Featurestore from a source storage.
   *
   * The progress of the import is tracked by the returned operation. The
   * imported features are guaranteed to be visible to subsequent read
   * operations after the operation is marked as successfully done.
   *
   * If an import operation fails, the Feature values returned from
   * reads and exports may be inconsistent. If consistency is
   * required, the caller must retry the same import request again and wait till
   * the new operation returned is marked as successfully done.
   *
   * There are also scenarios where the caller can cause inconsistency.
   *
   *  - Source data for import contains multiple distinct Feature values for
   *    the same entity ID and timestamp.
   *  - Source is modified during an import. This includes adding, updating, or
   *  removing source data and/or metadata. Examples of updating metadata
   *  include but are not limited to changing storage location, storage class,
   *  or retention policy.
   *  - Online serving cluster is under-provisioned.
   *
   * @param {Object} request
   *   The request object that will be sent.
   * @param {google.cloud.aiplatform.v1beta1.AvroSource} request.avroSource
   * @param {google.cloud.aiplatform.v1beta1.BigQuerySource} request.bigquerySource
   * @param {google.cloud.aiplatform.v1beta1.CsvSource} request.csvSource
   * @param {string} request.featureTimeField
   *   Source column that holds the Feature timestamp for all Feature
   *   values in each entity.
   * @param {google.protobuf.Timestamp} request.featureTime
   *   Single Feature timestamp for all entities being imported. The
   *   timestamp must not have higher than millisecond precision.
   * @param {string} request.entityType
   *   Required. The resource name of the EntityType grouping the Features for which values
   *   are being imported. Format:
   *   `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entityType}`
   * @param {string} request.entityIdField
   *   Source column that holds entity IDs. If not provided, entity IDs are
   *   extracted from the column named `entity_id`.
   * @param {number[]} request.featureSpecs
   *   Required. Specifications defining which Feature values to import from the entity. The
   *   request fails if no feature_specs are provided, and having multiple
   *   feature_specs for one Feature is not allowed.
   * @param {boolean} request.disableOnlineServing
   *   If set, data will not be imported for online serving. This
   *   is typically used for backfilling, where Feature generation timestamps are
   *   not in the timestamp range needed for online serving.
   * @param {number} request.workerCount
   *   Specifies the number of workers that are used to write data to the
   *   Featurestore. Consider the online serving capacity that you require to
   *   achieve the desired import throughput without interfering with online
   *   serving. The value must be positive, and less than or equal to 100.
   *   If not set, defaults to using 1 worker. The low count ensures minimal
   *   impact on online serving performance.
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
   * @returns {Promise} - The promise which resolves to an array.
   *   The first element of the array is an object representing
   *   a long running operation. Its `promise()` method returns a promise
   *   you can `await` for.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#long-running-operations)
   *   for more details and examples.
   * @example
   * const [operation] = await client.importFeatureValues(request);
   * const [response] = await operation.promise();
   */
  importFeatureValues(
    request: protos.google.cloud.aiplatform.v1beta1.IImportFeatureValuesRequest,
    optionsOrCallback?:
      | CallOptions
      | Callback<
          LROperation<
            protos.google.cloud.aiplatform.v1beta1.IImportFeatureValuesResponse,
            protos.google.cloud.aiplatform.v1beta1.IImportFeatureValuesOperationMetadata
          >,
          protos.google.longrunning.IOperation | null | undefined,
          {} | null | undefined
        >,
    callback?: Callback<
      LROperation<
        protos.google.cloud.aiplatform.v1beta1.IImportFeatureValuesResponse,
        protos.google.cloud.aiplatform.v1beta1.IImportFeatureValuesOperationMetadata
      >,
      protos.google.longrunning.IOperation | null | undefined,
      {} | null | undefined
    >
  ): Promise<
    [
      LROperation<
        protos.google.cloud.aiplatform.v1beta1.IImportFeatureValuesResponse,
        protos.google.cloud.aiplatform.v1beta1.IImportFeatureValuesOperationMetadata
      >,
      protos.google.longrunning.IOperation | undefined,
      {} | undefined
    ]
  > | void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    } else {
      options = optionsOrCallback as CallOptions;
    }
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers['x-goog-request-params'] =
      gax.routingHeader.fromParams({
        entity_type: request.entityType || '',
      });
    this.initialize();
    return this.innerApiCalls.importFeatureValues(request, options, callback);
  }
  /**
   * Check the status of the long running operation returned by `importFeatureValues()`.
   * @param {String} name
   *   The operation name that will be passed.
   * @returns {Promise} - The promise which resolves to an object.
   *   The decoded operation object has result and metadata field to get information from.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#long-running-operations)
   *   for more details and examples.
   * @example
   * const decodedOperation = await checkImportFeatureValuesProgress(name);
   * console.log(decodedOperation.result);
   * console.log(decodedOperation.done);
   * console.log(decodedOperation.metadata);
   */
  async checkImportFeatureValuesProgress(
    name: string
  ): Promise<
    LROperation<
      protos.google.cloud.aiplatform.v1beta1.ImportFeatureValuesResponse,
      protos.google.cloud.aiplatform.v1beta1.ImportFeatureValuesOperationMetadata
    >
  > {
    const request = new operationsProtos.google.longrunning.GetOperationRequest(
      {name}
    );
    const [operation] = await this.operationsClient.getOperation(request);
    const decodeOperation = new gax.Operation(
      operation,
      this.descriptors.longrunning.importFeatureValues,
      gax.createDefaultBackoffSettings()
    );
    return decodeOperation as LROperation<
      protos.google.cloud.aiplatform.v1beta1.ImportFeatureValuesResponse,
      protos.google.cloud.aiplatform.v1beta1.ImportFeatureValuesOperationMetadata
    >;
  }
  batchReadFeatureValues(
    request: protos.google.cloud.aiplatform.v1beta1.IBatchReadFeatureValuesRequest,
    options?: CallOptions
  ): Promise<
    [
      LROperation<
        protos.google.cloud.aiplatform.v1beta1.IBatchReadFeatureValuesResponse,
        protos.google.cloud.aiplatform.v1beta1.IBatchReadFeatureValuesOperationMetadata
      >,
      protos.google.longrunning.IOperation | undefined,
      {} | undefined
    ]
  >;
  batchReadFeatureValues(
    request: protos.google.cloud.aiplatform.v1beta1.IBatchReadFeatureValuesRequest,
    options: CallOptions,
    callback: Callback<
      LROperation<
        protos.google.cloud.aiplatform.v1beta1.IBatchReadFeatureValuesResponse,
        protos.google.cloud.aiplatform.v1beta1.IBatchReadFeatureValuesOperationMetadata
      >,
      protos.google.longrunning.IOperation | null | undefined,
      {} | null | undefined
    >
  ): void;
  batchReadFeatureValues(
    request: protos.google.cloud.aiplatform.v1beta1.IBatchReadFeatureValuesRequest,
    callback: Callback<
      LROperation<
        protos.google.cloud.aiplatform.v1beta1.IBatchReadFeatureValuesResponse,
        protos.google.cloud.aiplatform.v1beta1.IBatchReadFeatureValuesOperationMetadata
      >,
      protos.google.longrunning.IOperation | null | undefined,
      {} | null | undefined
    >
  ): void;
  /**
   * Batch reads Feature values from a Featurestore.
   *
   * This API enables batch reading Feature values, where each read
   * instance in the batch may read Feature values of entities from one or
   * more EntityTypes. Point-in-time correctness is guaranteed for Feature
   * values of each read instance as of each instance's read timestamp.
   *
   * @param {Object} request
   *   The request object that will be sent.
   * @param {google.cloud.aiplatform.v1beta1.CsvSource} request.csvReadInstances
   *   Each read instance consists of exactly one read timestamp and one or more
   *   entity IDs identifying entities of the corresponding EntityTypes whose
   *   Features are requested.
   *
   *   Each output instance contains Feature values of requested entities
   *   concatenated together as of the read time.
   *
   *   An example read instance may be `foo_entity_id, bar_entity_id,
   *   2020-01-01T10:00:00.123Z`.
   *
   *   An example output instance may be `foo_entity_id, bar_entity_id,
   *   2020-01-01T10:00:00.123Z, foo_entity_feature1_value,
   *   bar_entity_feature2_value`.
   *
   *   Timestamp in each read instance must be millisecond-aligned.
   *
   *   `csv_read_instances` are read instances stored in a plain-text CSV file.
   *   The header should be:
   *       [ENTITY_TYPE_ID1], [ENTITY_TYPE_ID2], ..., timestamp
   *
   *   The columns can be in any order.
   *
   *   Values in the timestamp column must use the RFC 3339 format, e.g.
   *   `2012-07-30T10:43:17.123Z`.
   * @param {string} request.featurestore
   *   Required. The resource name of the Featurestore from which to query Feature values.
   *   Format:
   *   `projects/{project}/locations/{location}/featurestores/{featurestore}`
   * @param {google.cloud.aiplatform.v1beta1.FeatureValueDestination} request.destination
   *   Required. Specifies output location and format.
   * @param {number[]} request.entityTypeSpecs
   *   Required. Specifies EntityType grouping Features to read values of and settings.
   *   Each EntityType referenced in
   *   [BatchReadFeatureValuesRequest.entity_type_specs] must have a column
   *   specifying entity IDs in tha EntityType in
   *   {@link |BatchReadFeatureValuesRequest.request} .
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
   * @returns {Promise} - The promise which resolves to an array.
   *   The first element of the array is an object representing
   *   a long running operation. Its `promise()` method returns a promise
   *   you can `await` for.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#long-running-operations)
   *   for more details and examples.
   * @example
   * const [operation] = await client.batchReadFeatureValues(request);
   * const [response] = await operation.promise();
   */
  batchReadFeatureValues(
    request: protos.google.cloud.aiplatform.v1beta1.IBatchReadFeatureValuesRequest,
    optionsOrCallback?:
      | CallOptions
      | Callback<
          LROperation<
            protos.google.cloud.aiplatform.v1beta1.IBatchReadFeatureValuesResponse,
            protos.google.cloud.aiplatform.v1beta1.IBatchReadFeatureValuesOperationMetadata
          >,
          protos.google.longrunning.IOperation | null | undefined,
          {} | null | undefined
        >,
    callback?: Callback<
      LROperation<
        protos.google.cloud.aiplatform.v1beta1.IBatchReadFeatureValuesResponse,
        protos.google.cloud.aiplatform.v1beta1.IBatchReadFeatureValuesOperationMetadata
      >,
      protos.google.longrunning.IOperation | null | undefined,
      {} | null | undefined
    >
  ): Promise<
    [
      LROperation<
        protos.google.cloud.aiplatform.v1beta1.IBatchReadFeatureValuesResponse,
        protos.google.cloud.aiplatform.v1beta1.IBatchReadFeatureValuesOperationMetadata
      >,
      protos.google.longrunning.IOperation | undefined,
      {} | undefined
    ]
  > | void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    } else {
      options = optionsOrCallback as CallOptions;
    }
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers['x-goog-request-params'] =
      gax.routingHeader.fromParams({
        featurestore: request.featurestore || '',
      });
    this.initialize();
    return this.innerApiCalls.batchReadFeatureValues(
      request,
      options,
      callback
    );
  }
  /**
   * Check the status of the long running operation returned by `batchReadFeatureValues()`.
   * @param {String} name
   *   The operation name that will be passed.
   * @returns {Promise} - The promise which resolves to an object.
   *   The decoded operation object has result and metadata field to get information from.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#long-running-operations)
   *   for more details and examples.
   * @example
   * const decodedOperation = await checkBatchReadFeatureValuesProgress(name);
   * console.log(decodedOperation.result);
   * console.log(decodedOperation.done);
   * console.log(decodedOperation.metadata);
   */
  async checkBatchReadFeatureValuesProgress(
    name: string
  ): Promise<
    LROperation<
      protos.google.cloud.aiplatform.v1beta1.BatchReadFeatureValuesResponse,
      protos.google.cloud.aiplatform.v1beta1.BatchReadFeatureValuesOperationMetadata
    >
  > {
    const request = new operationsProtos.google.longrunning.GetOperationRequest(
      {name}
    );
    const [operation] = await this.operationsClient.getOperation(request);
    const decodeOperation = new gax.Operation(
      operation,
      this.descriptors.longrunning.batchReadFeatureValues,
      gax.createDefaultBackoffSettings()
    );
    return decodeOperation as LROperation<
      protos.google.cloud.aiplatform.v1beta1.BatchReadFeatureValuesResponse,
      protos.google.cloud.aiplatform.v1beta1.BatchReadFeatureValuesOperationMetadata
    >;
  }
  exportFeatureValues(
    request: protos.google.cloud.aiplatform.v1beta1.IExportFeatureValuesRequest,
    options?: CallOptions
  ): Promise<
    [
      LROperation<
        protos.google.cloud.aiplatform.v1beta1.IExportFeatureValuesResponse,
        protos.google.cloud.aiplatform.v1beta1.IExportFeatureValuesOperationMetadata
      >,
      protos.google.longrunning.IOperation | undefined,
      {} | undefined
    ]
  >;
  exportFeatureValues(
    request: protos.google.cloud.aiplatform.v1beta1.IExportFeatureValuesRequest,
    options: CallOptions,
    callback: Callback<
      LROperation<
        protos.google.cloud.aiplatform.v1beta1.IExportFeatureValuesResponse,
        protos.google.cloud.aiplatform.v1beta1.IExportFeatureValuesOperationMetadata
      >,
      protos.google.longrunning.IOperation | null | undefined,
      {} | null | undefined
    >
  ): void;
  exportFeatureValues(
    request: protos.google.cloud.aiplatform.v1beta1.IExportFeatureValuesRequest,
    callback: Callback<
      LROperation<
        protos.google.cloud.aiplatform.v1beta1.IExportFeatureValuesResponse,
        protos.google.cloud.aiplatform.v1beta1.IExportFeatureValuesOperationMetadata
      >,
      protos.google.longrunning.IOperation | null | undefined,
      {} | null | undefined
    >
  ): void;
  /**
   * Exports Feature values from all the entities of a target EntityType.
   *
   * @param {Object} request
   *   The request object that will be sent.
   * @param {google.cloud.aiplatform.v1beta1.ExportFeatureValuesRequest.SnapshotExport} request.snapshotExport
   *   Exports Feature values of all entities of the EntityType as of a snapshot
   *   time.
   * @param {string} request.entityType
   *   Required. The resource name of the EntityType from which to export Feature values.
   *   Format:
   *   `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
   * @param {google.cloud.aiplatform.v1beta1.FeatureValueDestination} request.destination
   *   Required. Specifies destination location and format.
   * @param {google.cloud.aiplatform.v1beta1.FeatureSelector} request.featureSelector
   *   Required. Selects Features to export values of.
   * @param {number[]} request.settings
   *   Per-Feature export settings.
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
   * @returns {Promise} - The promise which resolves to an array.
   *   The first element of the array is an object representing
   *   a long running operation. Its `promise()` method returns a promise
   *   you can `await` for.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#long-running-operations)
   *   for more details and examples.
   * @example
   * const [operation] = await client.exportFeatureValues(request);
   * const [response] = await operation.promise();
   */
  exportFeatureValues(
    request: protos.google.cloud.aiplatform.v1beta1.IExportFeatureValuesRequest,
    optionsOrCallback?:
      | CallOptions
      | Callback<
          LROperation<
            protos.google.cloud.aiplatform.v1beta1.IExportFeatureValuesResponse,
            protos.google.cloud.aiplatform.v1beta1.IExportFeatureValuesOperationMetadata
          >,
          protos.google.longrunning.IOperation | null | undefined,
          {} | null | undefined
        >,
    callback?: Callback<
      LROperation<
        protos.google.cloud.aiplatform.v1beta1.IExportFeatureValuesResponse,
        protos.google.cloud.aiplatform.v1beta1.IExportFeatureValuesOperationMetadata
      >,
      protos.google.longrunning.IOperation | null | undefined,
      {} | null | undefined
    >
  ): Promise<
    [
      LROperation<
        protos.google.cloud.aiplatform.v1beta1.IExportFeatureValuesResponse,
        protos.google.cloud.aiplatform.v1beta1.IExportFeatureValuesOperationMetadata
      >,
      protos.google.longrunning.IOperation | undefined,
      {} | undefined
    ]
  > | void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    } else {
      options = optionsOrCallback as CallOptions;
    }
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers['x-goog-request-params'] =
      gax.routingHeader.fromParams({
        entity_type: request.entityType || '',
      });
    this.initialize();
    return this.innerApiCalls.exportFeatureValues(request, options, callback);
  }
  /**
   * Check the status of the long running operation returned by `exportFeatureValues()`.
   * @param {String} name
   *   The operation name that will be passed.
   * @returns {Promise} - The promise which resolves to an object.
   *   The decoded operation object has result and metadata field to get information from.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#long-running-operations)
   *   for more details and examples.
   * @example
   * const decodedOperation = await checkExportFeatureValuesProgress(name);
   * console.log(decodedOperation.result);
   * console.log(decodedOperation.done);
   * console.log(decodedOperation.metadata);
   */
  async checkExportFeatureValuesProgress(
    name: string
  ): Promise<
    LROperation<
      protos.google.cloud.aiplatform.v1beta1.ExportFeatureValuesResponse,
      protos.google.cloud.aiplatform.v1beta1.ExportFeatureValuesOperationMetadata
    >
  > {
    const request = new operationsProtos.google.longrunning.GetOperationRequest(
      {name}
    );
    const [operation] = await this.operationsClient.getOperation(request);
    const decodeOperation = new gax.Operation(
      operation,
      this.descriptors.longrunning.exportFeatureValues,
      gax.createDefaultBackoffSettings()
    );
    return decodeOperation as LROperation<
      protos.google.cloud.aiplatform.v1beta1.ExportFeatureValuesResponse,
      protos.google.cloud.aiplatform.v1beta1.ExportFeatureValuesOperationMetadata
    >;
  }
  listFeaturestores(
    request: protos.google.cloud.aiplatform.v1beta1.IListFeaturestoresRequest,
    options?: CallOptions
  ): Promise<
    [
      protos.google.cloud.aiplatform.v1beta1.IFeaturestore[],
      protos.google.cloud.aiplatform.v1beta1.IListFeaturestoresRequest | null,
      protos.google.cloud.aiplatform.v1beta1.IListFeaturestoresResponse
    ]
  >;
  listFeaturestores(
    request: protos.google.cloud.aiplatform.v1beta1.IListFeaturestoresRequest,
    options: CallOptions,
    callback: PaginationCallback<
      protos.google.cloud.aiplatform.v1beta1.IListFeaturestoresRequest,
      | protos.google.cloud.aiplatform.v1beta1.IListFeaturestoresResponse
      | null
      | undefined,
      protos.google.cloud.aiplatform.v1beta1.IFeaturestore
    >
  ): void;
  listFeaturestores(
    request: protos.google.cloud.aiplatform.v1beta1.IListFeaturestoresRequest,
    callback: PaginationCallback<
      protos.google.cloud.aiplatform.v1beta1.IListFeaturestoresRequest,
      | protos.google.cloud.aiplatform.v1beta1.IListFeaturestoresResponse
      | null
      | undefined,
      protos.google.cloud.aiplatform.v1beta1.IFeaturestore
    >
  ): void;
  /**
   * Lists Featurestores in a given project and location.
   *
   * @param {Object} request
   *   The request object that will be sent.
   * @param {string} request.parent
   *   Required. The resource name of the Location to list Featurestores.
   *   Format:
   *   `projects/{project}/locations/{location}`
   * @param {string} request.filter
   *   Lists the featurestores that match the filter expression. The following
   *   fields are supported:
   *
   *   * `display_name`: Supports =, != comparisons.
   *   * `create_time`: Supports =, !=, <, >, <=, and >= comparisons. Values must
   *   be
   *     in RFC 3339 format.
   *   * `update_time`: Supports =, !=, <, >, <=, and >= comparisons. Values must
   *   be
   *     in RFC 3339 format.
   *   * `online_serving_config.fixed_node_count`: Supports =, !=, <, >, <=,
   *   and >= comparisons.
   *   * `labels`: Supports key-value equality and key presence.
   *
   *   Examples:
   *
   *   * `create_time > "2020-01-01" OR update_time > "2020-01-01"`
   *      Featurestores created or updated after 2020-01-01.
   *   * `labels.env = "prod"`
   *      Featurestores with label "env" set to "prod".
   * @param {number} request.pageSize
   *   The maximum number of Featurestores to return. The service may return fewer
   *   than this value. If unspecified, at most 100 Featurestores will be
   *   returned. The maximum value is 100; any value greater than 100 will be
   *   coerced to 100.
   * @param {string} request.pageToken
   *   A page token, received from a previous
   *   {@link google.cloud.aiplatform.v1beta1.FeaturestoreService.ListFeaturestores|FeaturestoreService.ListFeaturestores} call.
   *   Provide this to retrieve the subsequent page.
   *
   *   When paginating, all other parameters provided to
   *   {@link google.cloud.aiplatform.v1beta1.FeaturestoreService.ListFeaturestores|FeaturestoreService.ListFeaturestores} must
   *   match the call that provided the page token.
   * @param {string} request.orderBy
   *   A comma-separated list of fields to order by, sorted in ascending order.
   *   Use "desc" after a field name for descending.
   *   Supported Fields:
   *
   *     * `display_name`
   *     * `create_time`
   *     * `update_time`
   *     * `online_serving_config.fixed_node_count`
   * @param {google.protobuf.FieldMask} request.readMask
   *   Mask specifying which fields to read.
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
   * @returns {Promise} - The promise which resolves to an array.
   *   The first element of the array is Array of [Featurestore]{@link google.cloud.aiplatform.v1beta1.Featurestore}.
   *   The client library will perform auto-pagination by default: it will call the API as many
   *   times as needed and will merge results from all the pages into this array.
   *   Note that it can affect your quota.
   *   We recommend using `listFeaturestoresAsync()`
   *   method described below for async iteration which you can stop as needed.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination)
   *   for more details and examples.
   */
  listFeaturestores(
    request: protos.google.cloud.aiplatform.v1beta1.IListFeaturestoresRequest,
    optionsOrCallback?:
      | CallOptions
      | PaginationCallback<
          protos.google.cloud.aiplatform.v1beta1.IListFeaturestoresRequest,
          | protos.google.cloud.aiplatform.v1beta1.IListFeaturestoresResponse
          | null
          | undefined,
          protos.google.cloud.aiplatform.v1beta1.IFeaturestore
        >,
    callback?: PaginationCallback<
      protos.google.cloud.aiplatform.v1beta1.IListFeaturestoresRequest,
      | protos.google.cloud.aiplatform.v1beta1.IListFeaturestoresResponse
      | null
      | undefined,
      protos.google.cloud.aiplatform.v1beta1.IFeaturestore
    >
  ): Promise<
    [
      protos.google.cloud.aiplatform.v1beta1.IFeaturestore[],
      protos.google.cloud.aiplatform.v1beta1.IListFeaturestoresRequest | null,
      protos.google.cloud.aiplatform.v1beta1.IListFeaturestoresResponse
    ]
  > | void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    } else {
      options = optionsOrCallback as CallOptions;
    }
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers['x-goog-request-params'] =
      gax.routingHeader.fromParams({
        parent: request.parent || '',
      });
    this.initialize();
    return this.innerApiCalls.listFeaturestores(request, options, callback);
  }

  /**
   * Equivalent to `method.name.toCamelCase()`, but returns a NodeJS Stream object.
   * @param {Object} request
   *   The request object that will be sent.
   * @param {string} request.parent
   *   Required. The resource name of the Location to list Featurestores.
   *   Format:
   *   `projects/{project}/locations/{location}`
   * @param {string} request.filter
   *   Lists the featurestores that match the filter expression. The following
   *   fields are supported:
   *
   *   * `display_name`: Supports =, != comparisons.
   *   * `create_time`: Supports =, !=, <, >, <=, and >= comparisons. Values must
   *   be
   *     in RFC 3339 format.
   *   * `update_time`: Supports =, !=, <, >, <=, and >= comparisons. Values must
   *   be
   *     in RFC 3339 format.
   *   * `online_serving_config.fixed_node_count`: Supports =, !=, <, >, <=,
   *   and >= comparisons.
   *   * `labels`: Supports key-value equality and key presence.
   *
   *   Examples:
   *
   *   * `create_time > "2020-01-01" OR update_time > "2020-01-01"`
   *      Featurestores created or updated after 2020-01-01.
   *   * `labels.env = "prod"`
   *      Featurestores with label "env" set to "prod".
   * @param {number} request.pageSize
   *   The maximum number of Featurestores to return. The service may return fewer
   *   than this value. If unspecified, at most 100 Featurestores will be
   *   returned. The maximum value is 100; any value greater than 100 will be
   *   coerced to 100.
   * @param {string} request.pageToken
   *   A page token, received from a previous
   *   {@link google.cloud.aiplatform.v1beta1.FeaturestoreService.ListFeaturestores|FeaturestoreService.ListFeaturestores} call.
   *   Provide this to retrieve the subsequent page.
   *
   *   When paginating, all other parameters provided to
   *   {@link google.cloud.aiplatform.v1beta1.FeaturestoreService.ListFeaturestores|FeaturestoreService.ListFeaturestores} must
   *   match the call that provided the page token.
   * @param {string} request.orderBy
   *   A comma-separated list of fields to order by, sorted in ascending order.
   *   Use "desc" after a field name for descending.
   *   Supported Fields:
   *
   *     * `display_name`
   *     * `create_time`
   *     * `update_time`
   *     * `online_serving_config.fixed_node_count`
   * @param {google.protobuf.FieldMask} request.readMask
   *   Mask specifying which fields to read.
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
   * @returns {Stream}
   *   An object stream which emits an object representing [Featurestore]{@link google.cloud.aiplatform.v1beta1.Featurestore} on 'data' event.
   *   The client library will perform auto-pagination by default: it will call the API as many
   *   times as needed. Note that it can affect your quota.
   *   We recommend using `listFeaturestoresAsync()`
   *   method described below for async iteration which you can stop as needed.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination)
   *   for more details and examples.
   */
  listFeaturestoresStream(
    request?: protos.google.cloud.aiplatform.v1beta1.IListFeaturestoresRequest,
    options?: CallOptions
  ): Transform {
    request = request || {};
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers['x-goog-request-params'] =
      gax.routingHeader.fromParams({
        parent: request.parent || '',
      });
    const callSettings = new gax.CallSettings(options);
    this.initialize();
    return this.descriptors.page.listFeaturestores.createStream(
      this.innerApiCalls.listFeaturestores as gax.GaxCall,
      request,
      callSettings
    );
  }

  /**
   * Equivalent to `listFeaturestores`, but returns an iterable object.
   *
   * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
   * @param {Object} request
   *   The request object that will be sent.
   * @param {string} request.parent
   *   Required. The resource name of the Location to list Featurestores.
   *   Format:
   *   `projects/{project}/locations/{location}`
   * @param {string} request.filter
   *   Lists the featurestores that match the filter expression. The following
   *   fields are supported:
   *
   *   * `display_name`: Supports =, != comparisons.
   *   * `create_time`: Supports =, !=, <, >, <=, and >= comparisons. Values must
   *   be
   *     in RFC 3339 format.
   *   * `update_time`: Supports =, !=, <, >, <=, and >= comparisons. Values must
   *   be
   *     in RFC 3339 format.
   *   * `online_serving_config.fixed_node_count`: Supports =, !=, <, >, <=,
   *   and >= comparisons.
   *   * `labels`: Supports key-value equality and key presence.
   *
   *   Examples:
   *
   *   * `create_time > "2020-01-01" OR update_time > "2020-01-01"`
   *      Featurestores created or updated after 2020-01-01.
   *   * `labels.env = "prod"`
   *      Featurestores with label "env" set to "prod".
   * @param {number} request.pageSize
   *   The maximum number of Featurestores to return. The service may return fewer
   *   than this value. If unspecified, at most 100 Featurestores will be
   *   returned. The maximum value is 100; any value greater than 100 will be
   *   coerced to 100.
   * @param {string} request.pageToken
   *   A page token, received from a previous
   *   {@link google.cloud.aiplatform.v1beta1.FeaturestoreService.ListFeaturestores|FeaturestoreService.ListFeaturestores} call.
   *   Provide this to retrieve the subsequent page.
   *
   *   When paginating, all other parameters provided to
   *   {@link google.cloud.aiplatform.v1beta1.FeaturestoreService.ListFeaturestores|FeaturestoreService.ListFeaturestores} must
   *   match the call that provided the page token.
   * @param {string} request.orderBy
   *   A comma-separated list of fields to order by, sorted in ascending order.
   *   Use "desc" after a field name for descending.
   *   Supported Fields:
   *
   *     * `display_name`
   *     * `create_time`
   *     * `update_time`
   *     * `online_serving_config.fixed_node_count`
   * @param {google.protobuf.FieldMask} request.readMask
   *   Mask specifying which fields to read.
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
   * @returns {Object}
   *   An iterable Object that allows [async iteration](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols).
   *   When you iterate the returned iterable, each element will be an object representing
   *   [Featurestore]{@link google.cloud.aiplatform.v1beta1.Featurestore}. The API will be called under the hood as needed, once per the page,
   *   so you can stop the iteration when you don't need more results.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination)
   *   for more details and examples.
   * @example
   * const iterable = client.listFeaturestoresAsync(request);
   * for await (const response of iterable) {
   *   // process response
   * }
   */
  listFeaturestoresAsync(
    request?: protos.google.cloud.aiplatform.v1beta1.IListFeaturestoresRequest,
    options?: CallOptions
  ): AsyncIterable<protos.google.cloud.aiplatform.v1beta1.IFeaturestore> {
    request = request || {};
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers['x-goog-request-params'] =
      gax.routingHeader.fromParams({
        parent: request.parent || '',
      });
    options = options || {};
    const callSettings = new gax.CallSettings(options);
    this.initialize();
    return this.descriptors.page.listFeaturestores.asyncIterate(
      this.innerApiCalls['listFeaturestores'] as GaxCall,
      request as unknown as RequestType,
      callSettings
    ) as AsyncIterable<protos.google.cloud.aiplatform.v1beta1.IFeaturestore>;
  }
  listEntityTypes(
    request: protos.google.cloud.aiplatform.v1beta1.IListEntityTypesRequest,
    options?: CallOptions
  ): Promise<
    [
      protos.google.cloud.aiplatform.v1beta1.IEntityType[],
      protos.google.cloud.aiplatform.v1beta1.IListEntityTypesRequest | null,
      protos.google.cloud.aiplatform.v1beta1.IListEntityTypesResponse
    ]
  >;
  listEntityTypes(
    request: protos.google.cloud.aiplatform.v1beta1.IListEntityTypesRequest,
    options: CallOptions,
    callback: PaginationCallback<
      protos.google.cloud.aiplatform.v1beta1.IListEntityTypesRequest,
      | protos.google.cloud.aiplatform.v1beta1.IListEntityTypesResponse
      | null
      | undefined,
      protos.google.cloud.aiplatform.v1beta1.IEntityType
    >
  ): void;
  listEntityTypes(
    request: protos.google.cloud.aiplatform.v1beta1.IListEntityTypesRequest,
    callback: PaginationCallback<
      protos.google.cloud.aiplatform.v1beta1.IListEntityTypesRequest,
      | protos.google.cloud.aiplatform.v1beta1.IListEntityTypesResponse
      | null
      | undefined,
      protos.google.cloud.aiplatform.v1beta1.IEntityType
    >
  ): void;
  /**
   * Lists EntityTypes in a given Featurestore.
   *
   * @param {Object} request
   *   The request object that will be sent.
   * @param {string} request.parent
   *   Required. The resource name of the Featurestore to list EntityTypes.
   *   Format:
   *   `projects/{project}/locations/{location}/featurestores/{featurestore}`
   * @param {string} request.filter
   *   Lists the EntityTypes that match the filter expression. The following
   *   filters are supported:
   *
   *   * `create_time`: Supports =, !=, <, >, >=, and <= comparisons. Values must
   *   be in RFC 3339 format.
   *   * `update_time`: Supports =, !=, <, >, >=, and <= comparisons. Values must
   *   be in RFC 3339 format.
   *   * `labels`: Supports key-value equality as well as key presence.
   *
   *   Examples:
   *
   *   * `create_time > \"2020-01-31T15:30:00.000000Z\" OR
   *        update_time > \"2020-01-31T15:30:00.000000Z\"` --> EntityTypes created
   *        or updated after 2020-01-31T15:30:00.000000Z.
   *   * `labels.active = yes AND labels.env = prod` --> EntityTypes having both
   *       (active: yes) and (env: prod) labels.
   *   * `labels.env: *` --> Any EntityType which has a label with 'env' as the
   *     key.
   * @param {number} request.pageSize
   *   The maximum number of EntityTypes to return. The service may return fewer
   *   than this value. If unspecified, at most 1000 EntityTypes will be returned.
   *   The maximum value is 1000; any value greater than 1000 will be coerced to
   *   1000.
   * @param {string} request.pageToken
   *   A page token, received from a previous
   *   {@link google.cloud.aiplatform.v1beta1.FeaturestoreService.ListEntityTypes|FeaturestoreService.ListEntityTypes} call.
   *   Provide this to retrieve the subsequent page.
   *
   *   When paginating, all other parameters provided to
   *   {@link google.cloud.aiplatform.v1beta1.FeaturestoreService.ListEntityTypes|FeaturestoreService.ListEntityTypes} must
   *   match the call that provided the page token.
   * @param {string} request.orderBy
   *   A comma-separated list of fields to order by, sorted in ascending order.
   *   Use "desc" after a field name for descending.
   *
   *   Supported fields:
   *
   *     * `entity_type_id`
   *     * `create_time`
   *     * `update_time`
   * @param {google.protobuf.FieldMask} request.readMask
   *   Mask specifying which fields to read.
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
   * @returns {Promise} - The promise which resolves to an array.
   *   The first element of the array is Array of [EntityType]{@link google.cloud.aiplatform.v1beta1.EntityType}.
   *   The client library will perform auto-pagination by default: it will call the API as many
   *   times as needed and will merge results from all the pages into this array.
   *   Note that it can affect your quota.
   *   We recommend using `listEntityTypesAsync()`
   *   method described below for async iteration which you can stop as needed.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination)
   *   for more details and examples.
   */
  listEntityTypes(
    request: protos.google.cloud.aiplatform.v1beta1.IListEntityTypesRequest,
    optionsOrCallback?:
      | CallOptions
      | PaginationCallback<
          protos.google.cloud.aiplatform.v1beta1.IListEntityTypesRequest,
          | protos.google.cloud.aiplatform.v1beta1.IListEntityTypesResponse
          | null
          | undefined,
          protos.google.cloud.aiplatform.v1beta1.IEntityType
        >,
    callback?: PaginationCallback<
      protos.google.cloud.aiplatform.v1beta1.IListEntityTypesRequest,
      | protos.google.cloud.aiplatform.v1beta1.IListEntityTypesResponse
      | null
      | undefined,
      protos.google.cloud.aiplatform.v1beta1.IEntityType
    >
  ): Promise<
    [
      protos.google.cloud.aiplatform.v1beta1.IEntityType[],
      protos.google.cloud.aiplatform.v1beta1.IListEntityTypesRequest | null,
      protos.google.cloud.aiplatform.v1beta1.IListEntityTypesResponse
    ]
  > | void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    } else {
      options = optionsOrCallback as CallOptions;
    }
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers['x-goog-request-params'] =
      gax.routingHeader.fromParams({
        parent: request.parent || '',
      });
    this.initialize();
    return this.innerApiCalls.listEntityTypes(request, options, callback);
  }

  /**
   * Equivalent to `method.name.toCamelCase()`, but returns a NodeJS Stream object.
   * @param {Object} request
   *   The request object that will be sent.
   * @param {string} request.parent
   *   Required. The resource name of the Featurestore to list EntityTypes.
   *   Format:
   *   `projects/{project}/locations/{location}/featurestores/{featurestore}`
   * @param {string} request.filter
   *   Lists the EntityTypes that match the filter expression. The following
   *   filters are supported:
   *
   *   * `create_time`: Supports =, !=, <, >, >=, and <= comparisons. Values must
   *   be in RFC 3339 format.
   *   * `update_time`: Supports =, !=, <, >, >=, and <= comparisons. Values must
   *   be in RFC 3339 format.
   *   * `labels`: Supports key-value equality as well as key presence.
   *
   *   Examples:
   *
   *   * `create_time > \"2020-01-31T15:30:00.000000Z\" OR
   *        update_time > \"2020-01-31T15:30:00.000000Z\"` --> EntityTypes created
   *        or updated after 2020-01-31T15:30:00.000000Z.
   *   * `labels.active = yes AND labels.env = prod` --> EntityTypes having both
   *       (active: yes) and (env: prod) labels.
   *   * `labels.env: *` --> Any EntityType which has a label with 'env' as the
   *     key.
   * @param {number} request.pageSize
   *   The maximum number of EntityTypes to return. The service may return fewer
   *   than this value. If unspecified, at most 1000 EntityTypes will be returned.
   *   The maximum value is 1000; any value greater than 1000 will be coerced to
   *   1000.
   * @param {string} request.pageToken
   *   A page token, received from a previous
   *   {@link google.cloud.aiplatform.v1beta1.FeaturestoreService.ListEntityTypes|FeaturestoreService.ListEntityTypes} call.
   *   Provide this to retrieve the subsequent page.
   *
   *   When paginating, all other parameters provided to
   *   {@link google.cloud.aiplatform.v1beta1.FeaturestoreService.ListEntityTypes|FeaturestoreService.ListEntityTypes} must
   *   match the call that provided the page token.
   * @param {string} request.orderBy
   *   A comma-separated list of fields to order by, sorted in ascending order.
   *   Use "desc" after a field name for descending.
   *
   *   Supported fields:
   *
   *     * `entity_type_id`
   *     * `create_time`
   *     * `update_time`
   * @param {google.protobuf.FieldMask} request.readMask
   *   Mask specifying which fields to read.
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
   * @returns {Stream}
   *   An object stream which emits an object representing [EntityType]{@link google.cloud.aiplatform.v1beta1.EntityType} on 'data' event.
   *   The client library will perform auto-pagination by default: it will call the API as many
   *   times as needed. Note that it can affect your quota.
   *   We recommend using `listEntityTypesAsync()`
   *   method described below for async iteration which you can stop as needed.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination)
   *   for more details and examples.
   */
  listEntityTypesStream(
    request?: protos.google.cloud.aiplatform.v1beta1.IListEntityTypesRequest,
    options?: CallOptions
  ): Transform {
    request = request || {};
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers['x-goog-request-params'] =
      gax.routingHeader.fromParams({
        parent: request.parent || '',
      });
    const callSettings = new gax.CallSettings(options);
    this.initialize();
    return this.descriptors.page.listEntityTypes.createStream(
      this.innerApiCalls.listEntityTypes as gax.GaxCall,
      request,
      callSettings
    );
  }

  /**
   * Equivalent to `listEntityTypes`, but returns an iterable object.
   *
   * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
   * @param {Object} request
   *   The request object that will be sent.
   * @param {string} request.parent
   *   Required. The resource name of the Featurestore to list EntityTypes.
   *   Format:
   *   `projects/{project}/locations/{location}/featurestores/{featurestore}`
   * @param {string} request.filter
   *   Lists the EntityTypes that match the filter expression. The following
   *   filters are supported:
   *
   *   * `create_time`: Supports =, !=, <, >, >=, and <= comparisons. Values must
   *   be in RFC 3339 format.
   *   * `update_time`: Supports =, !=, <, >, >=, and <= comparisons. Values must
   *   be in RFC 3339 format.
   *   * `labels`: Supports key-value equality as well as key presence.
   *
   *   Examples:
   *
   *   * `create_time > \"2020-01-31T15:30:00.000000Z\" OR
   *        update_time > \"2020-01-31T15:30:00.000000Z\"` --> EntityTypes created
   *        or updated after 2020-01-31T15:30:00.000000Z.
   *   * `labels.active = yes AND labels.env = prod` --> EntityTypes having both
   *       (active: yes) and (env: prod) labels.
   *   * `labels.env: *` --> Any EntityType which has a label with 'env' as the
   *     key.
   * @param {number} request.pageSize
   *   The maximum number of EntityTypes to return. The service may return fewer
   *   than this value. If unspecified, at most 1000 EntityTypes will be returned.
   *   The maximum value is 1000; any value greater than 1000 will be coerced to
   *   1000.
   * @param {string} request.pageToken
   *   A page token, received from a previous
   *   {@link google.cloud.aiplatform.v1beta1.FeaturestoreService.ListEntityTypes|FeaturestoreService.ListEntityTypes} call.
   *   Provide this to retrieve the subsequent page.
   *
   *   When paginating, all other parameters provided to
   *   {@link google.cloud.aiplatform.v1beta1.FeaturestoreService.ListEntityTypes|FeaturestoreService.ListEntityTypes} must
   *   match the call that provided the page token.
   * @param {string} request.orderBy
   *   A comma-separated list of fields to order by, sorted in ascending order.
   *   Use "desc" after a field name for descending.
   *
   *   Supported fields:
   *
   *     * `entity_type_id`
   *     * `create_time`
   *     * `update_time`
   * @param {google.protobuf.FieldMask} request.readMask
   *   Mask specifying which fields to read.
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
   * @returns {Object}
   *   An iterable Object that allows [async iteration](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols).
   *   When you iterate the returned iterable, each element will be an object representing
   *   [EntityType]{@link google.cloud.aiplatform.v1beta1.EntityType}. The API will be called under the hood as needed, once per the page,
   *   so you can stop the iteration when you don't need more results.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination)
   *   for more details and examples.
   * @example
   * const iterable = client.listEntityTypesAsync(request);
   * for await (const response of iterable) {
   *   // process response
   * }
   */
  listEntityTypesAsync(
    request?: protos.google.cloud.aiplatform.v1beta1.IListEntityTypesRequest,
    options?: CallOptions
  ): AsyncIterable<protos.google.cloud.aiplatform.v1beta1.IEntityType> {
    request = request || {};
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers['x-goog-request-params'] =
      gax.routingHeader.fromParams({
        parent: request.parent || '',
      });
    options = options || {};
    const callSettings = new gax.CallSettings(options);
    this.initialize();
    return this.descriptors.page.listEntityTypes.asyncIterate(
      this.innerApiCalls['listEntityTypes'] as GaxCall,
      request as unknown as RequestType,
      callSettings
    ) as AsyncIterable<protos.google.cloud.aiplatform.v1beta1.IEntityType>;
  }
  listFeatures(
    request: protos.google.cloud.aiplatform.v1beta1.IListFeaturesRequest,
    options?: CallOptions
  ): Promise<
    [
      protos.google.cloud.aiplatform.v1beta1.IFeature[],
      protos.google.cloud.aiplatform.v1beta1.IListFeaturesRequest | null,
      protos.google.cloud.aiplatform.v1beta1.IListFeaturesResponse
    ]
  >;
  listFeatures(
    request: protos.google.cloud.aiplatform.v1beta1.IListFeaturesRequest,
    options: CallOptions,
    callback: PaginationCallback<
      protos.google.cloud.aiplatform.v1beta1.IListFeaturesRequest,
      | protos.google.cloud.aiplatform.v1beta1.IListFeaturesResponse
      | null
      | undefined,
      protos.google.cloud.aiplatform.v1beta1.IFeature
    >
  ): void;
  listFeatures(
    request: protos.google.cloud.aiplatform.v1beta1.IListFeaturesRequest,
    callback: PaginationCallback<
      protos.google.cloud.aiplatform.v1beta1.IListFeaturesRequest,
      | protos.google.cloud.aiplatform.v1beta1.IListFeaturesResponse
      | null
      | undefined,
      protos.google.cloud.aiplatform.v1beta1.IFeature
    >
  ): void;
  /**
   * Lists Features in a given EntityType.
   *
   * @param {Object} request
   *   The request object that will be sent.
   * @param {string} request.parent
   *   Required. The resource name of the Location to list Features.
   *   Format:
   *   `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
   * @param {string} request.filter
   *   Lists the Features that match the filter expression. The following
   *   filters are supported:
   *
   *   * `value_type`: Supports = and != comparisons.
   *   * `create_time`: Supports =, !=, <, >, >=, and <= comparisons. Values must
   *   be in RFC 3339 format.
   *   * `update_time`: Supports =, !=, <, >, >=, and <= comparisons. Values must
   *   be in RFC 3339 format.
   *   * `labels`: Supports key-value equality as well as key presence.
   *
   *   Examples:
   *
   *   * `value_type = DOUBLE` --> Features whose type is DOUBLE.
   *   * `create_time > \"2020-01-31T15:30:00.000000Z\" OR
   *        update_time > \"2020-01-31T15:30:00.000000Z\"` --> EntityTypes created
   *        or updated after 2020-01-31T15:30:00.000000Z.
   *   * `labels.active = yes AND labels.env = prod` --> Features having both
   *       (active: yes) and (env: prod) labels.
   *   * `labels.env: *` --> Any Feature which has a label with 'env' as the
   *     key.
   * @param {number} request.pageSize
   *   The maximum number of Features to return. The service may return fewer
   *   than this value. If unspecified, at most 1000 Features will be returned.
   *   The maximum value is 1000; any value greater than 1000 will be coerced to
   *   1000.
   * @param {string} request.pageToken
   *   A page token, received from a previous
   *   {@link google.cloud.aiplatform.v1beta1.FeaturestoreService.ListFeatures|FeaturestoreService.ListFeatures} call.
   *   Provide this to retrieve the subsequent page.
   *
   *   When paginating, all other parameters provided to
   *   {@link google.cloud.aiplatform.v1beta1.FeaturestoreService.ListFeatures|FeaturestoreService.ListFeatures} must
   *   match the call that provided the page token.
   * @param {string} request.orderBy
   *   A comma-separated list of fields to order by, sorted in ascending order.
   *   Use "desc" after a field name for descending.
   *   Supported fields:
   *
   *     * `feature_id`
   *     * `value_type`
   *     * `create_time`
   *     * `update_time`
   * @param {google.protobuf.FieldMask} request.readMask
   *   Mask specifying which fields to read.
   * @param {number} request.latestStatsCount
   *   If set, return the most recent {@link google.cloud.aiplatform.v1beta1.ListFeaturesRequest.latest_stats_count|ListFeaturesRequest.latest_stats_count}
   *   of stats for each Feature in response. Valid value is [0, 10]. If number of
   *   stats exists < {@link google.cloud.aiplatform.v1beta1.ListFeaturesRequest.latest_stats_count|ListFeaturesRequest.latest_stats_count}, return all
   *   existing stats.
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
   * @returns {Promise} - The promise which resolves to an array.
   *   The first element of the array is Array of [Feature]{@link google.cloud.aiplatform.v1beta1.Feature}.
   *   The client library will perform auto-pagination by default: it will call the API as many
   *   times as needed and will merge results from all the pages into this array.
   *   Note that it can affect your quota.
   *   We recommend using `listFeaturesAsync()`
   *   method described below for async iteration which you can stop as needed.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination)
   *   for more details and examples.
   */
  listFeatures(
    request: protos.google.cloud.aiplatform.v1beta1.IListFeaturesRequest,
    optionsOrCallback?:
      | CallOptions
      | PaginationCallback<
          protos.google.cloud.aiplatform.v1beta1.IListFeaturesRequest,
          | protos.google.cloud.aiplatform.v1beta1.IListFeaturesResponse
          | null
          | undefined,
          protos.google.cloud.aiplatform.v1beta1.IFeature
        >,
    callback?: PaginationCallback<
      protos.google.cloud.aiplatform.v1beta1.IListFeaturesRequest,
      | protos.google.cloud.aiplatform.v1beta1.IListFeaturesResponse
      | null
      | undefined,
      protos.google.cloud.aiplatform.v1beta1.IFeature
    >
  ): Promise<
    [
      protos.google.cloud.aiplatform.v1beta1.IFeature[],
      protos.google.cloud.aiplatform.v1beta1.IListFeaturesRequest | null,
      protos.google.cloud.aiplatform.v1beta1.IListFeaturesResponse
    ]
  > | void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    } else {
      options = optionsOrCallback as CallOptions;
    }
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers['x-goog-request-params'] =
      gax.routingHeader.fromParams({
        parent: request.parent || '',
      });
    this.initialize();
    return this.innerApiCalls.listFeatures(request, options, callback);
  }

  /**
   * Equivalent to `method.name.toCamelCase()`, but returns a NodeJS Stream object.
   * @param {Object} request
   *   The request object that will be sent.
   * @param {string} request.parent
   *   Required. The resource name of the Location to list Features.
   *   Format:
   *   `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
   * @param {string} request.filter
   *   Lists the Features that match the filter expression. The following
   *   filters are supported:
   *
   *   * `value_type`: Supports = and != comparisons.
   *   * `create_time`: Supports =, !=, <, >, >=, and <= comparisons. Values must
   *   be in RFC 3339 format.
   *   * `update_time`: Supports =, !=, <, >, >=, and <= comparisons. Values must
   *   be in RFC 3339 format.
   *   * `labels`: Supports key-value equality as well as key presence.
   *
   *   Examples:
   *
   *   * `value_type = DOUBLE` --> Features whose type is DOUBLE.
   *   * `create_time > \"2020-01-31T15:30:00.000000Z\" OR
   *        update_time > \"2020-01-31T15:30:00.000000Z\"` --> EntityTypes created
   *        or updated after 2020-01-31T15:30:00.000000Z.
   *   * `labels.active = yes AND labels.env = prod` --> Features having both
   *       (active: yes) and (env: prod) labels.
   *   * `labels.env: *` --> Any Feature which has a label with 'env' as the
   *     key.
   * @param {number} request.pageSize
   *   The maximum number of Features to return. The service may return fewer
   *   than this value. If unspecified, at most 1000 Features will be returned.
   *   The maximum value is 1000; any value greater than 1000 will be coerced to
   *   1000.
   * @param {string} request.pageToken
   *   A page token, received from a previous
   *   {@link google.cloud.aiplatform.v1beta1.FeaturestoreService.ListFeatures|FeaturestoreService.ListFeatures} call.
   *   Provide this to retrieve the subsequent page.
   *
   *   When paginating, all other parameters provided to
   *   {@link google.cloud.aiplatform.v1beta1.FeaturestoreService.ListFeatures|FeaturestoreService.ListFeatures} must
   *   match the call that provided the page token.
   * @param {string} request.orderBy
   *   A comma-separated list of fields to order by, sorted in ascending order.
   *   Use "desc" after a field name for descending.
   *   Supported fields:
   *
   *     * `feature_id`
   *     * `value_type`
   *     * `create_time`
   *     * `update_time`
   * @param {google.protobuf.FieldMask} request.readMask
   *   Mask specifying which fields to read.
   * @param {number} request.latestStatsCount
   *   If set, return the most recent {@link google.cloud.aiplatform.v1beta1.ListFeaturesRequest.latest_stats_count|ListFeaturesRequest.latest_stats_count}
   *   of stats for each Feature in response. Valid value is [0, 10]. If number of
   *   stats exists < {@link google.cloud.aiplatform.v1beta1.ListFeaturesRequest.latest_stats_count|ListFeaturesRequest.latest_stats_count}, return all
   *   existing stats.
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
   * @returns {Stream}
   *   An object stream which emits an object representing [Feature]{@link google.cloud.aiplatform.v1beta1.Feature} on 'data' event.
   *   The client library will perform auto-pagination by default: it will call the API as many
   *   times as needed. Note that it can affect your quota.
   *   We recommend using `listFeaturesAsync()`
   *   method described below for async iteration which you can stop as needed.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination)
   *   for more details and examples.
   */
  listFeaturesStream(
    request?: protos.google.cloud.aiplatform.v1beta1.IListFeaturesRequest,
    options?: CallOptions
  ): Transform {
    request = request || {};
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers['x-goog-request-params'] =
      gax.routingHeader.fromParams({
        parent: request.parent || '',
      });
    const callSettings = new gax.CallSettings(options);
    this.initialize();
    return this.descriptors.page.listFeatures.createStream(
      this.innerApiCalls.listFeatures as gax.GaxCall,
      request,
      callSettings
    );
  }

  /**
   * Equivalent to `listFeatures`, but returns an iterable object.
   *
   * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
   * @param {Object} request
   *   The request object that will be sent.
   * @param {string} request.parent
   *   Required. The resource name of the Location to list Features.
   *   Format:
   *   `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
   * @param {string} request.filter
   *   Lists the Features that match the filter expression. The following
   *   filters are supported:
   *
   *   * `value_type`: Supports = and != comparisons.
   *   * `create_time`: Supports =, !=, <, >, >=, and <= comparisons. Values must
   *   be in RFC 3339 format.
   *   * `update_time`: Supports =, !=, <, >, >=, and <= comparisons. Values must
   *   be in RFC 3339 format.
   *   * `labels`: Supports key-value equality as well as key presence.
   *
   *   Examples:
   *
   *   * `value_type = DOUBLE` --> Features whose type is DOUBLE.
   *   * `create_time > \"2020-01-31T15:30:00.000000Z\" OR
   *        update_time > \"2020-01-31T15:30:00.000000Z\"` --> EntityTypes created
   *        or updated after 2020-01-31T15:30:00.000000Z.
   *   * `labels.active = yes AND labels.env = prod` --> Features having both
   *       (active: yes) and (env: prod) labels.
   *   * `labels.env: *` --> Any Feature which has a label with 'env' as the
   *     key.
   * @param {number} request.pageSize
   *   The maximum number of Features to return. The service may return fewer
   *   than this value. If unspecified, at most 1000 Features will be returned.
   *   The maximum value is 1000; any value greater than 1000 will be coerced to
   *   1000.
   * @param {string} request.pageToken
   *   A page token, received from a previous
   *   {@link google.cloud.aiplatform.v1beta1.FeaturestoreService.ListFeatures|FeaturestoreService.ListFeatures} call.
   *   Provide this to retrieve the subsequent page.
   *
   *   When paginating, all other parameters provided to
   *   {@link google.cloud.aiplatform.v1beta1.FeaturestoreService.ListFeatures|FeaturestoreService.ListFeatures} must
   *   match the call that provided the page token.
   * @param {string} request.orderBy
   *   A comma-separated list of fields to order by, sorted in ascending order.
   *   Use "desc" after a field name for descending.
   *   Supported fields:
   *
   *     * `feature_id`
   *     * `value_type`
   *     * `create_time`
   *     * `update_time`
   * @param {google.protobuf.FieldMask} request.readMask
   *   Mask specifying which fields to read.
   * @param {number} request.latestStatsCount
   *   If set, return the most recent {@link google.cloud.aiplatform.v1beta1.ListFeaturesRequest.latest_stats_count|ListFeaturesRequest.latest_stats_count}
   *   of stats for each Feature in response. Valid value is [0, 10]. If number of
   *   stats exists < {@link google.cloud.aiplatform.v1beta1.ListFeaturesRequest.latest_stats_count|ListFeaturesRequest.latest_stats_count}, return all
   *   existing stats.
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
   * @returns {Object}
   *   An iterable Object that allows [async iteration](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols).
   *   When you iterate the returned iterable, each element will be an object representing
   *   [Feature]{@link google.cloud.aiplatform.v1beta1.Feature}. The API will be called under the hood as needed, once per the page,
   *   so you can stop the iteration when you don't need more results.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination)
   *   for more details and examples.
   * @example
   * const iterable = client.listFeaturesAsync(request);
   * for await (const response of iterable) {
   *   // process response
   * }
   */
  listFeaturesAsync(
    request?: protos.google.cloud.aiplatform.v1beta1.IListFeaturesRequest,
    options?: CallOptions
  ): AsyncIterable<protos.google.cloud.aiplatform.v1beta1.IFeature> {
    request = request || {};
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers['x-goog-request-params'] =
      gax.routingHeader.fromParams({
        parent: request.parent || '',
      });
    options = options || {};
    const callSettings = new gax.CallSettings(options);
    this.initialize();
    return this.descriptors.page.listFeatures.asyncIterate(
      this.innerApiCalls['listFeatures'] as GaxCall,
      request as unknown as RequestType,
      callSettings
    ) as AsyncIterable<protos.google.cloud.aiplatform.v1beta1.IFeature>;
  }
  searchFeatures(
    request: protos.google.cloud.aiplatform.v1beta1.ISearchFeaturesRequest,
    options?: CallOptions
  ): Promise<
    [
      protos.google.cloud.aiplatform.v1beta1.IFeature[],
      protos.google.cloud.aiplatform.v1beta1.ISearchFeaturesRequest | null,
      protos.google.cloud.aiplatform.v1beta1.ISearchFeaturesResponse
    ]
  >;
  searchFeatures(
    request: protos.google.cloud.aiplatform.v1beta1.ISearchFeaturesRequest,
    options: CallOptions,
    callback: PaginationCallback<
      protos.google.cloud.aiplatform.v1beta1.ISearchFeaturesRequest,
      | protos.google.cloud.aiplatform.v1beta1.ISearchFeaturesResponse
      | null
      | undefined,
      protos.google.cloud.aiplatform.v1beta1.IFeature
    >
  ): void;
  searchFeatures(
    request: protos.google.cloud.aiplatform.v1beta1.ISearchFeaturesRequest,
    callback: PaginationCallback<
      protos.google.cloud.aiplatform.v1beta1.ISearchFeaturesRequest,
      | protos.google.cloud.aiplatform.v1beta1.ISearchFeaturesResponse
      | null
      | undefined,
      protos.google.cloud.aiplatform.v1beta1.IFeature
    >
  ): void;
  /**
   * Searches Features matching a query in a given project.
   *
   * @param {Object} request
   *   The request object that will be sent.
   * @param {string} request.location
   *   Required. The resource name of the Location to search Features.
   *   Format:
   *   `projects/{project}/locations/{location}`
   * @param {string} request.query
   *   Query string that is a conjunction of field-restricted queries and/or
   *   field-restricted filters.  Field-restricted queries and filters can be
   *   combined using `AND` to form a conjunction.
   *
   *   A field query is in the form FIELD:QUERY. This implicitly checks if QUERY
   *   exists as a substring within Feature's FIELD. The QUERY
   *   and the FIELD are converted to a sequence of words (i.e. tokens) for
   *   comparison. This is done by:
   *
   *     * Removing leading/trailing whitespace and tokenizing the search value.
   *     Characters that are not one of alphanumeric [a-zA-Z0-9], underscore [_],
   *     or asterisk [*] are treated as delimiters for tokens. (*) is treated as a
   *     wildcard that matches characters within a token.
   *     * Ignoring case.
   *     * Prepending an asterisk to the first and appending an asterisk to the
   *     last token in QUERY.
   *
   *   A QUERY must be either a singular token or a phrase. A phrase is one or
   *   multiple words enclosed in double quotation marks ("). With phrases, the
   *   order of the words is important. Words in the phrase must be matching in
   *   order and consecutively.
   *
   *   Supported FIELDs for field-restricted queries:
   *
   *   * `feature_id`
   *   * `description`
   *   * `entity_type_id`
   *
   *   Examples:
   *
   *   * `feature_id: foo` --> Matches a Feature with ID containing the substring
   *   `foo` (eg. `foo`, `foofeature`, `barfoo`).
   *   * `feature_id: foo*feature` --> Matches a Feature with ID containing the
   *   substring `foo*feature` (eg. `foobarfeature`).
   *   * `feature_id: foo AND description: bar` --> Matches a Feature with ID
   *   containing the substring `foo` and description containing the substring
   *   `bar`.
   *
   *
   *   Besides field queries, the following exact-match filters are
   *   supported. The exact-match filters do not support wildcards. Unlike
   *   field-restricted queries, exact-match filters are case-sensitive.
   *
   *   * `feature_id`: Supports = comparisons.
   *   * `description`: Supports = comparisons. Multi-token filters should be
   *   enclosed in quotes.
   *   * `entity_type_id`: Supports = comparisons.
   *   * `value_type`: Supports = and != comparisons.
   *   * `labels`: Supports key-value equality as well as key presence.
   *   * `featurestore_id`: Supports = comparisons.
   *
   *   Examples:
   *   * `description = "foo bar"` --> Any Feature with description exactly equal
   *   to `foo bar`
   *   * `value_type = DOUBLE` --> Features whose type is DOUBLE.
   *   * `labels.active = yes AND labels.env = prod` --> Features having both
   *       (active: yes) and (env: prod) labels.
   *   * `labels.env: *` --> Any Feature which has a label with `env` as the
   *     key.
   * @param {number} request.pageSize
   *   The maximum number of Features to return. The service may return fewer
   *   than this value. If unspecified, at most 100 Features will be returned.
   *   The maximum value is 100; any value greater than 100 will be coerced to
   *   100.
   * @param {string} request.pageToken
   *   A page token, received from a previous
   *   {@link google.cloud.aiplatform.v1beta1.FeaturestoreService.SearchFeatures|FeaturestoreService.SearchFeatures} call.
   *   Provide this to retrieve the subsequent page.
   *
   *   When paginating, all other parameters provided to
   *   {@link google.cloud.aiplatform.v1beta1.FeaturestoreService.SearchFeatures|FeaturestoreService.SearchFeatures}, except `page_size`, must
   *   match the call that provided the page token.
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
   * @returns {Promise} - The promise which resolves to an array.
   *   The first element of the array is Array of [Feature]{@link google.cloud.aiplatform.v1beta1.Feature}.
   *   The client library will perform auto-pagination by default: it will call the API as many
   *   times as needed and will merge results from all the pages into this array.
   *   Note that it can affect your quota.
   *   We recommend using `searchFeaturesAsync()`
   *   method described below for async iteration which you can stop as needed.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination)
   *   for more details and examples.
   */
  searchFeatures(
    request: protos.google.cloud.aiplatform.v1beta1.ISearchFeaturesRequest,
    optionsOrCallback?:
      | CallOptions
      | PaginationCallback<
          protos.google.cloud.aiplatform.v1beta1.ISearchFeaturesRequest,
          | protos.google.cloud.aiplatform.v1beta1.ISearchFeaturesResponse
          | null
          | undefined,
          protos.google.cloud.aiplatform.v1beta1.IFeature
        >,
    callback?: PaginationCallback<
      protos.google.cloud.aiplatform.v1beta1.ISearchFeaturesRequest,
      | protos.google.cloud.aiplatform.v1beta1.ISearchFeaturesResponse
      | null
      | undefined,
      protos.google.cloud.aiplatform.v1beta1.IFeature
    >
  ): Promise<
    [
      protos.google.cloud.aiplatform.v1beta1.IFeature[],
      protos.google.cloud.aiplatform.v1beta1.ISearchFeaturesRequest | null,
      protos.google.cloud.aiplatform.v1beta1.ISearchFeaturesResponse
    ]
  > | void {
    request = request || {};
    let options: CallOptions;
    if (typeof optionsOrCallback === 'function' && callback === undefined) {
      callback = optionsOrCallback;
      options = {};
    } else {
      options = optionsOrCallback as CallOptions;
    }
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers['x-goog-request-params'] =
      gax.routingHeader.fromParams({
        location: request.location || '',
      });
    this.initialize();
    return this.innerApiCalls.searchFeatures(request, options, callback);
  }

  /**
   * Equivalent to `method.name.toCamelCase()`, but returns a NodeJS Stream object.
   * @param {Object} request
   *   The request object that will be sent.
   * @param {string} request.location
   *   Required. The resource name of the Location to search Features.
   *   Format:
   *   `projects/{project}/locations/{location}`
   * @param {string} request.query
   *   Query string that is a conjunction of field-restricted queries and/or
   *   field-restricted filters.  Field-restricted queries and filters can be
   *   combined using `AND` to form a conjunction.
   *
   *   A field query is in the form FIELD:QUERY. This implicitly checks if QUERY
   *   exists as a substring within Feature's FIELD. The QUERY
   *   and the FIELD are converted to a sequence of words (i.e. tokens) for
   *   comparison. This is done by:
   *
   *     * Removing leading/trailing whitespace and tokenizing the search value.
   *     Characters that are not one of alphanumeric [a-zA-Z0-9], underscore [_],
   *     or asterisk [*] are treated as delimiters for tokens. (*) is treated as a
   *     wildcard that matches characters within a token.
   *     * Ignoring case.
   *     * Prepending an asterisk to the first and appending an asterisk to the
   *     last token in QUERY.
   *
   *   A QUERY must be either a singular token or a phrase. A phrase is one or
   *   multiple words enclosed in double quotation marks ("). With phrases, the
   *   order of the words is important. Words in the phrase must be matching in
   *   order and consecutively.
   *
   *   Supported FIELDs for field-restricted queries:
   *
   *   * `feature_id`
   *   * `description`
   *   * `entity_type_id`
   *
   *   Examples:
   *
   *   * `feature_id: foo` --> Matches a Feature with ID containing the substring
   *   `foo` (eg. `foo`, `foofeature`, `barfoo`).
   *   * `feature_id: foo*feature` --> Matches a Feature with ID containing the
   *   substring `foo*feature` (eg. `foobarfeature`).
   *   * `feature_id: foo AND description: bar` --> Matches a Feature with ID
   *   containing the substring `foo` and description containing the substring
   *   `bar`.
   *
   *
   *   Besides field queries, the following exact-match filters are
   *   supported. The exact-match filters do not support wildcards. Unlike
   *   field-restricted queries, exact-match filters are case-sensitive.
   *
   *   * `feature_id`: Supports = comparisons.
   *   * `description`: Supports = comparisons. Multi-token filters should be
   *   enclosed in quotes.
   *   * `entity_type_id`: Supports = comparisons.
   *   * `value_type`: Supports = and != comparisons.
   *   * `labels`: Supports key-value equality as well as key presence.
   *   * `featurestore_id`: Supports = comparisons.
   *
   *   Examples:
   *   * `description = "foo bar"` --> Any Feature with description exactly equal
   *   to `foo bar`
   *   * `value_type = DOUBLE` --> Features whose type is DOUBLE.
   *   * `labels.active = yes AND labels.env = prod` --> Features having both
   *       (active: yes) and (env: prod) labels.
   *   * `labels.env: *` --> Any Feature which has a label with `env` as the
   *     key.
   * @param {number} request.pageSize
   *   The maximum number of Features to return. The service may return fewer
   *   than this value. If unspecified, at most 100 Features will be returned.
   *   The maximum value is 100; any value greater than 100 will be coerced to
   *   100.
   * @param {string} request.pageToken
   *   A page token, received from a previous
   *   {@link google.cloud.aiplatform.v1beta1.FeaturestoreService.SearchFeatures|FeaturestoreService.SearchFeatures} call.
   *   Provide this to retrieve the subsequent page.
   *
   *   When paginating, all other parameters provided to
   *   {@link google.cloud.aiplatform.v1beta1.FeaturestoreService.SearchFeatures|FeaturestoreService.SearchFeatures}, except `page_size`, must
   *   match the call that provided the page token.
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
   * @returns {Stream}
   *   An object stream which emits an object representing [Feature]{@link google.cloud.aiplatform.v1beta1.Feature} on 'data' event.
   *   The client library will perform auto-pagination by default: it will call the API as many
   *   times as needed. Note that it can affect your quota.
   *   We recommend using `searchFeaturesAsync()`
   *   method described below for async iteration which you can stop as needed.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination)
   *   for more details and examples.
   */
  searchFeaturesStream(
    request?: protos.google.cloud.aiplatform.v1beta1.ISearchFeaturesRequest,
    options?: CallOptions
  ): Transform {
    request = request || {};
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers['x-goog-request-params'] =
      gax.routingHeader.fromParams({
        location: request.location || '',
      });
    const callSettings = new gax.CallSettings(options);
    this.initialize();
    return this.descriptors.page.searchFeatures.createStream(
      this.innerApiCalls.searchFeatures as gax.GaxCall,
      request,
      callSettings
    );
  }

  /**
   * Equivalent to `searchFeatures`, but returns an iterable object.
   *
   * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
   * @param {Object} request
   *   The request object that will be sent.
   * @param {string} request.location
   *   Required. The resource name of the Location to search Features.
   *   Format:
   *   `projects/{project}/locations/{location}`
   * @param {string} request.query
   *   Query string that is a conjunction of field-restricted queries and/or
   *   field-restricted filters.  Field-restricted queries and filters can be
   *   combined using `AND` to form a conjunction.
   *
   *   A field query is in the form FIELD:QUERY. This implicitly checks if QUERY
   *   exists as a substring within Feature's FIELD. The QUERY
   *   and the FIELD are converted to a sequence of words (i.e. tokens) for
   *   comparison. This is done by:
   *
   *     * Removing leading/trailing whitespace and tokenizing the search value.
   *     Characters that are not one of alphanumeric [a-zA-Z0-9], underscore [_],
   *     or asterisk [*] are treated as delimiters for tokens. (*) is treated as a
   *     wildcard that matches characters within a token.
   *     * Ignoring case.
   *     * Prepending an asterisk to the first and appending an asterisk to the
   *     last token in QUERY.
   *
   *   A QUERY must be either a singular token or a phrase. A phrase is one or
   *   multiple words enclosed in double quotation marks ("). With phrases, the
   *   order of the words is important. Words in the phrase must be matching in
   *   order and consecutively.
   *
   *   Supported FIELDs for field-restricted queries:
   *
   *   * `feature_id`
   *   * `description`
   *   * `entity_type_id`
   *
   *   Examples:
   *
   *   * `feature_id: foo` --> Matches a Feature with ID containing the substring
   *   `foo` (eg. `foo`, `foofeature`, `barfoo`).
   *   * `feature_id: foo*feature` --> Matches a Feature with ID containing the
   *   substring `foo*feature` (eg. `foobarfeature`).
   *   * `feature_id: foo AND description: bar` --> Matches a Feature with ID
   *   containing the substring `foo` and description containing the substring
   *   `bar`.
   *
   *
   *   Besides field queries, the following exact-match filters are
   *   supported. The exact-match filters do not support wildcards. Unlike
   *   field-restricted queries, exact-match filters are case-sensitive.
   *
   *   * `feature_id`: Supports = comparisons.
   *   * `description`: Supports = comparisons. Multi-token filters should be
   *   enclosed in quotes.
   *   * `entity_type_id`: Supports = comparisons.
   *   * `value_type`: Supports = and != comparisons.
   *   * `labels`: Supports key-value equality as well as key presence.
   *   * `featurestore_id`: Supports = comparisons.
   *
   *   Examples:
   *   * `description = "foo bar"` --> Any Feature with description exactly equal
   *   to `foo bar`
   *   * `value_type = DOUBLE` --> Features whose type is DOUBLE.
   *   * `labels.active = yes AND labels.env = prod` --> Features having both
   *       (active: yes) and (env: prod) labels.
   *   * `labels.env: *` --> Any Feature which has a label with `env` as the
   *     key.
   * @param {number} request.pageSize
   *   The maximum number of Features to return. The service may return fewer
   *   than this value. If unspecified, at most 100 Features will be returned.
   *   The maximum value is 100; any value greater than 100 will be coerced to
   *   100.
   * @param {string} request.pageToken
   *   A page token, received from a previous
   *   {@link google.cloud.aiplatform.v1beta1.FeaturestoreService.SearchFeatures|FeaturestoreService.SearchFeatures} call.
   *   Provide this to retrieve the subsequent page.
   *
   *   When paginating, all other parameters provided to
   *   {@link google.cloud.aiplatform.v1beta1.FeaturestoreService.SearchFeatures|FeaturestoreService.SearchFeatures}, except `page_size`, must
   *   match the call that provided the page token.
   * @param {object} [options]
   *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
   * @returns {Object}
   *   An iterable Object that allows [async iteration](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols).
   *   When you iterate the returned iterable, each element will be an object representing
   *   [Feature]{@link google.cloud.aiplatform.v1beta1.Feature}. The API will be called under the hood as needed, once per the page,
   *   so you can stop the iteration when you don't need more results.
   *   Please see the
   *   [documentation](https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination)
   *   for more details and examples.
   * @example
   * const iterable = client.searchFeaturesAsync(request);
   * for await (const response of iterable) {
   *   // process response
   * }
   */
  searchFeaturesAsync(
    request?: protos.google.cloud.aiplatform.v1beta1.ISearchFeaturesRequest,
    options?: CallOptions
  ): AsyncIterable<protos.google.cloud.aiplatform.v1beta1.IFeature> {
    request = request || {};
    options = options || {};
    options.otherArgs = options.otherArgs || {};
    options.otherArgs.headers = options.otherArgs.headers || {};
    options.otherArgs.headers['x-goog-request-params'] =
      gax.routingHeader.fromParams({
        location: request.location || '',
      });
    options = options || {};
    const callSettings = new gax.CallSettings(options);
    this.initialize();
    return this.descriptors.page.searchFeatures.asyncIterate(
      this.innerApiCalls['searchFeatures'] as GaxCall,
      request as unknown as RequestType,
      callSettings
    ) as AsyncIterable<protos.google.cloud.aiplatform.v1beta1.IFeature>;
  }
  // --------------------
  // -- Path templates --
  // --------------------

  /**
   * Return a fully-qualified annotation resource name string.
   *
   * @param {string} project
   * @param {string} location
   * @param {string} dataset
   * @param {string} data_item
   * @param {string} annotation
   * @returns {string} Resource name string.
   */
  annotationPath(
    project: string,
    location: string,
    dataset: string,
    dataItem: string,
    annotation: string
  ) {
    return this.pathTemplates.annotationPathTemplate.render({
      project: project,
      location: location,
      dataset: dataset,
      data_item: dataItem,
      annotation: annotation,
    });
  }

  /**
   * Parse the project from Annotation resource.
   *
   * @param {string} annotationName
   *   A fully-qualified path representing Annotation resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromAnnotationName(annotationName: string) {
    return this.pathTemplates.annotationPathTemplate.match(annotationName)
      .project;
  }

  /**
   * Parse the location from Annotation resource.
   *
   * @param {string} annotationName
   *   A fully-qualified path representing Annotation resource.
   * @returns {string} A string representing the location.
   */
  matchLocationFromAnnotationName(annotationName: string) {
    return this.pathTemplates.annotationPathTemplate.match(annotationName)
      .location;
  }

  /**
   * Parse the dataset from Annotation resource.
   *
   * @param {string} annotationName
   *   A fully-qualified path representing Annotation resource.
   * @returns {string} A string representing the dataset.
   */
  matchDatasetFromAnnotationName(annotationName: string) {
    return this.pathTemplates.annotationPathTemplate.match(annotationName)
      .dataset;
  }

  /**
   * Parse the data_item from Annotation resource.
   *
   * @param {string} annotationName
   *   A fully-qualified path representing Annotation resource.
   * @returns {string} A string representing the data_item.
   */
  matchDataItemFromAnnotationName(annotationName: string) {
    return this.pathTemplates.annotationPathTemplate.match(annotationName)
      .data_item;
  }

  /**
   * Parse the annotation from Annotation resource.
   *
   * @param {string} annotationName
   *   A fully-qualified path representing Annotation resource.
   * @returns {string} A string representing the annotation.
   */
  matchAnnotationFromAnnotationName(annotationName: string) {
    return this.pathTemplates.annotationPathTemplate.match(annotationName)
      .annotation;
  }

  /**
   * Return a fully-qualified annotationSpec resource name string.
   *
   * @param {string} project
   * @param {string} location
   * @param {string} dataset
   * @param {string} annotation_spec
   * @returns {string} Resource name string.
   */
  annotationSpecPath(
    project: string,
    location: string,
    dataset: string,
    annotationSpec: string
  ) {
    return this.pathTemplates.annotationSpecPathTemplate.render({
      project: project,
      location: location,
      dataset: dataset,
      annotation_spec: annotationSpec,
    });
  }

  /**
   * Parse the project from AnnotationSpec resource.
   *
   * @param {string} annotationSpecName
   *   A fully-qualified path representing AnnotationSpec resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromAnnotationSpecName(annotationSpecName: string) {
    return this.pathTemplates.annotationSpecPathTemplate.match(
      annotationSpecName
    ).project;
  }

  /**
   * Parse the location from AnnotationSpec resource.
   *
   * @param {string} annotationSpecName
   *   A fully-qualified path representing AnnotationSpec resource.
   * @returns {string} A string representing the location.
   */
  matchLocationFromAnnotationSpecName(annotationSpecName: string) {
    return this.pathTemplates.annotationSpecPathTemplate.match(
      annotationSpecName
    ).location;
  }

  /**
   * Parse the dataset from AnnotationSpec resource.
   *
   * @param {string} annotationSpecName
   *   A fully-qualified path representing AnnotationSpec resource.
   * @returns {string} A string representing the dataset.
   */
  matchDatasetFromAnnotationSpecName(annotationSpecName: string) {
    return this.pathTemplates.annotationSpecPathTemplate.match(
      annotationSpecName
    ).dataset;
  }

  /**
   * Parse the annotation_spec from AnnotationSpec resource.
   *
   * @param {string} annotationSpecName
   *   A fully-qualified path representing AnnotationSpec resource.
   * @returns {string} A string representing the annotation_spec.
   */
  matchAnnotationSpecFromAnnotationSpecName(annotationSpecName: string) {
    return this.pathTemplates.annotationSpecPathTemplate.match(
      annotationSpecName
    ).annotation_spec;
  }

  /**
   * Return a fully-qualified artifact resource name string.
   *
   * @param {string} project
   * @param {string} location
   * @param {string} metadata_store
   * @param {string} artifact
   * @returns {string} Resource name string.
   */
  artifactPath(
    project: string,
    location: string,
    metadataStore: string,
    artifact: string
  ) {
    return this.pathTemplates.artifactPathTemplate.render({
      project: project,
      location: location,
      metadata_store: metadataStore,
      artifact: artifact,
    });
  }

  /**
   * Parse the project from Artifact resource.
   *
   * @param {string} artifactName
   *   A fully-qualified path representing Artifact resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromArtifactName(artifactName: string) {
    return this.pathTemplates.artifactPathTemplate.match(artifactName).project;
  }

  /**
   * Parse the location from Artifact resource.
   *
   * @param {string} artifactName
   *   A fully-qualified path representing Artifact resource.
   * @returns {string} A string representing the location.
   */
  matchLocationFromArtifactName(artifactName: string) {
    return this.pathTemplates.artifactPathTemplate.match(artifactName).location;
  }

  /**
   * Parse the metadata_store from Artifact resource.
   *
   * @param {string} artifactName
   *   A fully-qualified path representing Artifact resource.
   * @returns {string} A string representing the metadata_store.
   */
  matchMetadataStoreFromArtifactName(artifactName: string) {
    return this.pathTemplates.artifactPathTemplate.match(artifactName)
      .metadata_store;
  }

  /**
   * Parse the artifact from Artifact resource.
   *
   * @param {string} artifactName
   *   A fully-qualified path representing Artifact resource.
   * @returns {string} A string representing the artifact.
   */
  matchArtifactFromArtifactName(artifactName: string) {
    return this.pathTemplates.artifactPathTemplate.match(artifactName).artifact;
  }

  /**
   * Return a fully-qualified batchPredictionJob resource name string.
   *
   * @param {string} project
   * @param {string} location
   * @param {string} batch_prediction_job
   * @returns {string} Resource name string.
   */
  batchPredictionJobPath(
    project: string,
    location: string,
    batchPredictionJob: string
  ) {
    return this.pathTemplates.batchPredictionJobPathTemplate.render({
      project: project,
      location: location,
      batch_prediction_job: batchPredictionJob,
    });
  }

  /**
   * Parse the project from BatchPredictionJob resource.
   *
   * @param {string} batchPredictionJobName
   *   A fully-qualified path representing BatchPredictionJob resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromBatchPredictionJobName(batchPredictionJobName: string) {
    return this.pathTemplates.batchPredictionJobPathTemplate.match(
      batchPredictionJobName
    ).project;
  }

  /**
   * Parse the location from BatchPredictionJob resource.
   *
   * @param {string} batchPredictionJobName
   *   A fully-qualified path representing BatchPredictionJob resource.
   * @returns {string} A string representing the location.
   */
  matchLocationFromBatchPredictionJobName(batchPredictionJobName: string) {
    return this.pathTemplates.batchPredictionJobPathTemplate.match(
      batchPredictionJobName
    ).location;
  }

  /**
   * Parse the batch_prediction_job from BatchPredictionJob resource.
   *
   * @param {string} batchPredictionJobName
   *   A fully-qualified path representing BatchPredictionJob resource.
   * @returns {string} A string representing the batch_prediction_job.
   */
  matchBatchPredictionJobFromBatchPredictionJobName(
    batchPredictionJobName: string
  ) {
    return this.pathTemplates.batchPredictionJobPathTemplate.match(
      batchPredictionJobName
    ).batch_prediction_job;
  }

  /**
   * Return a fully-qualified context resource name string.
   *
   * @param {string} project
   * @param {string} location
   * @param {string} metadata_store
   * @param {string} context
   * @returns {string} Resource name string.
   */
  contextPath(
    project: string,
    location: string,
    metadataStore: string,
    context: string
  ) {
    return this.pathTemplates.contextPathTemplate.render({
      project: project,
      location: location,
      metadata_store: metadataStore,
      context: context,
    });
  }

  /**
   * Parse the project from Context resource.
   *
   * @param {string} contextName
   *   A fully-qualified path representing Context resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromContextName(contextName: string) {
    return this.pathTemplates.contextPathTemplate.match(contextName).project;
  }

  /**
   * Parse the location from Context resource.
   *
   * @param {string} contextName
   *   A fully-qualified path representing Context resource.
   * @returns {string} A string representing the location.
   */
  matchLocationFromContextName(contextName: string) {
    return this.pathTemplates.contextPathTemplate.match(contextName).location;
  }

  /**
   * Parse the metadata_store from Context resource.
   *
   * @param {string} contextName
   *   A fully-qualified path representing Context resource.
   * @returns {string} A string representing the metadata_store.
   */
  matchMetadataStoreFromContextName(contextName: string) {
    return this.pathTemplates.contextPathTemplate.match(contextName)
      .metadata_store;
  }

  /**
   * Parse the context from Context resource.
   *
   * @param {string} contextName
   *   A fully-qualified path representing Context resource.
   * @returns {string} A string representing the context.
   */
  matchContextFromContextName(contextName: string) {
    return this.pathTemplates.contextPathTemplate.match(contextName).context;
  }

  /**
   * Return a fully-qualified customJob resource name string.
   *
   * @param {string} project
   * @param {string} location
   * @param {string} custom_job
   * @returns {string} Resource name string.
   */
  customJobPath(project: string, location: string, customJob: string) {
    return this.pathTemplates.customJobPathTemplate.render({
      project: project,
      location: location,
      custom_job: customJob,
    });
  }

  /**
   * Parse the project from CustomJob resource.
   *
   * @param {string} customJobName
   *   A fully-qualified path representing CustomJob resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromCustomJobName(customJobName: string) {
    return this.pathTemplates.customJobPathTemplate.match(customJobName)
      .project;
  }

  /**
   * Parse the location from CustomJob resource.
   *
   * @param {string} customJobName
   *   A fully-qualified path representing CustomJob resource.
   * @returns {string} A string representing the location.
   */
  matchLocationFromCustomJobName(customJobName: string) {
    return this.pathTemplates.customJobPathTemplate.match(customJobName)
      .location;
  }

  /**
   * Parse the custom_job from CustomJob resource.
   *
   * @param {string} customJobName
   *   A fully-qualified path representing CustomJob resource.
   * @returns {string} A string representing the custom_job.
   */
  matchCustomJobFromCustomJobName(customJobName: string) {
    return this.pathTemplates.customJobPathTemplate.match(customJobName)
      .custom_job;
  }

  /**
   * Return a fully-qualified dataItem resource name string.
   *
   * @param {string} project
   * @param {string} location
   * @param {string} dataset
   * @param {string} data_item
   * @returns {string} Resource name string.
   */
  dataItemPath(
    project: string,
    location: string,
    dataset: string,
    dataItem: string
  ) {
    return this.pathTemplates.dataItemPathTemplate.render({
      project: project,
      location: location,
      dataset: dataset,
      data_item: dataItem,
    });
  }

  /**
   * Parse the project from DataItem resource.
   *
   * @param {string} dataItemName
   *   A fully-qualified path representing DataItem resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromDataItemName(dataItemName: string) {
    return this.pathTemplates.dataItemPathTemplate.match(dataItemName).project;
  }

  /**
   * Parse the location from DataItem resource.
   *
   * @param {string} dataItemName
   *   A fully-qualified path representing DataItem resource.
   * @returns {string} A string representing the location.
   */
  matchLocationFromDataItemName(dataItemName: string) {
    return this.pathTemplates.dataItemPathTemplate.match(dataItemName).location;
  }

  /**
   * Parse the dataset from DataItem resource.
   *
   * @param {string} dataItemName
   *   A fully-qualified path representing DataItem resource.
   * @returns {string} A string representing the dataset.
   */
  matchDatasetFromDataItemName(dataItemName: string) {
    return this.pathTemplates.dataItemPathTemplate.match(dataItemName).dataset;
  }

  /**
   * Parse the data_item from DataItem resource.
   *
   * @param {string} dataItemName
   *   A fully-qualified path representing DataItem resource.
   * @returns {string} A string representing the data_item.
   */
  matchDataItemFromDataItemName(dataItemName: string) {
    return this.pathTemplates.dataItemPathTemplate.match(dataItemName)
      .data_item;
  }

  /**
   * Return a fully-qualified dataLabelingJob resource name string.
   *
   * @param {string} project
   * @param {string} location
   * @param {string} data_labeling_job
   * @returns {string} Resource name string.
   */
  dataLabelingJobPath(
    project: string,
    location: string,
    dataLabelingJob: string
  ) {
    return this.pathTemplates.dataLabelingJobPathTemplate.render({
      project: project,
      location: location,
      data_labeling_job: dataLabelingJob,
    });
  }

  /**
   * Parse the project from DataLabelingJob resource.
   *
   * @param {string} dataLabelingJobName
   *   A fully-qualified path representing DataLabelingJob resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromDataLabelingJobName(dataLabelingJobName: string) {
    return this.pathTemplates.dataLabelingJobPathTemplate.match(
      dataLabelingJobName
    ).project;
  }

  /**
   * Parse the location from DataLabelingJob resource.
   *
   * @param {string} dataLabelingJobName
   *   A fully-qualified path representing DataLabelingJob resource.
   * @returns {string} A string representing the location.
   */
  matchLocationFromDataLabelingJobName(dataLabelingJobName: string) {
    return this.pathTemplates.dataLabelingJobPathTemplate.match(
      dataLabelingJobName
    ).location;
  }

  /**
   * Parse the data_labeling_job from DataLabelingJob resource.
   *
   * @param {string} dataLabelingJobName
   *   A fully-qualified path representing DataLabelingJob resource.
   * @returns {string} A string representing the data_labeling_job.
   */
  matchDataLabelingJobFromDataLabelingJobName(dataLabelingJobName: string) {
    return this.pathTemplates.dataLabelingJobPathTemplate.match(
      dataLabelingJobName
    ).data_labeling_job;
  }

  /**
   * Return a fully-qualified dataset resource name string.
   *
   * @param {string} project
   * @param {string} location
   * @param {string} dataset
   * @returns {string} Resource name string.
   */
  datasetPath(project: string, location: string, dataset: string) {
    return this.pathTemplates.datasetPathTemplate.render({
      project: project,
      location: location,
      dataset: dataset,
    });
  }

  /**
   * Parse the project from Dataset resource.
   *
   * @param {string} datasetName
   *   A fully-qualified path representing Dataset resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromDatasetName(datasetName: string) {
    return this.pathTemplates.datasetPathTemplate.match(datasetName).project;
  }

  /**
   * Parse the location from Dataset resource.
   *
   * @param {string} datasetName
   *   A fully-qualified path representing Dataset resource.
   * @returns {string} A string representing the location.
   */
  matchLocationFromDatasetName(datasetName: string) {
    return this.pathTemplates.datasetPathTemplate.match(datasetName).location;
  }

  /**
   * Parse the dataset from Dataset resource.
   *
   * @param {string} datasetName
   *   A fully-qualified path representing Dataset resource.
   * @returns {string} A string representing the dataset.
   */
  matchDatasetFromDatasetName(datasetName: string) {
    return this.pathTemplates.datasetPathTemplate.match(datasetName).dataset;
  }

  /**
   * Return a fully-qualified endpoint resource name string.
   *
   * @param {string} project
   * @param {string} location
   * @param {string} endpoint
   * @returns {string} Resource name string.
   */
  endpointPath(project: string, location: string, endpoint: string) {
    return this.pathTemplates.endpointPathTemplate.render({
      project: project,
      location: location,
      endpoint: endpoint,
    });
  }

  /**
   * Parse the project from Endpoint resource.
   *
   * @param {string} endpointName
   *   A fully-qualified path representing Endpoint resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromEndpointName(endpointName: string) {
    return this.pathTemplates.endpointPathTemplate.match(endpointName).project;
  }

  /**
   * Parse the location from Endpoint resource.
   *
   * @param {string} endpointName
   *   A fully-qualified path representing Endpoint resource.
   * @returns {string} A string representing the location.
   */
  matchLocationFromEndpointName(endpointName: string) {
    return this.pathTemplates.endpointPathTemplate.match(endpointName).location;
  }

  /**
   * Parse the endpoint from Endpoint resource.
   *
   * @param {string} endpointName
   *   A fully-qualified path representing Endpoint resource.
   * @returns {string} A string representing the endpoint.
   */
  matchEndpointFromEndpointName(endpointName: string) {
    return this.pathTemplates.endpointPathTemplate.match(endpointName).endpoint;
  }

  /**
   * Return a fully-qualified entityType resource name string.
   *
   * @param {string} project
   * @param {string} location
   * @param {string} featurestore
   * @param {string} entity_type
   * @returns {string} Resource name string.
   */
  entityTypePath(
    project: string,
    location: string,
    featurestore: string,
    entityType: string
  ) {
    return this.pathTemplates.entityTypePathTemplate.render({
      project: project,
      location: location,
      featurestore: featurestore,
      entity_type: entityType,
    });
  }

  /**
   * Parse the project from EntityType resource.
   *
   * @param {string} entityTypeName
   *   A fully-qualified path representing EntityType resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromEntityTypeName(entityTypeName: string) {
    return this.pathTemplates.entityTypePathTemplate.match(entityTypeName)
      .project;
  }

  /**
   * Parse the location from EntityType resource.
   *
   * @param {string} entityTypeName
   *   A fully-qualified path representing EntityType resource.
   * @returns {string} A string representing the location.
   */
  matchLocationFromEntityTypeName(entityTypeName: string) {
    return this.pathTemplates.entityTypePathTemplate.match(entityTypeName)
      .location;
  }

  /**
   * Parse the featurestore from EntityType resource.
   *
   * @param {string} entityTypeName
   *   A fully-qualified path representing EntityType resource.
   * @returns {string} A string representing the featurestore.
   */
  matchFeaturestoreFromEntityTypeName(entityTypeName: string) {
    return this.pathTemplates.entityTypePathTemplate.match(entityTypeName)
      .featurestore;
  }

  /**
   * Parse the entity_type from EntityType resource.
   *
   * @param {string} entityTypeName
   *   A fully-qualified path representing EntityType resource.
   * @returns {string} A string representing the entity_type.
   */
  matchEntityTypeFromEntityTypeName(entityTypeName: string) {
    return this.pathTemplates.entityTypePathTemplate.match(entityTypeName)
      .entity_type;
  }

  /**
   * Return a fully-qualified execution resource name string.
   *
   * @param {string} project
   * @param {string} location
   * @param {string} metadata_store
   * @param {string} execution
   * @returns {string} Resource name string.
   */
  executionPath(
    project: string,
    location: string,
    metadataStore: string,
    execution: string
  ) {
    return this.pathTemplates.executionPathTemplate.render({
      project: project,
      location: location,
      metadata_store: metadataStore,
      execution: execution,
    });
  }

  /**
   * Parse the project from Execution resource.
   *
   * @param {string} executionName
   *   A fully-qualified path representing Execution resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromExecutionName(executionName: string) {
    return this.pathTemplates.executionPathTemplate.match(executionName)
      .project;
  }

  /**
   * Parse the location from Execution resource.
   *
   * @param {string} executionName
   *   A fully-qualified path representing Execution resource.
   * @returns {string} A string representing the location.
   */
  matchLocationFromExecutionName(executionName: string) {
    return this.pathTemplates.executionPathTemplate.match(executionName)
      .location;
  }

  /**
   * Parse the metadata_store from Execution resource.
   *
   * @param {string} executionName
   *   A fully-qualified path representing Execution resource.
   * @returns {string} A string representing the metadata_store.
   */
  matchMetadataStoreFromExecutionName(executionName: string) {
    return this.pathTemplates.executionPathTemplate.match(executionName)
      .metadata_store;
  }

  /**
   * Parse the execution from Execution resource.
   *
   * @param {string} executionName
   *   A fully-qualified path representing Execution resource.
   * @returns {string} A string representing the execution.
   */
  matchExecutionFromExecutionName(executionName: string) {
    return this.pathTemplates.executionPathTemplate.match(executionName)
      .execution;
  }

  /**
   * Return a fully-qualified feature resource name string.
   *
   * @param {string} project
   * @param {string} location
   * @param {string} featurestore
   * @param {string} entity_type
   * @param {string} feature
   * @returns {string} Resource name string.
   */
  featurePath(
    project: string,
    location: string,
    featurestore: string,
    entityType: string,
    feature: string
  ) {
    return this.pathTemplates.featurePathTemplate.render({
      project: project,
      location: location,
      featurestore: featurestore,
      entity_type: entityType,
      feature: feature,
    });
  }

  /**
   * Parse the project from Feature resource.
   *
   * @param {string} featureName
   *   A fully-qualified path representing Feature resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromFeatureName(featureName: string) {
    return this.pathTemplates.featurePathTemplate.match(featureName).project;
  }

  /**
   * Parse the location from Feature resource.
   *
   * @param {string} featureName
   *   A fully-qualified path representing Feature resource.
   * @returns {string} A string representing the location.
   */
  matchLocationFromFeatureName(featureName: string) {
    return this.pathTemplates.featurePathTemplate.match(featureName).location;
  }

  /**
   * Parse the featurestore from Feature resource.
   *
   * @param {string} featureName
   *   A fully-qualified path representing Feature resource.
   * @returns {string} A string representing the featurestore.
   */
  matchFeaturestoreFromFeatureName(featureName: string) {
    return this.pathTemplates.featurePathTemplate.match(featureName)
      .featurestore;
  }

  /**
   * Parse the entity_type from Feature resource.
   *
   * @param {string} featureName
   *   A fully-qualified path representing Feature resource.
   * @returns {string} A string representing the entity_type.
   */
  matchEntityTypeFromFeatureName(featureName: string) {
    return this.pathTemplates.featurePathTemplate.match(featureName)
      .entity_type;
  }

  /**
   * Parse the feature from Feature resource.
   *
   * @param {string} featureName
   *   A fully-qualified path representing Feature resource.
   * @returns {string} A string representing the feature.
   */
  matchFeatureFromFeatureName(featureName: string) {
    return this.pathTemplates.featurePathTemplate.match(featureName).feature;
  }

  /**
   * Return a fully-qualified featurestore resource name string.
   *
   * @param {string} project
   * @param {string} location
   * @param {string} featurestore
   * @returns {string} Resource name string.
   */
  featurestorePath(project: string, location: string, featurestore: string) {
    return this.pathTemplates.featurestorePathTemplate.render({
      project: project,
      location: location,
      featurestore: featurestore,
    });
  }

  /**
   * Parse the project from Featurestore resource.
   *
   * @param {string} featurestoreName
   *   A fully-qualified path representing Featurestore resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromFeaturestoreName(featurestoreName: string) {
    return this.pathTemplates.featurestorePathTemplate.match(featurestoreName)
      .project;
  }

  /**
   * Parse the location from Featurestore resource.
   *
   * @param {string} featurestoreName
   *   A fully-qualified path representing Featurestore resource.
   * @returns {string} A string representing the location.
   */
  matchLocationFromFeaturestoreName(featurestoreName: string) {
    return this.pathTemplates.featurestorePathTemplate.match(featurestoreName)
      .location;
  }

  /**
   * Parse the featurestore from Featurestore resource.
   *
   * @param {string} featurestoreName
   *   A fully-qualified path representing Featurestore resource.
   * @returns {string} A string representing the featurestore.
   */
  matchFeaturestoreFromFeaturestoreName(featurestoreName: string) {
    return this.pathTemplates.featurestorePathTemplate.match(featurestoreName)
      .featurestore;
  }

  /**
   * Return a fully-qualified hyperparameterTuningJob resource name string.
   *
   * @param {string} project
   * @param {string} location
   * @param {string} hyperparameter_tuning_job
   * @returns {string} Resource name string.
   */
  hyperparameterTuningJobPath(
    project: string,
    location: string,
    hyperparameterTuningJob: string
  ) {
    return this.pathTemplates.hyperparameterTuningJobPathTemplate.render({
      project: project,
      location: location,
      hyperparameter_tuning_job: hyperparameterTuningJob,
    });
  }

  /**
   * Parse the project from HyperparameterTuningJob resource.
   *
   * @param {string} hyperparameterTuningJobName
   *   A fully-qualified path representing HyperparameterTuningJob resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromHyperparameterTuningJobName(
    hyperparameterTuningJobName: string
  ) {
    return this.pathTemplates.hyperparameterTuningJobPathTemplate.match(
      hyperparameterTuningJobName
    ).project;
  }

  /**
   * Parse the location from HyperparameterTuningJob resource.
   *
   * @param {string} hyperparameterTuningJobName
   *   A fully-qualified path representing HyperparameterTuningJob resource.
   * @returns {string} A string representing the location.
   */
  matchLocationFromHyperparameterTuningJobName(
    hyperparameterTuningJobName: string
  ) {
    return this.pathTemplates.hyperparameterTuningJobPathTemplate.match(
      hyperparameterTuningJobName
    ).location;
  }

  /**
   * Parse the hyperparameter_tuning_job from HyperparameterTuningJob resource.
   *
   * @param {string} hyperparameterTuningJobName
   *   A fully-qualified path representing HyperparameterTuningJob resource.
   * @returns {string} A string representing the hyperparameter_tuning_job.
   */
  matchHyperparameterTuningJobFromHyperparameterTuningJobName(
    hyperparameterTuningJobName: string
  ) {
    return this.pathTemplates.hyperparameterTuningJobPathTemplate.match(
      hyperparameterTuningJobName
    ).hyperparameter_tuning_job;
  }

  /**
   * Return a fully-qualified index resource name string.
   *
   * @param {string} project
   * @param {string} location
   * @param {string} index
   * @returns {string} Resource name string.
   */
  indexPath(project: string, location: string, index: string) {
    return this.pathTemplates.indexPathTemplate.render({
      project: project,
      location: location,
      index: index,
    });
  }

  /**
   * Parse the project from Index resource.
   *
   * @param {string} indexName
   *   A fully-qualified path representing Index resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromIndexName(indexName: string) {
    return this.pathTemplates.indexPathTemplate.match(indexName).project;
  }

  /**
   * Parse the location from Index resource.
   *
   * @param {string} indexName
   *   A fully-qualified path representing Index resource.
   * @returns {string} A string representing the location.
   */
  matchLocationFromIndexName(indexName: string) {
    return this.pathTemplates.indexPathTemplate.match(indexName).location;
  }

  /**
   * Parse the index from Index resource.
   *
   * @param {string} indexName
   *   A fully-qualified path representing Index resource.
   * @returns {string} A string representing the index.
   */
  matchIndexFromIndexName(indexName: string) {
    return this.pathTemplates.indexPathTemplate.match(indexName).index;
  }

  /**
   * Return a fully-qualified indexEndpoint resource name string.
   *
   * @param {string} project
   * @param {string} location
   * @param {string} index_endpoint
   * @returns {string} Resource name string.
   */
  indexEndpointPath(project: string, location: string, indexEndpoint: string) {
    return this.pathTemplates.indexEndpointPathTemplate.render({
      project: project,
      location: location,
      index_endpoint: indexEndpoint,
    });
  }

  /**
   * Parse the project from IndexEndpoint resource.
   *
   * @param {string} indexEndpointName
   *   A fully-qualified path representing IndexEndpoint resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromIndexEndpointName(indexEndpointName: string) {
    return this.pathTemplates.indexEndpointPathTemplate.match(indexEndpointName)
      .project;
  }

  /**
   * Parse the location from IndexEndpoint resource.
   *
   * @param {string} indexEndpointName
   *   A fully-qualified path representing IndexEndpoint resource.
   * @returns {string} A string representing the location.
   */
  matchLocationFromIndexEndpointName(indexEndpointName: string) {
    return this.pathTemplates.indexEndpointPathTemplate.match(indexEndpointName)
      .location;
  }

  /**
   * Parse the index_endpoint from IndexEndpoint resource.
   *
   * @param {string} indexEndpointName
   *   A fully-qualified path representing IndexEndpoint resource.
   * @returns {string} A string representing the index_endpoint.
   */
  matchIndexEndpointFromIndexEndpointName(indexEndpointName: string) {
    return this.pathTemplates.indexEndpointPathTemplate.match(indexEndpointName)
      .index_endpoint;
  }

  /**
   * Return a fully-qualified location resource name string.
   *
   * @param {string} project
   * @param {string} location
   * @returns {string} Resource name string.
   */
  locationPath(project: string, location: string) {
    return this.pathTemplates.locationPathTemplate.render({
      project: project,
      location: location,
    });
  }

  /**
   * Parse the project from Location resource.
   *
   * @param {string} locationName
   *   A fully-qualified path representing Location resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromLocationName(locationName: string) {
    return this.pathTemplates.locationPathTemplate.match(locationName).project;
  }

  /**
   * Parse the location from Location resource.
   *
   * @param {string} locationName
   *   A fully-qualified path representing Location resource.
   * @returns {string} A string representing the location.
   */
  matchLocationFromLocationName(locationName: string) {
    return this.pathTemplates.locationPathTemplate.match(locationName).location;
  }

  /**
   * Return a fully-qualified metadataSchema resource name string.
   *
   * @param {string} project
   * @param {string} location
   * @param {string} metadata_store
   * @param {string} metadata_schema
   * @returns {string} Resource name string.
   */
  metadataSchemaPath(
    project: string,
    location: string,
    metadataStore: string,
    metadataSchema: string
  ) {
    return this.pathTemplates.metadataSchemaPathTemplate.render({
      project: project,
      location: location,
      metadata_store: metadataStore,
      metadata_schema: metadataSchema,
    });
  }

  /**
   * Parse the project from MetadataSchema resource.
   *
   * @param {string} metadataSchemaName
   *   A fully-qualified path representing MetadataSchema resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromMetadataSchemaName(metadataSchemaName: string) {
    return this.pathTemplates.metadataSchemaPathTemplate.match(
      metadataSchemaName
    ).project;
  }

  /**
   * Parse the location from MetadataSchema resource.
   *
   * @param {string} metadataSchemaName
   *   A fully-qualified path representing MetadataSchema resource.
   * @returns {string} A string representing the location.
   */
  matchLocationFromMetadataSchemaName(metadataSchemaName: string) {
    return this.pathTemplates.metadataSchemaPathTemplate.match(
      metadataSchemaName
    ).location;
  }

  /**
   * Parse the metadata_store from MetadataSchema resource.
   *
   * @param {string} metadataSchemaName
   *   A fully-qualified path representing MetadataSchema resource.
   * @returns {string} A string representing the metadata_store.
   */
  matchMetadataStoreFromMetadataSchemaName(metadataSchemaName: string) {
    return this.pathTemplates.metadataSchemaPathTemplate.match(
      metadataSchemaName
    ).metadata_store;
  }

  /**
   * Parse the metadata_schema from MetadataSchema resource.
   *
   * @param {string} metadataSchemaName
   *   A fully-qualified path representing MetadataSchema resource.
   * @returns {string} A string representing the metadata_schema.
   */
  matchMetadataSchemaFromMetadataSchemaName(metadataSchemaName: string) {
    return this.pathTemplates.metadataSchemaPathTemplate.match(
      metadataSchemaName
    ).metadata_schema;
  }

  /**
   * Return a fully-qualified metadataStore resource name string.
   *
   * @param {string} project
   * @param {string} location
   * @param {string} metadata_store
   * @returns {string} Resource name string.
   */
  metadataStorePath(project: string, location: string, metadataStore: string) {
    return this.pathTemplates.metadataStorePathTemplate.render({
      project: project,
      location: location,
      metadata_store: metadataStore,
    });
  }

  /**
   * Parse the project from MetadataStore resource.
   *
   * @param {string} metadataStoreName
   *   A fully-qualified path representing MetadataStore resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromMetadataStoreName(metadataStoreName: string) {
    return this.pathTemplates.metadataStorePathTemplate.match(metadataStoreName)
      .project;
  }

  /**
   * Parse the location from MetadataStore resource.
   *
   * @param {string} metadataStoreName
   *   A fully-qualified path representing MetadataStore resource.
   * @returns {string} A string representing the location.
   */
  matchLocationFromMetadataStoreName(metadataStoreName: string) {
    return this.pathTemplates.metadataStorePathTemplate.match(metadataStoreName)
      .location;
  }

  /**
   * Parse the metadata_store from MetadataStore resource.
   *
   * @param {string} metadataStoreName
   *   A fully-qualified path representing MetadataStore resource.
   * @returns {string} A string representing the metadata_store.
   */
  matchMetadataStoreFromMetadataStoreName(metadataStoreName: string) {
    return this.pathTemplates.metadataStorePathTemplate.match(metadataStoreName)
      .metadata_store;
  }

  /**
   * Return a fully-qualified model resource name string.
   *
   * @param {string} project
   * @param {string} location
   * @param {string} model
   * @returns {string} Resource name string.
   */
  modelPath(project: string, location: string, model: string) {
    return this.pathTemplates.modelPathTemplate.render({
      project: project,
      location: location,
      model: model,
    });
  }

  /**
   * Parse the project from Model resource.
   *
   * @param {string} modelName
   *   A fully-qualified path representing Model resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromModelName(modelName: string) {
    return this.pathTemplates.modelPathTemplate.match(modelName).project;
  }

  /**
   * Parse the location from Model resource.
   *
   * @param {string} modelName
   *   A fully-qualified path representing Model resource.
   * @returns {string} A string representing the location.
   */
  matchLocationFromModelName(modelName: string) {
    return this.pathTemplates.modelPathTemplate.match(modelName).location;
  }

  /**
   * Parse the model from Model resource.
   *
   * @param {string} modelName
   *   A fully-qualified path representing Model resource.
   * @returns {string} A string representing the model.
   */
  matchModelFromModelName(modelName: string) {
    return this.pathTemplates.modelPathTemplate.match(modelName).model;
  }

  /**
   * Return a fully-qualified modelDeploymentMonitoringJob resource name string.
   *
   * @param {string} project
   * @param {string} location
   * @param {string} model_deployment_monitoring_job
   * @returns {string} Resource name string.
   */
  modelDeploymentMonitoringJobPath(
    project: string,
    location: string,
    modelDeploymentMonitoringJob: string
  ) {
    return this.pathTemplates.modelDeploymentMonitoringJobPathTemplate.render({
      project: project,
      location: location,
      model_deployment_monitoring_job: modelDeploymentMonitoringJob,
    });
  }

  /**
   * Parse the project from ModelDeploymentMonitoringJob resource.
   *
   * @param {string} modelDeploymentMonitoringJobName
   *   A fully-qualified path representing ModelDeploymentMonitoringJob resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromModelDeploymentMonitoringJobName(
    modelDeploymentMonitoringJobName: string
  ) {
    return this.pathTemplates.modelDeploymentMonitoringJobPathTemplate.match(
      modelDeploymentMonitoringJobName
    ).project;
  }

  /**
   * Parse the location from ModelDeploymentMonitoringJob resource.
   *
   * @param {string} modelDeploymentMonitoringJobName
   *   A fully-qualified path representing ModelDeploymentMonitoringJob resource.
   * @returns {string} A string representing the location.
   */
  matchLocationFromModelDeploymentMonitoringJobName(
    modelDeploymentMonitoringJobName: string
  ) {
    return this.pathTemplates.modelDeploymentMonitoringJobPathTemplate.match(
      modelDeploymentMonitoringJobName
    ).location;
  }

  /**
   * Parse the model_deployment_monitoring_job from ModelDeploymentMonitoringJob resource.
   *
   * @param {string} modelDeploymentMonitoringJobName
   *   A fully-qualified path representing ModelDeploymentMonitoringJob resource.
   * @returns {string} A string representing the model_deployment_monitoring_job.
   */
  matchModelDeploymentMonitoringJobFromModelDeploymentMonitoringJobName(
    modelDeploymentMonitoringJobName: string
  ) {
    return this.pathTemplates.modelDeploymentMonitoringJobPathTemplate.match(
      modelDeploymentMonitoringJobName
    ).model_deployment_monitoring_job;
  }

  /**
   * Return a fully-qualified modelEvaluation resource name string.
   *
   * @param {string} project
   * @param {string} location
   * @param {string} model
   * @param {string} evaluation
   * @returns {string} Resource name string.
   */
  modelEvaluationPath(
    project: string,
    location: string,
    model: string,
    evaluation: string
  ) {
    return this.pathTemplates.modelEvaluationPathTemplate.render({
      project: project,
      location: location,
      model: model,
      evaluation: evaluation,
    });
  }

  /**
   * Parse the project from ModelEvaluation resource.
   *
   * @param {string} modelEvaluationName
   *   A fully-qualified path representing ModelEvaluation resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromModelEvaluationName(modelEvaluationName: string) {
    return this.pathTemplates.modelEvaluationPathTemplate.match(
      modelEvaluationName
    ).project;
  }

  /**
   * Parse the location from ModelEvaluation resource.
   *
   * @param {string} modelEvaluationName
   *   A fully-qualified path representing ModelEvaluation resource.
   * @returns {string} A string representing the location.
   */
  matchLocationFromModelEvaluationName(modelEvaluationName: string) {
    return this.pathTemplates.modelEvaluationPathTemplate.match(
      modelEvaluationName
    ).location;
  }

  /**
   * Parse the model from ModelEvaluation resource.
   *
   * @param {string} modelEvaluationName
   *   A fully-qualified path representing ModelEvaluation resource.
   * @returns {string} A string representing the model.
   */
  matchModelFromModelEvaluationName(modelEvaluationName: string) {
    return this.pathTemplates.modelEvaluationPathTemplate.match(
      modelEvaluationName
    ).model;
  }

  /**
   * Parse the evaluation from ModelEvaluation resource.
   *
   * @param {string} modelEvaluationName
   *   A fully-qualified path representing ModelEvaluation resource.
   * @returns {string} A string representing the evaluation.
   */
  matchEvaluationFromModelEvaluationName(modelEvaluationName: string) {
    return this.pathTemplates.modelEvaluationPathTemplate.match(
      modelEvaluationName
    ).evaluation;
  }

  /**
   * Return a fully-qualified modelEvaluationSlice resource name string.
   *
   * @param {string} project
   * @param {string} location
   * @param {string} model
   * @param {string} evaluation
   * @param {string} slice
   * @returns {string} Resource name string.
   */
  modelEvaluationSlicePath(
    project: string,
    location: string,
    model: string,
    evaluation: string,
    slice: string
  ) {
    return this.pathTemplates.modelEvaluationSlicePathTemplate.render({
      project: project,
      location: location,
      model: model,
      evaluation: evaluation,
      slice: slice,
    });
  }

  /**
   * Parse the project from ModelEvaluationSlice resource.
   *
   * @param {string} modelEvaluationSliceName
   *   A fully-qualified path representing ModelEvaluationSlice resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromModelEvaluationSliceName(modelEvaluationSliceName: string) {
    return this.pathTemplates.modelEvaluationSlicePathTemplate.match(
      modelEvaluationSliceName
    ).project;
  }

  /**
   * Parse the location from ModelEvaluationSlice resource.
   *
   * @param {string} modelEvaluationSliceName
   *   A fully-qualified path representing ModelEvaluationSlice resource.
   * @returns {string} A string representing the location.
   */
  matchLocationFromModelEvaluationSliceName(modelEvaluationSliceName: string) {
    return this.pathTemplates.modelEvaluationSlicePathTemplate.match(
      modelEvaluationSliceName
    ).location;
  }

  /**
   * Parse the model from ModelEvaluationSlice resource.
   *
   * @param {string} modelEvaluationSliceName
   *   A fully-qualified path representing ModelEvaluationSlice resource.
   * @returns {string} A string representing the model.
   */
  matchModelFromModelEvaluationSliceName(modelEvaluationSliceName: string) {
    return this.pathTemplates.modelEvaluationSlicePathTemplate.match(
      modelEvaluationSliceName
    ).model;
  }

  /**
   * Parse the evaluation from ModelEvaluationSlice resource.
   *
   * @param {string} modelEvaluationSliceName
   *   A fully-qualified path representing ModelEvaluationSlice resource.
   * @returns {string} A string representing the evaluation.
   */
  matchEvaluationFromModelEvaluationSliceName(
    modelEvaluationSliceName: string
  ) {
    return this.pathTemplates.modelEvaluationSlicePathTemplate.match(
      modelEvaluationSliceName
    ).evaluation;
  }

  /**
   * Parse the slice from ModelEvaluationSlice resource.
   *
   * @param {string} modelEvaluationSliceName
   *   A fully-qualified path representing ModelEvaluationSlice resource.
   * @returns {string} A string representing the slice.
   */
  matchSliceFromModelEvaluationSliceName(modelEvaluationSliceName: string) {
    return this.pathTemplates.modelEvaluationSlicePathTemplate.match(
      modelEvaluationSliceName
    ).slice;
  }

  /**
   * Return a fully-qualified pipelineJob resource name string.
   *
   * @param {string} project
   * @param {string} location
   * @param {string} pipeline_job
   * @returns {string} Resource name string.
   */
  pipelineJobPath(project: string, location: string, pipelineJob: string) {
    return this.pathTemplates.pipelineJobPathTemplate.render({
      project: project,
      location: location,
      pipeline_job: pipelineJob,
    });
  }

  /**
   * Parse the project from PipelineJob resource.
   *
   * @param {string} pipelineJobName
   *   A fully-qualified path representing PipelineJob resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromPipelineJobName(pipelineJobName: string) {
    return this.pathTemplates.pipelineJobPathTemplate.match(pipelineJobName)
      .project;
  }

  /**
   * Parse the location from PipelineJob resource.
   *
   * @param {string} pipelineJobName
   *   A fully-qualified path representing PipelineJob resource.
   * @returns {string} A string representing the location.
   */
  matchLocationFromPipelineJobName(pipelineJobName: string) {
    return this.pathTemplates.pipelineJobPathTemplate.match(pipelineJobName)
      .location;
  }

  /**
   * Parse the pipeline_job from PipelineJob resource.
   *
   * @param {string} pipelineJobName
   *   A fully-qualified path representing PipelineJob resource.
   * @returns {string} A string representing the pipeline_job.
   */
  matchPipelineJobFromPipelineJobName(pipelineJobName: string) {
    return this.pathTemplates.pipelineJobPathTemplate.match(pipelineJobName)
      .pipeline_job;
  }

  /**
   * Return a fully-qualified project resource name string.
   *
   * @param {string} project
   * @returns {string} Resource name string.
   */
  projectPath(project: string) {
    return this.pathTemplates.projectPathTemplate.render({
      project: project,
    });
  }

  /**
   * Parse the project from Project resource.
   *
   * @param {string} projectName
   *   A fully-qualified path representing Project resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromProjectName(projectName: string) {
    return this.pathTemplates.projectPathTemplate.match(projectName).project;
  }

  /**
   * Return a fully-qualified specialistPool resource name string.
   *
   * @param {string} project
   * @param {string} location
   * @param {string} specialist_pool
   * @returns {string} Resource name string.
   */
  specialistPoolPath(
    project: string,
    location: string,
    specialistPool: string
  ) {
    return this.pathTemplates.specialistPoolPathTemplate.render({
      project: project,
      location: location,
      specialist_pool: specialistPool,
    });
  }

  /**
   * Parse the project from SpecialistPool resource.
   *
   * @param {string} specialistPoolName
   *   A fully-qualified path representing SpecialistPool resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromSpecialistPoolName(specialistPoolName: string) {
    return this.pathTemplates.specialistPoolPathTemplate.match(
      specialistPoolName
    ).project;
  }

  /**
   * Parse the location from SpecialistPool resource.
   *
   * @param {string} specialistPoolName
   *   A fully-qualified path representing SpecialistPool resource.
   * @returns {string} A string representing the location.
   */
  matchLocationFromSpecialistPoolName(specialistPoolName: string) {
    return this.pathTemplates.specialistPoolPathTemplate.match(
      specialistPoolName
    ).location;
  }

  /**
   * Parse the specialist_pool from SpecialistPool resource.
   *
   * @param {string} specialistPoolName
   *   A fully-qualified path representing SpecialistPool resource.
   * @returns {string} A string representing the specialist_pool.
   */
  matchSpecialistPoolFromSpecialistPoolName(specialistPoolName: string) {
    return this.pathTemplates.specialistPoolPathTemplate.match(
      specialistPoolName
    ).specialist_pool;
  }

  /**
   * Return a fully-qualified study resource name string.
   *
   * @param {string} project
   * @param {string} location
   * @param {string} study
   * @returns {string} Resource name string.
   */
  studyPath(project: string, location: string, study: string) {
    return this.pathTemplates.studyPathTemplate.render({
      project: project,
      location: location,
      study: study,
    });
  }

  /**
   * Parse the project from Study resource.
   *
   * @param {string} studyName
   *   A fully-qualified path representing Study resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromStudyName(studyName: string) {
    return this.pathTemplates.studyPathTemplate.match(studyName).project;
  }

  /**
   * Parse the location from Study resource.
   *
   * @param {string} studyName
   *   A fully-qualified path representing Study resource.
   * @returns {string} A string representing the location.
   */
  matchLocationFromStudyName(studyName: string) {
    return this.pathTemplates.studyPathTemplate.match(studyName).location;
  }

  /**
   * Parse the study from Study resource.
   *
   * @param {string} studyName
   *   A fully-qualified path representing Study resource.
   * @returns {string} A string representing the study.
   */
  matchStudyFromStudyName(studyName: string) {
    return this.pathTemplates.studyPathTemplate.match(studyName).study;
  }

  /**
   * Return a fully-qualified tensorboard resource name string.
   *
   * @param {string} project
   * @param {string} location
   * @param {string} tensorboard
   * @returns {string} Resource name string.
   */
  tensorboardPath(project: string, location: string, tensorboard: string) {
    return this.pathTemplates.tensorboardPathTemplate.render({
      project: project,
      location: location,
      tensorboard: tensorboard,
    });
  }

  /**
   * Parse the project from Tensorboard resource.
   *
   * @param {string} tensorboardName
   *   A fully-qualified path representing Tensorboard resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromTensorboardName(tensorboardName: string) {
    return this.pathTemplates.tensorboardPathTemplate.match(tensorboardName)
      .project;
  }

  /**
   * Parse the location from Tensorboard resource.
   *
   * @param {string} tensorboardName
   *   A fully-qualified path representing Tensorboard resource.
   * @returns {string} A string representing the location.
   */
  matchLocationFromTensorboardName(tensorboardName: string) {
    return this.pathTemplates.tensorboardPathTemplate.match(tensorboardName)
      .location;
  }

  /**
   * Parse the tensorboard from Tensorboard resource.
   *
   * @param {string} tensorboardName
   *   A fully-qualified path representing Tensorboard resource.
   * @returns {string} A string representing the tensorboard.
   */
  matchTensorboardFromTensorboardName(tensorboardName: string) {
    return this.pathTemplates.tensorboardPathTemplate.match(tensorboardName)
      .tensorboard;
  }

  /**
   * Return a fully-qualified tensorboardExperiment resource name string.
   *
   * @param {string} project
   * @param {string} location
   * @param {string} tensorboard
   * @param {string} experiment
   * @returns {string} Resource name string.
   */
  tensorboardExperimentPath(
    project: string,
    location: string,
    tensorboard: string,
    experiment: string
  ) {
    return this.pathTemplates.tensorboardExperimentPathTemplate.render({
      project: project,
      location: location,
      tensorboard: tensorboard,
      experiment: experiment,
    });
  }

  /**
   * Parse the project from TensorboardExperiment resource.
   *
   * @param {string} tensorboardExperimentName
   *   A fully-qualified path representing TensorboardExperiment resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromTensorboardExperimentName(tensorboardExperimentName: string) {
    return this.pathTemplates.tensorboardExperimentPathTemplate.match(
      tensorboardExperimentName
    ).project;
  }

  /**
   * Parse the location from TensorboardExperiment resource.
   *
   * @param {string} tensorboardExperimentName
   *   A fully-qualified path representing TensorboardExperiment resource.
   * @returns {string} A string representing the location.
   */
  matchLocationFromTensorboardExperimentName(
    tensorboardExperimentName: string
  ) {
    return this.pathTemplates.tensorboardExperimentPathTemplate.match(
      tensorboardExperimentName
    ).location;
  }

  /**
   * Parse the tensorboard from TensorboardExperiment resource.
   *
   * @param {string} tensorboardExperimentName
   *   A fully-qualified path representing TensorboardExperiment resource.
   * @returns {string} A string representing the tensorboard.
   */
  matchTensorboardFromTensorboardExperimentName(
    tensorboardExperimentName: string
  ) {
    return this.pathTemplates.tensorboardExperimentPathTemplate.match(
      tensorboardExperimentName
    ).tensorboard;
  }

  /**
   * Parse the experiment from TensorboardExperiment resource.
   *
   * @param {string} tensorboardExperimentName
   *   A fully-qualified path representing TensorboardExperiment resource.
   * @returns {string} A string representing the experiment.
   */
  matchExperimentFromTensorboardExperimentName(
    tensorboardExperimentName: string
  ) {
    return this.pathTemplates.tensorboardExperimentPathTemplate.match(
      tensorboardExperimentName
    ).experiment;
  }

  /**
   * Return a fully-qualified tensorboardRun resource name string.
   *
   * @param {string} project
   * @param {string} location
   * @param {string} tensorboard
   * @param {string} experiment
   * @param {string} run
   * @returns {string} Resource name string.
   */
  tensorboardRunPath(
    project: string,
    location: string,
    tensorboard: string,
    experiment: string,
    run: string
  ) {
    return this.pathTemplates.tensorboardRunPathTemplate.render({
      project: project,
      location: location,
      tensorboard: tensorboard,
      experiment: experiment,
      run: run,
    });
  }

  /**
   * Parse the project from TensorboardRun resource.
   *
   * @param {string} tensorboardRunName
   *   A fully-qualified path representing TensorboardRun resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromTensorboardRunName(tensorboardRunName: string) {
    return this.pathTemplates.tensorboardRunPathTemplate.match(
      tensorboardRunName
    ).project;
  }

  /**
   * Parse the location from TensorboardRun resource.
   *
   * @param {string} tensorboardRunName
   *   A fully-qualified path representing TensorboardRun resource.
   * @returns {string} A string representing the location.
   */
  matchLocationFromTensorboardRunName(tensorboardRunName: string) {
    return this.pathTemplates.tensorboardRunPathTemplate.match(
      tensorboardRunName
    ).location;
  }

  /**
   * Parse the tensorboard from TensorboardRun resource.
   *
   * @param {string} tensorboardRunName
   *   A fully-qualified path representing TensorboardRun resource.
   * @returns {string} A string representing the tensorboard.
   */
  matchTensorboardFromTensorboardRunName(tensorboardRunName: string) {
    return this.pathTemplates.tensorboardRunPathTemplate.match(
      tensorboardRunName
    ).tensorboard;
  }

  /**
   * Parse the experiment from TensorboardRun resource.
   *
   * @param {string} tensorboardRunName
   *   A fully-qualified path representing TensorboardRun resource.
   * @returns {string} A string representing the experiment.
   */
  matchExperimentFromTensorboardRunName(tensorboardRunName: string) {
    return this.pathTemplates.tensorboardRunPathTemplate.match(
      tensorboardRunName
    ).experiment;
  }

  /**
   * Parse the run from TensorboardRun resource.
   *
   * @param {string} tensorboardRunName
   *   A fully-qualified path representing TensorboardRun resource.
   * @returns {string} A string representing the run.
   */
  matchRunFromTensorboardRunName(tensorboardRunName: string) {
    return this.pathTemplates.tensorboardRunPathTemplate.match(
      tensorboardRunName
    ).run;
  }

  /**
   * Return a fully-qualified tensorboardTimeSeries resource name string.
   *
   * @param {string} project
   * @param {string} location
   * @param {string} tensorboard
   * @param {string} experiment
   * @param {string} run
   * @param {string} time_series
   * @returns {string} Resource name string.
   */
  tensorboardTimeSeriesPath(
    project: string,
    location: string,
    tensorboard: string,
    experiment: string,
    run: string,
    timeSeries: string
  ) {
    return this.pathTemplates.tensorboardTimeSeriesPathTemplate.render({
      project: project,
      location: location,
      tensorboard: tensorboard,
      experiment: experiment,
      run: run,
      time_series: timeSeries,
    });
  }

  /**
   * Parse the project from TensorboardTimeSeries resource.
   *
   * @param {string} tensorboardTimeSeriesName
   *   A fully-qualified path representing TensorboardTimeSeries resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromTensorboardTimeSeriesName(tensorboardTimeSeriesName: string) {
    return this.pathTemplates.tensorboardTimeSeriesPathTemplate.match(
      tensorboardTimeSeriesName
    ).project;
  }

  /**
   * Parse the location from TensorboardTimeSeries resource.
   *
   * @param {string} tensorboardTimeSeriesName
   *   A fully-qualified path representing TensorboardTimeSeries resource.
   * @returns {string} A string representing the location.
   */
  matchLocationFromTensorboardTimeSeriesName(
    tensorboardTimeSeriesName: string
  ) {
    return this.pathTemplates.tensorboardTimeSeriesPathTemplate.match(
      tensorboardTimeSeriesName
    ).location;
  }

  /**
   * Parse the tensorboard from TensorboardTimeSeries resource.
   *
   * @param {string} tensorboardTimeSeriesName
   *   A fully-qualified path representing TensorboardTimeSeries resource.
   * @returns {string} A string representing the tensorboard.
   */
  matchTensorboardFromTensorboardTimeSeriesName(
    tensorboardTimeSeriesName: string
  ) {
    return this.pathTemplates.tensorboardTimeSeriesPathTemplate.match(
      tensorboardTimeSeriesName
    ).tensorboard;
  }

  /**
   * Parse the experiment from TensorboardTimeSeries resource.
   *
   * @param {string} tensorboardTimeSeriesName
   *   A fully-qualified path representing TensorboardTimeSeries resource.
   * @returns {string} A string representing the experiment.
   */
  matchExperimentFromTensorboardTimeSeriesName(
    tensorboardTimeSeriesName: string
  ) {
    return this.pathTemplates.tensorboardTimeSeriesPathTemplate.match(
      tensorboardTimeSeriesName
    ).experiment;
  }

  /**
   * Parse the run from TensorboardTimeSeries resource.
   *
   * @param {string} tensorboardTimeSeriesName
   *   A fully-qualified path representing TensorboardTimeSeries resource.
   * @returns {string} A string representing the run.
   */
  matchRunFromTensorboardTimeSeriesName(tensorboardTimeSeriesName: string) {
    return this.pathTemplates.tensorboardTimeSeriesPathTemplate.match(
      tensorboardTimeSeriesName
    ).run;
  }

  /**
   * Parse the time_series from TensorboardTimeSeries resource.
   *
   * @param {string} tensorboardTimeSeriesName
   *   A fully-qualified path representing TensorboardTimeSeries resource.
   * @returns {string} A string representing the time_series.
   */
  matchTimeSeriesFromTensorboardTimeSeriesName(
    tensorboardTimeSeriesName: string
  ) {
    return this.pathTemplates.tensorboardTimeSeriesPathTemplate.match(
      tensorboardTimeSeriesName
    ).time_series;
  }

  /**
   * Return a fully-qualified trainingPipeline resource name string.
   *
   * @param {string} project
   * @param {string} location
   * @param {string} training_pipeline
   * @returns {string} Resource name string.
   */
  trainingPipelinePath(
    project: string,
    location: string,
    trainingPipeline: string
  ) {
    return this.pathTemplates.trainingPipelinePathTemplate.render({
      project: project,
      location: location,
      training_pipeline: trainingPipeline,
    });
  }

  /**
   * Parse the project from TrainingPipeline resource.
   *
   * @param {string} trainingPipelineName
   *   A fully-qualified path representing TrainingPipeline resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromTrainingPipelineName(trainingPipelineName: string) {
    return this.pathTemplates.trainingPipelinePathTemplate.match(
      trainingPipelineName
    ).project;
  }

  /**
   * Parse the location from TrainingPipeline resource.
   *
   * @param {string} trainingPipelineName
   *   A fully-qualified path representing TrainingPipeline resource.
   * @returns {string} A string representing the location.
   */
  matchLocationFromTrainingPipelineName(trainingPipelineName: string) {
    return this.pathTemplates.trainingPipelinePathTemplate.match(
      trainingPipelineName
    ).location;
  }

  /**
   * Parse the training_pipeline from TrainingPipeline resource.
   *
   * @param {string} trainingPipelineName
   *   A fully-qualified path representing TrainingPipeline resource.
   * @returns {string} A string representing the training_pipeline.
   */
  matchTrainingPipelineFromTrainingPipelineName(trainingPipelineName: string) {
    return this.pathTemplates.trainingPipelinePathTemplate.match(
      trainingPipelineName
    ).training_pipeline;
  }

  /**
   * Return a fully-qualified trial resource name string.
   *
   * @param {string} project
   * @param {string} location
   * @param {string} study
   * @param {string} trial
   * @returns {string} Resource name string.
   */
  trialPath(project: string, location: string, study: string, trial: string) {
    return this.pathTemplates.trialPathTemplate.render({
      project: project,
      location: location,
      study: study,
      trial: trial,
    });
  }

  /**
   * Parse the project from Trial resource.
   *
   * @param {string} trialName
   *   A fully-qualified path representing Trial resource.
   * @returns {string} A string representing the project.
   */
  matchProjectFromTrialName(trialName: string) {
    return this.pathTemplates.trialPathTemplate.match(trialName).project;
  }

  /**
   * Parse the location from Trial resource.
   *
   * @param {string} trialName
   *   A fully-qualified path representing Trial resource.
   * @returns {string} A string representing the location.
   */
  matchLocationFromTrialName(trialName: string) {
    return this.pathTemplates.trialPathTemplate.match(trialName).location;
  }

  /**
   * Parse the study from Trial resource.
   *
   * @param {string} trialName
   *   A fully-qualified path representing Trial resource.
   * @returns {string} A string representing the study.
   */
  matchStudyFromTrialName(trialName: string) {
    return this.pathTemplates.trialPathTemplate.match(trialName).study;
  }

  /**
   * Parse the trial from Trial resource.
   *
   * @param {string} trialName
   *   A fully-qualified path representing Trial resource.
   * @returns {string} A string representing the trial.
   */
  matchTrialFromTrialName(trialName: string) {
    return this.pathTemplates.trialPathTemplate.match(trialName).trial;
  }

  /**
   * Terminate the gRPC channel and close the client.
   *
   * The client will no longer be usable and all future behavior is undefined.
   * @returns {Promise} A promise that resolves when the client is closed.
   */
  close(): Promise<void> {
    this.initialize();
    if (!this._terminated) {
      return this.featurestoreServiceStub!.then(stub => {
        this._terminated = true;
        stub.close();
      });
    }
    return Promise.resolve();
  }
}
