// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// ** This file is automatically generated by gapic-generator-typescript. **
// ** https://github.com/googleapis/gapic-generator-typescript **
// ** All changes to this file may be overwritten. **

import * as protos from '../protos/protos';
import * as assert from 'assert';
import * as sinon from 'sinon';
import {SinonStub} from 'sinon';
import {describe, it} from 'mocha';
import * as chatserviceModule from '../src';

import {PassThrough} from 'stream';

import {protobuf} from 'google-gax';

// Dynamically loaded proto JSON is needed to get the type information
// to fill in default values for request objects
const root = protobuf.Root.fromJSON(
  require('../protos/protos.json')
).resolveAll();

// eslint-disable-next-line @typescript-eslint/no-unused-vars
function getTypeDefaultValue(typeName: string, fields: string[]) {
  let type = root.lookupType(typeName) as protobuf.Type;
  for (const field of fields.slice(0, -1)) {
    type = type.fields[field]?.resolvedType as protobuf.Type;
  }
  return type.fields[fields[fields.length - 1]]?.defaultValue;
}

function generateSampleMessage<T extends object>(instance: T) {
  const filledObject = (
    instance.constructor as typeof protobuf.Message
  ).toObject(instance as protobuf.Message<T>, {defaults: true});
  return (instance.constructor as typeof protobuf.Message).fromObject(
    filledObject
  ) as T;
}

function stubSimpleCall<ResponseType>(response?: ResponseType, error?: Error) {
  return error
    ? sinon.stub().rejects(error)
    : sinon.stub().resolves([response]);
}

function stubSimpleCallWithCallback<ResponseType>(
  response?: ResponseType,
  error?: Error
) {
  return error
    ? sinon.stub().callsArgWith(2, error)
    : sinon.stub().callsArgWith(2, null, response);
}

function stubPageStreamingCall<ResponseType>(
  responses?: ResponseType[],
  error?: Error
) {
  const pagingStub = sinon.stub();
  if (responses) {
    for (let i = 0; i < responses.length; ++i) {
      pagingStub.onCall(i).callsArgWith(2, null, responses[i]);
    }
  }
  const transformStub = error
    ? sinon.stub().callsArgWith(2, error)
    : pagingStub;
  const mockStream = new PassThrough({
    objectMode: true,
    transform: transformStub,
  });
  // trigger as many responses as needed
  if (responses) {
    for (let i = 0; i < responses.length; ++i) {
      setImmediate(() => {
        mockStream.write({});
      });
    }
    setImmediate(() => {
      mockStream.end();
    });
  } else {
    setImmediate(() => {
      mockStream.write({});
    });
    setImmediate(() => {
      mockStream.end();
    });
  }
  return sinon.stub().returns(mockStream);
}

function stubAsyncIterationCall<ResponseType>(
  responses?: ResponseType[],
  error?: Error
) {
  let counter = 0;
  const asyncIterable = {
    [Symbol.asyncIterator]() {
      return {
        async next() {
          if (error) {
            return Promise.reject(error);
          }
          if (counter >= responses!.length) {
            return Promise.resolve({done: true, value: undefined});
          }
          return Promise.resolve({done: false, value: responses![counter++]});
        },
      };
    },
  };
  return sinon.stub().returns(asyncIterable);
}

describe('v1.ChatServiceClient', () => {
  describe('Common methods', () => {
    it('has apiEndpoint', () => {
      const client = new chatserviceModule.v1.ChatServiceClient();
      const apiEndpoint = client.apiEndpoint;
      assert.strictEqual(apiEndpoint, 'chat.googleapis.com');
    });

    it('has universeDomain', () => {
      const client = new chatserviceModule.v1.ChatServiceClient();
      const universeDomain = client.universeDomain;
      assert.strictEqual(universeDomain, 'googleapis.com');
    });

    if (
      typeof process === 'object' &&
      typeof process.emitWarning === 'function'
    ) {
      it('throws DeprecationWarning if static servicePath is used', () => {
        const stub = sinon.stub(process, 'emitWarning');
        const servicePath = chatserviceModule.v1.ChatServiceClient.servicePath;
        assert.strictEqual(servicePath, 'chat.googleapis.com');
        assert(stub.called);
        stub.restore();
      });

      it('throws DeprecationWarning if static apiEndpoint is used', () => {
        const stub = sinon.stub(process, 'emitWarning');
        const apiEndpoint = chatserviceModule.v1.ChatServiceClient.apiEndpoint;
        assert.strictEqual(apiEndpoint, 'chat.googleapis.com');
        assert(stub.called);
        stub.restore();
      });
    }
    it('sets apiEndpoint according to universe domain camelCase', () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        universeDomain: 'example.com',
      });
      const servicePath = client.apiEndpoint;
      assert.strictEqual(servicePath, 'chat.example.com');
    });

    it('sets apiEndpoint according to universe domain snakeCase', () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        universe_domain: 'example.com',
      });
      const servicePath = client.apiEndpoint;
      assert.strictEqual(servicePath, 'chat.example.com');
    });

    if (typeof process === 'object' && 'env' in process) {
      describe('GOOGLE_CLOUD_UNIVERSE_DOMAIN environment variable', () => {
        it('sets apiEndpoint from environment variable', () => {
          const saved = process.env['GOOGLE_CLOUD_UNIVERSE_DOMAIN'];
          process.env['GOOGLE_CLOUD_UNIVERSE_DOMAIN'] = 'example.com';
          const client = new chatserviceModule.v1.ChatServiceClient();
          const servicePath = client.apiEndpoint;
          assert.strictEqual(servicePath, 'chat.example.com');
          if (saved) {
            process.env['GOOGLE_CLOUD_UNIVERSE_DOMAIN'] = saved;
          } else {
            delete process.env['GOOGLE_CLOUD_UNIVERSE_DOMAIN'];
          }
        });

        it('value configured in code has priority over environment variable', () => {
          const saved = process.env['GOOGLE_CLOUD_UNIVERSE_DOMAIN'];
          process.env['GOOGLE_CLOUD_UNIVERSE_DOMAIN'] = 'example.com';
          const client = new chatserviceModule.v1.ChatServiceClient({
            universeDomain: 'configured.example.com',
          });
          const servicePath = client.apiEndpoint;
          assert.strictEqual(servicePath, 'chat.configured.example.com');
          if (saved) {
            process.env['GOOGLE_CLOUD_UNIVERSE_DOMAIN'] = saved;
          } else {
            delete process.env['GOOGLE_CLOUD_UNIVERSE_DOMAIN'];
          }
        });
      });
    }
    it('does not allow setting both universeDomain and universe_domain', () => {
      assert.throws(() => {
        new chatserviceModule.v1.ChatServiceClient({
          universe_domain: 'example.com',
          universeDomain: 'example.net',
        });
      });
    });

    it('has port', () => {
      const port = chatserviceModule.v1.ChatServiceClient.port;
      assert(port);
      assert(typeof port === 'number');
    });

    it('should create a client with no option', () => {
      const client = new chatserviceModule.v1.ChatServiceClient();
      assert(client);
    });

    it('should create a client with gRPC fallback', () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        fallback: true,
      });
      assert(client);
    });

    it('has initialize method and supports deferred initialization', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      assert.strictEqual(client.chatServiceStub, undefined);
      await client.initialize();
      assert(client.chatServiceStub);
    });

    it('has close method for the initialized client', done => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      assert(client.chatServiceStub);
      client.close().then(() => {
        done();
      });
    });

    it('has close method for the non-initialized client', done => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      assert.strictEqual(client.chatServiceStub, undefined);
      client.close().then(() => {
        done();
      });
    });

    it('has getProjectId method', async () => {
      const fakeProjectId = 'fake-project-id';
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.auth.getProjectId = sinon.stub().resolves(fakeProjectId);
      const result = await client.getProjectId();
      assert.strictEqual(result, fakeProjectId);
      assert((client.auth.getProjectId as SinonStub).calledWithExactly());
    });

    it('has getProjectId method with callback', async () => {
      const fakeProjectId = 'fake-project-id';
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.auth.getProjectId = sinon
        .stub()
        .callsArgWith(0, null, fakeProjectId);
      const promise = new Promise((resolve, reject) => {
        client.getProjectId((err?: Error | null, projectId?: string | null) => {
          if (err) {
            reject(err);
          } else {
            resolve(projectId);
          }
        });
      });
      const result = await promise;
      assert.strictEqual(result, fakeProjectId);
    });
  });

  describe('createMessage', () => {
    it('invokes createMessage without error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.CreateMessageRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.CreateMessageRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.chat.v1.Message()
      );
      client.innerApiCalls.createMessage = stubSimpleCall(expectedResponse);
      const [response] = await client.createMessage(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.createMessage as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.createMessage as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes createMessage without error using callback', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.CreateMessageRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.CreateMessageRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.chat.v1.Message()
      );
      client.innerApiCalls.createMessage =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.createMessage(
          request,
          (
            err?: Error | null,
            result?: protos.google.chat.v1.IMessage | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.createMessage as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.createMessage as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes createMessage with error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.CreateMessageRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.CreateMessageRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.createMessage = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.createMessage(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.createMessage as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.createMessage as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes createMessage with closed client', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.CreateMessageRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.CreateMessageRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.createMessage(request), expectedError);
    });
  });

  describe('getMembership', () => {
    it('invokes getMembership without error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.GetMembershipRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.GetMembershipRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.chat.v1.Membership()
      );
      client.innerApiCalls.getMembership = stubSimpleCall(expectedResponse);
      const [response] = await client.getMembership(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.getMembership as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getMembership as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getMembership without error using callback', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.GetMembershipRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.GetMembershipRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.chat.v1.Membership()
      );
      client.innerApiCalls.getMembership =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.getMembership(
          request,
          (
            err?: Error | null,
            result?: protos.google.chat.v1.IMembership | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.getMembership as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getMembership as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getMembership with error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.GetMembershipRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.GetMembershipRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.getMembership = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.getMembership(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.getMembership as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getMembership as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getMembership with closed client', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.GetMembershipRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.GetMembershipRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.getMembership(request), expectedError);
    });
  });

  describe('getMessage', () => {
    it('invokes getMessage without error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.GetMessageRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.GetMessageRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.chat.v1.Message()
      );
      client.innerApiCalls.getMessage = stubSimpleCall(expectedResponse);
      const [response] = await client.getMessage(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.getMessage as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getMessage as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getMessage without error using callback', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.GetMessageRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.GetMessageRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.chat.v1.Message()
      );
      client.innerApiCalls.getMessage =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.getMessage(
          request,
          (
            err?: Error | null,
            result?: protos.google.chat.v1.IMessage | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.getMessage as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getMessage as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getMessage with error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.GetMessageRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.GetMessageRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.getMessage = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.getMessage(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.getMessage as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getMessage as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getMessage with closed client', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.GetMessageRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.GetMessageRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.getMessage(request), expectedError);
    });
  });

  describe('updateMessage', () => {
    it('invokes updateMessage without error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.UpdateMessageRequest()
      );
      request.message ??= {};
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.UpdateMessageRequest',
        ['message', 'name']
      );
      request.message.name = defaultValue1;
      const expectedHeaderRequestParams = `message.name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.chat.v1.Message()
      );
      client.innerApiCalls.updateMessage = stubSimpleCall(expectedResponse);
      const [response] = await client.updateMessage(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.updateMessage as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.updateMessage as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes updateMessage without error using callback', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.UpdateMessageRequest()
      );
      request.message ??= {};
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.UpdateMessageRequest',
        ['message', 'name']
      );
      request.message.name = defaultValue1;
      const expectedHeaderRequestParams = `message.name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.chat.v1.Message()
      );
      client.innerApiCalls.updateMessage =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.updateMessage(
          request,
          (
            err?: Error | null,
            result?: protos.google.chat.v1.IMessage | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.updateMessage as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.updateMessage as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes updateMessage with error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.UpdateMessageRequest()
      );
      request.message ??= {};
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.UpdateMessageRequest',
        ['message', 'name']
      );
      request.message.name = defaultValue1;
      const expectedHeaderRequestParams = `message.name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.updateMessage = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.updateMessage(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.updateMessage as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.updateMessage as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes updateMessage with closed client', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.UpdateMessageRequest()
      );
      request.message ??= {};
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.UpdateMessageRequest',
        ['message', 'name']
      );
      request.message.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.updateMessage(request), expectedError);
    });
  });

  describe('deleteMessage', () => {
    it('invokes deleteMessage without error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.DeleteMessageRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.DeleteMessageRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.protobuf.Empty()
      );
      client.innerApiCalls.deleteMessage = stubSimpleCall(expectedResponse);
      const [response] = await client.deleteMessage(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.deleteMessage as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deleteMessage as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deleteMessage without error using callback', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.DeleteMessageRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.DeleteMessageRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.protobuf.Empty()
      );
      client.innerApiCalls.deleteMessage =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.deleteMessage(
          request,
          (
            err?: Error | null,
            result?: protos.google.protobuf.IEmpty | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.deleteMessage as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deleteMessage as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deleteMessage with error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.DeleteMessageRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.DeleteMessageRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.deleteMessage = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.deleteMessage(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.deleteMessage as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deleteMessage as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deleteMessage with closed client', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.DeleteMessageRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.DeleteMessageRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.deleteMessage(request), expectedError);
    });
  });

  describe('getAttachment', () => {
    it('invokes getAttachment without error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.GetAttachmentRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.GetAttachmentRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.chat.v1.Attachment()
      );
      client.innerApiCalls.getAttachment = stubSimpleCall(expectedResponse);
      const [response] = await client.getAttachment(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.getAttachment as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getAttachment as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getAttachment without error using callback', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.GetAttachmentRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.GetAttachmentRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.chat.v1.Attachment()
      );
      client.innerApiCalls.getAttachment =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.getAttachment(
          request,
          (
            err?: Error | null,
            result?: protos.google.chat.v1.IAttachment | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.getAttachment as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getAttachment as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getAttachment with error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.GetAttachmentRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.GetAttachmentRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.getAttachment = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.getAttachment(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.getAttachment as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getAttachment as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getAttachment with closed client', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.GetAttachmentRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.GetAttachmentRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.getAttachment(request), expectedError);
    });
  });

  describe('uploadAttachment', () => {
    it('invokes uploadAttachment without error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.UploadAttachmentRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.UploadAttachmentRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.chat.v1.UploadAttachmentResponse()
      );
      client.innerApiCalls.uploadAttachment = stubSimpleCall(expectedResponse);
      const [response] = await client.uploadAttachment(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.uploadAttachment as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.uploadAttachment as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes uploadAttachment without error using callback', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.UploadAttachmentRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.UploadAttachmentRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.chat.v1.UploadAttachmentResponse()
      );
      client.innerApiCalls.uploadAttachment =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.uploadAttachment(
          request,
          (
            err?: Error | null,
            result?: protos.google.chat.v1.IUploadAttachmentResponse | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.uploadAttachment as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.uploadAttachment as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes uploadAttachment with error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.UploadAttachmentRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.UploadAttachmentRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.uploadAttachment = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.uploadAttachment(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.uploadAttachment as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.uploadAttachment as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes uploadAttachment with closed client', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.UploadAttachmentRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.UploadAttachmentRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.uploadAttachment(request), expectedError);
    });
  });

  describe('getSpace', () => {
    it('invokes getSpace without error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.GetSpaceRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.GetSpaceRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.chat.v1.Space()
      );
      client.innerApiCalls.getSpace = stubSimpleCall(expectedResponse);
      const [response] = await client.getSpace(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.getSpace as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getSpace as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getSpace without error using callback', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.GetSpaceRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.GetSpaceRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.chat.v1.Space()
      );
      client.innerApiCalls.getSpace =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.getSpace(
          request,
          (
            err?: Error | null,
            result?: protos.google.chat.v1.ISpace | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.getSpace as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getSpace as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getSpace with error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.GetSpaceRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.GetSpaceRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.getSpace = stubSimpleCall(undefined, expectedError);
      await assert.rejects(client.getSpace(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.getSpace as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getSpace as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getSpace with closed client', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.GetSpaceRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.GetSpaceRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.getSpace(request), expectedError);
    });
  });

  describe('createSpace', () => {
    it('invokes createSpace without error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.CreateSpaceRequest()
      );
      const expectedResponse = generateSampleMessage(
        new protos.google.chat.v1.Space()
      );
      client.innerApiCalls.createSpace = stubSimpleCall(expectedResponse);
      const [response] = await client.createSpace(request);
      assert.deepStrictEqual(response, expectedResponse);
    });

    it('invokes createSpace without error using callback', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.CreateSpaceRequest()
      );
      const expectedResponse = generateSampleMessage(
        new protos.google.chat.v1.Space()
      );
      client.innerApiCalls.createSpace =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.createSpace(
          request,
          (
            err?: Error | null,
            result?: protos.google.chat.v1.ISpace | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
    });

    it('invokes createSpace with error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.CreateSpaceRequest()
      );
      const expectedError = new Error('expected');
      client.innerApiCalls.createSpace = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.createSpace(request), expectedError);
    });

    it('invokes createSpace with closed client', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.CreateSpaceRequest()
      );
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.createSpace(request), expectedError);
    });
  });

  describe('setUpSpace', () => {
    it('invokes setUpSpace without error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.SetUpSpaceRequest()
      );
      const expectedResponse = generateSampleMessage(
        new protos.google.chat.v1.Space()
      );
      client.innerApiCalls.setUpSpace = stubSimpleCall(expectedResponse);
      const [response] = await client.setUpSpace(request);
      assert.deepStrictEqual(response, expectedResponse);
    });

    it('invokes setUpSpace without error using callback', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.SetUpSpaceRequest()
      );
      const expectedResponse = generateSampleMessage(
        new protos.google.chat.v1.Space()
      );
      client.innerApiCalls.setUpSpace =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.setUpSpace(
          request,
          (
            err?: Error | null,
            result?: protos.google.chat.v1.ISpace | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
    });

    it('invokes setUpSpace with error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.SetUpSpaceRequest()
      );
      const expectedError = new Error('expected');
      client.innerApiCalls.setUpSpace = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.setUpSpace(request), expectedError);
    });

    it('invokes setUpSpace with closed client', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.SetUpSpaceRequest()
      );
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.setUpSpace(request), expectedError);
    });
  });

  describe('updateSpace', () => {
    it('invokes updateSpace without error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.UpdateSpaceRequest()
      );
      request.space ??= {};
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.UpdateSpaceRequest',
        ['space', 'name']
      );
      request.space.name = defaultValue1;
      const expectedHeaderRequestParams = `space.name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.chat.v1.Space()
      );
      client.innerApiCalls.updateSpace = stubSimpleCall(expectedResponse);
      const [response] = await client.updateSpace(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.updateSpace as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.updateSpace as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes updateSpace without error using callback', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.UpdateSpaceRequest()
      );
      request.space ??= {};
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.UpdateSpaceRequest',
        ['space', 'name']
      );
      request.space.name = defaultValue1;
      const expectedHeaderRequestParams = `space.name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.chat.v1.Space()
      );
      client.innerApiCalls.updateSpace =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.updateSpace(
          request,
          (
            err?: Error | null,
            result?: protos.google.chat.v1.ISpace | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.updateSpace as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.updateSpace as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes updateSpace with error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.UpdateSpaceRequest()
      );
      request.space ??= {};
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.UpdateSpaceRequest',
        ['space', 'name']
      );
      request.space.name = defaultValue1;
      const expectedHeaderRequestParams = `space.name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.updateSpace = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.updateSpace(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.updateSpace as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.updateSpace as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes updateSpace with closed client', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.UpdateSpaceRequest()
      );
      request.space ??= {};
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.UpdateSpaceRequest',
        ['space', 'name']
      );
      request.space.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.updateSpace(request), expectedError);
    });
  });

  describe('deleteSpace', () => {
    it('invokes deleteSpace without error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.DeleteSpaceRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.DeleteSpaceRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.protobuf.Empty()
      );
      client.innerApiCalls.deleteSpace = stubSimpleCall(expectedResponse);
      const [response] = await client.deleteSpace(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.deleteSpace as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deleteSpace as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deleteSpace without error using callback', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.DeleteSpaceRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.DeleteSpaceRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.protobuf.Empty()
      );
      client.innerApiCalls.deleteSpace =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.deleteSpace(
          request,
          (
            err?: Error | null,
            result?: protos.google.protobuf.IEmpty | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.deleteSpace as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deleteSpace as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deleteSpace with error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.DeleteSpaceRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.DeleteSpaceRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.deleteSpace = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.deleteSpace(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.deleteSpace as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deleteSpace as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deleteSpace with closed client', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.DeleteSpaceRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.DeleteSpaceRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.deleteSpace(request), expectedError);
    });
  });

  describe('completeImportSpace', () => {
    it('invokes completeImportSpace without error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.CompleteImportSpaceRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.CompleteImportSpaceRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.chat.v1.CompleteImportSpaceResponse()
      );
      client.innerApiCalls.completeImportSpace =
        stubSimpleCall(expectedResponse);
      const [response] = await client.completeImportSpace(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.completeImportSpace as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.completeImportSpace as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes completeImportSpace without error using callback', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.CompleteImportSpaceRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.CompleteImportSpaceRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.chat.v1.CompleteImportSpaceResponse()
      );
      client.innerApiCalls.completeImportSpace =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.completeImportSpace(
          request,
          (
            err?: Error | null,
            result?: protos.google.chat.v1.ICompleteImportSpaceResponse | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.completeImportSpace as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.completeImportSpace as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes completeImportSpace with error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.CompleteImportSpaceRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.CompleteImportSpaceRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.completeImportSpace = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.completeImportSpace(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.completeImportSpace as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.completeImportSpace as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes completeImportSpace with closed client', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.CompleteImportSpaceRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.CompleteImportSpaceRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.completeImportSpace(request), expectedError);
    });
  });

  describe('findDirectMessage', () => {
    it('invokes findDirectMessage without error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.FindDirectMessageRequest()
      );
      const expectedResponse = generateSampleMessage(
        new protos.google.chat.v1.Space()
      );
      client.innerApiCalls.findDirectMessage = stubSimpleCall(expectedResponse);
      const [response] = await client.findDirectMessage(request);
      assert.deepStrictEqual(response, expectedResponse);
    });

    it('invokes findDirectMessage without error using callback', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.FindDirectMessageRequest()
      );
      const expectedResponse = generateSampleMessage(
        new protos.google.chat.v1.Space()
      );
      client.innerApiCalls.findDirectMessage =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.findDirectMessage(
          request,
          (
            err?: Error | null,
            result?: protos.google.chat.v1.ISpace | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
    });

    it('invokes findDirectMessage with error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.FindDirectMessageRequest()
      );
      const expectedError = new Error('expected');
      client.innerApiCalls.findDirectMessage = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.findDirectMessage(request), expectedError);
    });

    it('invokes findDirectMessage with closed client', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.FindDirectMessageRequest()
      );
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.findDirectMessage(request), expectedError);
    });
  });

  describe('createMembership', () => {
    it('invokes createMembership without error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.CreateMembershipRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.CreateMembershipRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.chat.v1.Membership()
      );
      client.innerApiCalls.createMembership = stubSimpleCall(expectedResponse);
      const [response] = await client.createMembership(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.createMembership as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.createMembership as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes createMembership without error using callback', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.CreateMembershipRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.CreateMembershipRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.chat.v1.Membership()
      );
      client.innerApiCalls.createMembership =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.createMembership(
          request,
          (
            err?: Error | null,
            result?: protos.google.chat.v1.IMembership | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.createMembership as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.createMembership as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes createMembership with error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.CreateMembershipRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.CreateMembershipRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.createMembership = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.createMembership(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.createMembership as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.createMembership as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes createMembership with closed client', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.CreateMembershipRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.CreateMembershipRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.createMembership(request), expectedError);
    });
  });

  describe('updateMembership', () => {
    it('invokes updateMembership without error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.UpdateMembershipRequest()
      );
      request.membership ??= {};
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.UpdateMembershipRequest',
        ['membership', 'name']
      );
      request.membership.name = defaultValue1;
      const expectedHeaderRequestParams = `membership.name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.chat.v1.Membership()
      );
      client.innerApiCalls.updateMembership = stubSimpleCall(expectedResponse);
      const [response] = await client.updateMembership(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.updateMembership as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.updateMembership as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes updateMembership without error using callback', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.UpdateMembershipRequest()
      );
      request.membership ??= {};
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.UpdateMembershipRequest',
        ['membership', 'name']
      );
      request.membership.name = defaultValue1;
      const expectedHeaderRequestParams = `membership.name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.chat.v1.Membership()
      );
      client.innerApiCalls.updateMembership =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.updateMembership(
          request,
          (
            err?: Error | null,
            result?: protos.google.chat.v1.IMembership | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.updateMembership as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.updateMembership as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes updateMembership with error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.UpdateMembershipRequest()
      );
      request.membership ??= {};
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.UpdateMembershipRequest',
        ['membership', 'name']
      );
      request.membership.name = defaultValue1;
      const expectedHeaderRequestParams = `membership.name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.updateMembership = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.updateMembership(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.updateMembership as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.updateMembership as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes updateMembership with closed client', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.UpdateMembershipRequest()
      );
      request.membership ??= {};
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.UpdateMembershipRequest',
        ['membership', 'name']
      );
      request.membership.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.updateMembership(request), expectedError);
    });
  });

  describe('deleteMembership', () => {
    it('invokes deleteMembership without error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.DeleteMembershipRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.DeleteMembershipRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.chat.v1.Membership()
      );
      client.innerApiCalls.deleteMembership = stubSimpleCall(expectedResponse);
      const [response] = await client.deleteMembership(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.deleteMembership as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deleteMembership as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deleteMembership without error using callback', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.DeleteMembershipRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.DeleteMembershipRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.chat.v1.Membership()
      );
      client.innerApiCalls.deleteMembership =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.deleteMembership(
          request,
          (
            err?: Error | null,
            result?: protos.google.chat.v1.IMembership | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.deleteMembership as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deleteMembership as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deleteMembership with error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.DeleteMembershipRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.DeleteMembershipRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.deleteMembership = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.deleteMembership(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.deleteMembership as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deleteMembership as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deleteMembership with closed client', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.DeleteMembershipRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.DeleteMembershipRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.deleteMembership(request), expectedError);
    });
  });

  describe('createReaction', () => {
    it('invokes createReaction without error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.CreateReactionRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.CreateReactionRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.chat.v1.Reaction()
      );
      client.innerApiCalls.createReaction = stubSimpleCall(expectedResponse);
      const [response] = await client.createReaction(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.createReaction as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.createReaction as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes createReaction without error using callback', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.CreateReactionRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.CreateReactionRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.chat.v1.Reaction()
      );
      client.innerApiCalls.createReaction =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.createReaction(
          request,
          (
            err?: Error | null,
            result?: protos.google.chat.v1.IReaction | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.createReaction as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.createReaction as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes createReaction with error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.CreateReactionRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.CreateReactionRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.createReaction = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.createReaction(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.createReaction as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.createReaction as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes createReaction with closed client', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.CreateReactionRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.CreateReactionRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.createReaction(request), expectedError);
    });
  });

  describe('deleteReaction', () => {
    it('invokes deleteReaction without error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.DeleteReactionRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.DeleteReactionRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.protobuf.Empty()
      );
      client.innerApiCalls.deleteReaction = stubSimpleCall(expectedResponse);
      const [response] = await client.deleteReaction(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.deleteReaction as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deleteReaction as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deleteReaction without error using callback', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.DeleteReactionRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.DeleteReactionRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.protobuf.Empty()
      );
      client.innerApiCalls.deleteReaction =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.deleteReaction(
          request,
          (
            err?: Error | null,
            result?: protos.google.protobuf.IEmpty | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.deleteReaction as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deleteReaction as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deleteReaction with error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.DeleteReactionRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.DeleteReactionRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.deleteReaction = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.deleteReaction(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.deleteReaction as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.deleteReaction as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes deleteReaction with closed client', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.DeleteReactionRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.DeleteReactionRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.deleteReaction(request), expectedError);
    });
  });

  describe('getSpaceReadState', () => {
    it('invokes getSpaceReadState without error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.GetSpaceReadStateRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.GetSpaceReadStateRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.chat.v1.SpaceReadState()
      );
      client.innerApiCalls.getSpaceReadState = stubSimpleCall(expectedResponse);
      const [response] = await client.getSpaceReadState(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.getSpaceReadState as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getSpaceReadState as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getSpaceReadState without error using callback', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.GetSpaceReadStateRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.GetSpaceReadStateRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.chat.v1.SpaceReadState()
      );
      client.innerApiCalls.getSpaceReadState =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.getSpaceReadState(
          request,
          (
            err?: Error | null,
            result?: protos.google.chat.v1.ISpaceReadState | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.getSpaceReadState as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getSpaceReadState as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getSpaceReadState with error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.GetSpaceReadStateRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.GetSpaceReadStateRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.getSpaceReadState = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.getSpaceReadState(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.getSpaceReadState as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getSpaceReadState as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getSpaceReadState with closed client', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.GetSpaceReadStateRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.GetSpaceReadStateRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.getSpaceReadState(request), expectedError);
    });
  });

  describe('updateSpaceReadState', () => {
    it('invokes updateSpaceReadState without error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.UpdateSpaceReadStateRequest()
      );
      request.spaceReadState ??= {};
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.UpdateSpaceReadStateRequest',
        ['spaceReadState', 'name']
      );
      request.spaceReadState.name = defaultValue1;
      const expectedHeaderRequestParams = `space_read_state.name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.chat.v1.SpaceReadState()
      );
      client.innerApiCalls.updateSpaceReadState =
        stubSimpleCall(expectedResponse);
      const [response] = await client.updateSpaceReadState(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.updateSpaceReadState as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.updateSpaceReadState as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes updateSpaceReadState without error using callback', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.UpdateSpaceReadStateRequest()
      );
      request.spaceReadState ??= {};
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.UpdateSpaceReadStateRequest',
        ['spaceReadState', 'name']
      );
      request.spaceReadState.name = defaultValue1;
      const expectedHeaderRequestParams = `space_read_state.name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.chat.v1.SpaceReadState()
      );
      client.innerApiCalls.updateSpaceReadState =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.updateSpaceReadState(
          request,
          (
            err?: Error | null,
            result?: protos.google.chat.v1.ISpaceReadState | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.updateSpaceReadState as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.updateSpaceReadState as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes updateSpaceReadState with error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.UpdateSpaceReadStateRequest()
      );
      request.spaceReadState ??= {};
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.UpdateSpaceReadStateRequest',
        ['spaceReadState', 'name']
      );
      request.spaceReadState.name = defaultValue1;
      const expectedHeaderRequestParams = `space_read_state.name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.updateSpaceReadState = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.updateSpaceReadState(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.updateSpaceReadState as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.updateSpaceReadState as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes updateSpaceReadState with closed client', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.UpdateSpaceReadStateRequest()
      );
      request.spaceReadState ??= {};
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.UpdateSpaceReadStateRequest',
        ['spaceReadState', 'name']
      );
      request.spaceReadState.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.updateSpaceReadState(request), expectedError);
    });
  });

  describe('getThreadReadState', () => {
    it('invokes getThreadReadState without error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.GetThreadReadStateRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.GetThreadReadStateRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.chat.v1.ThreadReadState()
      );
      client.innerApiCalls.getThreadReadState =
        stubSimpleCall(expectedResponse);
      const [response] = await client.getThreadReadState(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.getThreadReadState as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getThreadReadState as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getThreadReadState without error using callback', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.GetThreadReadStateRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.GetThreadReadStateRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedResponse = generateSampleMessage(
        new protos.google.chat.v1.ThreadReadState()
      );
      client.innerApiCalls.getThreadReadState =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.getThreadReadState(
          request,
          (
            err?: Error | null,
            result?: protos.google.chat.v1.IThreadReadState | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.getThreadReadState as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getThreadReadState as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getThreadReadState with error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.GetThreadReadStateRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.GetThreadReadStateRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedHeaderRequestParams = `name=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.getThreadReadState = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.getThreadReadState(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.getThreadReadState as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.getThreadReadState as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes getThreadReadState with closed client', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.GetThreadReadStateRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.GetThreadReadStateRequest',
        ['name']
      );
      request.name = defaultValue1;
      const expectedError = new Error('The client has already been closed.');
      client.close();
      await assert.rejects(client.getThreadReadState(request), expectedError);
    });
  });

  describe('listMessages', () => {
    it('invokes listMessages without error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.ListMessagesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.ListMessagesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(new protos.google.chat.v1.Message()),
        generateSampleMessage(new protos.google.chat.v1.Message()),
        generateSampleMessage(new protos.google.chat.v1.Message()),
      ];
      client.innerApiCalls.listMessages = stubSimpleCall(expectedResponse);
      const [response] = await client.listMessages(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.listMessages as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listMessages as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listMessages without error using callback', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.ListMessagesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.ListMessagesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(new protos.google.chat.v1.Message()),
        generateSampleMessage(new protos.google.chat.v1.Message()),
        generateSampleMessage(new protos.google.chat.v1.Message()),
      ];
      client.innerApiCalls.listMessages =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.listMessages(
          request,
          (
            err?: Error | null,
            result?: protos.google.chat.v1.IMessage[] | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.listMessages as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listMessages as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listMessages with error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.ListMessagesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.ListMessagesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.listMessages = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.listMessages(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.listMessages as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listMessages as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listMessagesStream without error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.ListMessagesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.ListMessagesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(new protos.google.chat.v1.Message()),
        generateSampleMessage(new protos.google.chat.v1.Message()),
        generateSampleMessage(new protos.google.chat.v1.Message()),
      ];
      client.descriptors.page.listMessages.createStream =
        stubPageStreamingCall(expectedResponse);
      const stream = client.listMessagesStream(request);
      const promise = new Promise((resolve, reject) => {
        const responses: protos.google.chat.v1.Message[] = [];
        stream.on('data', (response: protos.google.chat.v1.Message) => {
          responses.push(response);
        });
        stream.on('end', () => {
          resolve(responses);
        });
        stream.on('error', (err: Error) => {
          reject(err);
        });
      });
      const responses = await promise;
      assert.deepStrictEqual(responses, expectedResponse);
      assert(
        (client.descriptors.page.listMessages.createStream as SinonStub)
          .getCall(0)
          .calledWith(client.innerApiCalls.listMessages, request)
      );
      assert(
        (client.descriptors.page.listMessages.createStream as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers[
            'x-goog-request-params'
          ].includes(expectedHeaderRequestParams)
      );
    });

    it('invokes listMessagesStream with error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.ListMessagesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.ListMessagesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.descriptors.page.listMessages.createStream = stubPageStreamingCall(
        undefined,
        expectedError
      );
      const stream = client.listMessagesStream(request);
      const promise = new Promise((resolve, reject) => {
        const responses: protos.google.chat.v1.Message[] = [];
        stream.on('data', (response: protos.google.chat.v1.Message) => {
          responses.push(response);
        });
        stream.on('end', () => {
          resolve(responses);
        });
        stream.on('error', (err: Error) => {
          reject(err);
        });
      });
      await assert.rejects(promise, expectedError);
      assert(
        (client.descriptors.page.listMessages.createStream as SinonStub)
          .getCall(0)
          .calledWith(client.innerApiCalls.listMessages, request)
      );
      assert(
        (client.descriptors.page.listMessages.createStream as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers[
            'x-goog-request-params'
          ].includes(expectedHeaderRequestParams)
      );
    });

    it('uses async iteration with listMessages without error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.ListMessagesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.ListMessagesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(new protos.google.chat.v1.Message()),
        generateSampleMessage(new protos.google.chat.v1.Message()),
        generateSampleMessage(new protos.google.chat.v1.Message()),
      ];
      client.descriptors.page.listMessages.asyncIterate =
        stubAsyncIterationCall(expectedResponse);
      const responses: protos.google.chat.v1.IMessage[] = [];
      const iterable = client.listMessagesAsync(request);
      for await (const resource of iterable) {
        responses.push(resource!);
      }
      assert.deepStrictEqual(responses, expectedResponse);
      assert.deepStrictEqual(
        (
          client.descriptors.page.listMessages.asyncIterate as SinonStub
        ).getCall(0).args[1],
        request
      );
      assert(
        (client.descriptors.page.listMessages.asyncIterate as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers[
            'x-goog-request-params'
          ].includes(expectedHeaderRequestParams)
      );
    });

    it('uses async iteration with listMessages with error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.ListMessagesRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.ListMessagesRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.descriptors.page.listMessages.asyncIterate =
        stubAsyncIterationCall(undefined, expectedError);
      const iterable = client.listMessagesAsync(request);
      await assert.rejects(async () => {
        const responses: protos.google.chat.v1.IMessage[] = [];
        for await (const resource of iterable) {
          responses.push(resource!);
        }
      });
      assert.deepStrictEqual(
        (
          client.descriptors.page.listMessages.asyncIterate as SinonStub
        ).getCall(0).args[1],
        request
      );
      assert(
        (client.descriptors.page.listMessages.asyncIterate as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers[
            'x-goog-request-params'
          ].includes(expectedHeaderRequestParams)
      );
    });
  });

  describe('listMemberships', () => {
    it('invokes listMemberships without error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.ListMembershipsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.ListMembershipsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(new protos.google.chat.v1.Membership()),
        generateSampleMessage(new protos.google.chat.v1.Membership()),
        generateSampleMessage(new protos.google.chat.v1.Membership()),
      ];
      client.innerApiCalls.listMemberships = stubSimpleCall(expectedResponse);
      const [response] = await client.listMemberships(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.listMemberships as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listMemberships as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listMemberships without error using callback', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.ListMembershipsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.ListMembershipsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(new protos.google.chat.v1.Membership()),
        generateSampleMessage(new protos.google.chat.v1.Membership()),
        generateSampleMessage(new protos.google.chat.v1.Membership()),
      ];
      client.innerApiCalls.listMemberships =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.listMemberships(
          request,
          (
            err?: Error | null,
            result?: protos.google.chat.v1.IMembership[] | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.listMemberships as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listMemberships as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listMemberships with error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.ListMembershipsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.ListMembershipsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.listMemberships = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.listMemberships(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.listMemberships as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listMemberships as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listMembershipsStream without error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.ListMembershipsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.ListMembershipsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(new protos.google.chat.v1.Membership()),
        generateSampleMessage(new protos.google.chat.v1.Membership()),
        generateSampleMessage(new protos.google.chat.v1.Membership()),
      ];
      client.descriptors.page.listMemberships.createStream =
        stubPageStreamingCall(expectedResponse);
      const stream = client.listMembershipsStream(request);
      const promise = new Promise((resolve, reject) => {
        const responses: protos.google.chat.v1.Membership[] = [];
        stream.on('data', (response: protos.google.chat.v1.Membership) => {
          responses.push(response);
        });
        stream.on('end', () => {
          resolve(responses);
        });
        stream.on('error', (err: Error) => {
          reject(err);
        });
      });
      const responses = await promise;
      assert.deepStrictEqual(responses, expectedResponse);
      assert(
        (client.descriptors.page.listMemberships.createStream as SinonStub)
          .getCall(0)
          .calledWith(client.innerApiCalls.listMemberships, request)
      );
      assert(
        (client.descriptors.page.listMemberships.createStream as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers[
            'x-goog-request-params'
          ].includes(expectedHeaderRequestParams)
      );
    });

    it('invokes listMembershipsStream with error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.ListMembershipsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.ListMembershipsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.descriptors.page.listMemberships.createStream =
        stubPageStreamingCall(undefined, expectedError);
      const stream = client.listMembershipsStream(request);
      const promise = new Promise((resolve, reject) => {
        const responses: protos.google.chat.v1.Membership[] = [];
        stream.on('data', (response: protos.google.chat.v1.Membership) => {
          responses.push(response);
        });
        stream.on('end', () => {
          resolve(responses);
        });
        stream.on('error', (err: Error) => {
          reject(err);
        });
      });
      await assert.rejects(promise, expectedError);
      assert(
        (client.descriptors.page.listMemberships.createStream as SinonStub)
          .getCall(0)
          .calledWith(client.innerApiCalls.listMemberships, request)
      );
      assert(
        (client.descriptors.page.listMemberships.createStream as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers[
            'x-goog-request-params'
          ].includes(expectedHeaderRequestParams)
      );
    });

    it('uses async iteration with listMemberships without error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.ListMembershipsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.ListMembershipsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(new protos.google.chat.v1.Membership()),
        generateSampleMessage(new protos.google.chat.v1.Membership()),
        generateSampleMessage(new protos.google.chat.v1.Membership()),
      ];
      client.descriptors.page.listMemberships.asyncIterate =
        stubAsyncIterationCall(expectedResponse);
      const responses: protos.google.chat.v1.IMembership[] = [];
      const iterable = client.listMembershipsAsync(request);
      for await (const resource of iterable) {
        responses.push(resource!);
      }
      assert.deepStrictEqual(responses, expectedResponse);
      assert.deepStrictEqual(
        (
          client.descriptors.page.listMemberships.asyncIterate as SinonStub
        ).getCall(0).args[1],
        request
      );
      assert(
        (client.descriptors.page.listMemberships.asyncIterate as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers[
            'x-goog-request-params'
          ].includes(expectedHeaderRequestParams)
      );
    });

    it('uses async iteration with listMemberships with error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.ListMembershipsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.ListMembershipsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.descriptors.page.listMemberships.asyncIterate =
        stubAsyncIterationCall(undefined, expectedError);
      const iterable = client.listMembershipsAsync(request);
      await assert.rejects(async () => {
        const responses: protos.google.chat.v1.IMembership[] = [];
        for await (const resource of iterable) {
          responses.push(resource!);
        }
      });
      assert.deepStrictEqual(
        (
          client.descriptors.page.listMemberships.asyncIterate as SinonStub
        ).getCall(0).args[1],
        request
      );
      assert(
        (client.descriptors.page.listMemberships.asyncIterate as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers[
            'x-goog-request-params'
          ].includes(expectedHeaderRequestParams)
      );
    });
  });

  describe('listSpaces', () => {
    it('invokes listSpaces without error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.ListSpacesRequest()
      );
      const expectedResponse = [
        generateSampleMessage(new protos.google.chat.v1.Space()),
        generateSampleMessage(new protos.google.chat.v1.Space()),
        generateSampleMessage(new protos.google.chat.v1.Space()),
      ];
      client.innerApiCalls.listSpaces = stubSimpleCall(expectedResponse);
      const [response] = await client.listSpaces(request);
      assert.deepStrictEqual(response, expectedResponse);
    });

    it('invokes listSpaces without error using callback', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.ListSpacesRequest()
      );
      const expectedResponse = [
        generateSampleMessage(new protos.google.chat.v1.Space()),
        generateSampleMessage(new protos.google.chat.v1.Space()),
        generateSampleMessage(new protos.google.chat.v1.Space()),
      ];
      client.innerApiCalls.listSpaces =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.listSpaces(
          request,
          (
            err?: Error | null,
            result?: protos.google.chat.v1.ISpace[] | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
    });

    it('invokes listSpaces with error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.ListSpacesRequest()
      );
      const expectedError = new Error('expected');
      client.innerApiCalls.listSpaces = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.listSpaces(request), expectedError);
    });

    it('invokes listSpacesStream without error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.ListSpacesRequest()
      );
      const expectedResponse = [
        generateSampleMessage(new protos.google.chat.v1.Space()),
        generateSampleMessage(new protos.google.chat.v1.Space()),
        generateSampleMessage(new protos.google.chat.v1.Space()),
      ];
      client.descriptors.page.listSpaces.createStream =
        stubPageStreamingCall(expectedResponse);
      const stream = client.listSpacesStream(request);
      const promise = new Promise((resolve, reject) => {
        const responses: protos.google.chat.v1.Space[] = [];
        stream.on('data', (response: protos.google.chat.v1.Space) => {
          responses.push(response);
        });
        stream.on('end', () => {
          resolve(responses);
        });
        stream.on('error', (err: Error) => {
          reject(err);
        });
      });
      const responses = await promise;
      assert.deepStrictEqual(responses, expectedResponse);
      assert(
        (client.descriptors.page.listSpaces.createStream as SinonStub)
          .getCall(0)
          .calledWith(client.innerApiCalls.listSpaces, request)
      );
    });

    it('invokes listSpacesStream with error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.ListSpacesRequest()
      );
      const expectedError = new Error('expected');
      client.descriptors.page.listSpaces.createStream = stubPageStreamingCall(
        undefined,
        expectedError
      );
      const stream = client.listSpacesStream(request);
      const promise = new Promise((resolve, reject) => {
        const responses: protos.google.chat.v1.Space[] = [];
        stream.on('data', (response: protos.google.chat.v1.Space) => {
          responses.push(response);
        });
        stream.on('end', () => {
          resolve(responses);
        });
        stream.on('error', (err: Error) => {
          reject(err);
        });
      });
      await assert.rejects(promise, expectedError);
      assert(
        (client.descriptors.page.listSpaces.createStream as SinonStub)
          .getCall(0)
          .calledWith(client.innerApiCalls.listSpaces, request)
      );
    });

    it('uses async iteration with listSpaces without error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.ListSpacesRequest()
      );
      const expectedResponse = [
        generateSampleMessage(new protos.google.chat.v1.Space()),
        generateSampleMessage(new protos.google.chat.v1.Space()),
        generateSampleMessage(new protos.google.chat.v1.Space()),
      ];
      client.descriptors.page.listSpaces.asyncIterate =
        stubAsyncIterationCall(expectedResponse);
      const responses: protos.google.chat.v1.ISpace[] = [];
      const iterable = client.listSpacesAsync(request);
      for await (const resource of iterable) {
        responses.push(resource!);
      }
      assert.deepStrictEqual(responses, expectedResponse);
      assert.deepStrictEqual(
        (client.descriptors.page.listSpaces.asyncIterate as SinonStub).getCall(
          0
        ).args[1],
        request
      );
    });

    it('uses async iteration with listSpaces with error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.ListSpacesRequest()
      );
      const expectedError = new Error('expected');
      client.descriptors.page.listSpaces.asyncIterate = stubAsyncIterationCall(
        undefined,
        expectedError
      );
      const iterable = client.listSpacesAsync(request);
      await assert.rejects(async () => {
        const responses: protos.google.chat.v1.ISpace[] = [];
        for await (const resource of iterable) {
          responses.push(resource!);
        }
      });
      assert.deepStrictEqual(
        (client.descriptors.page.listSpaces.asyncIterate as SinonStub).getCall(
          0
        ).args[1],
        request
      );
    });
  });

  describe('listReactions', () => {
    it('invokes listReactions without error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.ListReactionsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.ListReactionsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(new protos.google.chat.v1.Reaction()),
        generateSampleMessage(new protos.google.chat.v1.Reaction()),
        generateSampleMessage(new protos.google.chat.v1.Reaction()),
      ];
      client.innerApiCalls.listReactions = stubSimpleCall(expectedResponse);
      const [response] = await client.listReactions(request);
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.listReactions as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listReactions as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listReactions without error using callback', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.ListReactionsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.ListReactionsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(new protos.google.chat.v1.Reaction()),
        generateSampleMessage(new protos.google.chat.v1.Reaction()),
        generateSampleMessage(new protos.google.chat.v1.Reaction()),
      ];
      client.innerApiCalls.listReactions =
        stubSimpleCallWithCallback(expectedResponse);
      const promise = new Promise((resolve, reject) => {
        client.listReactions(
          request,
          (
            err?: Error | null,
            result?: protos.google.chat.v1.IReaction[] | null
          ) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          }
        );
      });
      const response = await promise;
      assert.deepStrictEqual(response, expectedResponse);
      const actualRequest = (
        client.innerApiCalls.listReactions as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listReactions as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listReactions with error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.ListReactionsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.ListReactionsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.innerApiCalls.listReactions = stubSimpleCall(
        undefined,
        expectedError
      );
      await assert.rejects(client.listReactions(request), expectedError);
      const actualRequest = (
        client.innerApiCalls.listReactions as SinonStub
      ).getCall(0).args[0];
      assert.deepStrictEqual(actualRequest, request);
      const actualHeaderRequestParams = (
        client.innerApiCalls.listReactions as SinonStub
      ).getCall(0).args[1].otherArgs.headers['x-goog-request-params'];
      assert(actualHeaderRequestParams.includes(expectedHeaderRequestParams));
    });

    it('invokes listReactionsStream without error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.ListReactionsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.ListReactionsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(new protos.google.chat.v1.Reaction()),
        generateSampleMessage(new protos.google.chat.v1.Reaction()),
        generateSampleMessage(new protos.google.chat.v1.Reaction()),
      ];
      client.descriptors.page.listReactions.createStream =
        stubPageStreamingCall(expectedResponse);
      const stream = client.listReactionsStream(request);
      const promise = new Promise((resolve, reject) => {
        const responses: protos.google.chat.v1.Reaction[] = [];
        stream.on('data', (response: protos.google.chat.v1.Reaction) => {
          responses.push(response);
        });
        stream.on('end', () => {
          resolve(responses);
        });
        stream.on('error', (err: Error) => {
          reject(err);
        });
      });
      const responses = await promise;
      assert.deepStrictEqual(responses, expectedResponse);
      assert(
        (client.descriptors.page.listReactions.createStream as SinonStub)
          .getCall(0)
          .calledWith(client.innerApiCalls.listReactions, request)
      );
      assert(
        (client.descriptors.page.listReactions.createStream as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers[
            'x-goog-request-params'
          ].includes(expectedHeaderRequestParams)
      );
    });

    it('invokes listReactionsStream with error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.ListReactionsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.ListReactionsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.descriptors.page.listReactions.createStream =
        stubPageStreamingCall(undefined, expectedError);
      const stream = client.listReactionsStream(request);
      const promise = new Promise((resolve, reject) => {
        const responses: protos.google.chat.v1.Reaction[] = [];
        stream.on('data', (response: protos.google.chat.v1.Reaction) => {
          responses.push(response);
        });
        stream.on('end', () => {
          resolve(responses);
        });
        stream.on('error', (err: Error) => {
          reject(err);
        });
      });
      await assert.rejects(promise, expectedError);
      assert(
        (client.descriptors.page.listReactions.createStream as SinonStub)
          .getCall(0)
          .calledWith(client.innerApiCalls.listReactions, request)
      );
      assert(
        (client.descriptors.page.listReactions.createStream as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers[
            'x-goog-request-params'
          ].includes(expectedHeaderRequestParams)
      );
    });

    it('uses async iteration with listReactions without error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.ListReactionsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.ListReactionsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedResponse = [
        generateSampleMessage(new protos.google.chat.v1.Reaction()),
        generateSampleMessage(new protos.google.chat.v1.Reaction()),
        generateSampleMessage(new protos.google.chat.v1.Reaction()),
      ];
      client.descriptors.page.listReactions.asyncIterate =
        stubAsyncIterationCall(expectedResponse);
      const responses: protos.google.chat.v1.IReaction[] = [];
      const iterable = client.listReactionsAsync(request);
      for await (const resource of iterable) {
        responses.push(resource!);
      }
      assert.deepStrictEqual(responses, expectedResponse);
      assert.deepStrictEqual(
        (
          client.descriptors.page.listReactions.asyncIterate as SinonStub
        ).getCall(0).args[1],
        request
      );
      assert(
        (client.descriptors.page.listReactions.asyncIterate as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers[
            'x-goog-request-params'
          ].includes(expectedHeaderRequestParams)
      );
    });

    it('uses async iteration with listReactions with error', async () => {
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      const request = generateSampleMessage(
        new protos.google.chat.v1.ListReactionsRequest()
      );
      const defaultValue1 = getTypeDefaultValue(
        '.google.chat.v1.ListReactionsRequest',
        ['parent']
      );
      request.parent = defaultValue1;
      const expectedHeaderRequestParams = `parent=${defaultValue1}`;
      const expectedError = new Error('expected');
      client.descriptors.page.listReactions.asyncIterate =
        stubAsyncIterationCall(undefined, expectedError);
      const iterable = client.listReactionsAsync(request);
      await assert.rejects(async () => {
        const responses: protos.google.chat.v1.IReaction[] = [];
        for await (const resource of iterable) {
          responses.push(resource!);
        }
      });
      assert.deepStrictEqual(
        (
          client.descriptors.page.listReactions.asyncIterate as SinonStub
        ).getCall(0).args[1],
        request
      );
      assert(
        (client.descriptors.page.listReactions.asyncIterate as SinonStub)
          .getCall(0)
          .args[2].otherArgs.headers[
            'x-goog-request-params'
          ].includes(expectedHeaderRequestParams)
      );
    });
  });

  describe('Path templates', () => {
    describe('attachment', () => {
      const fakePath = '/rendered/path/attachment';
      const expectedParameters = {
        space: 'spaceValue',
        message: 'messageValue',
        attachment: 'attachmentValue',
      };
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.attachmentPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.attachmentPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('attachmentPath', () => {
        const result = client.attachmentPath(
          'spaceValue',
          'messageValue',
          'attachmentValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (client.pathTemplates.attachmentPathTemplate.render as SinonStub)
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchSpaceFromAttachmentName', () => {
        const result = client.matchSpaceFromAttachmentName(fakePath);
        assert.strictEqual(result, 'spaceValue');
        assert(
          (client.pathTemplates.attachmentPathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchMessageFromAttachmentName', () => {
        const result = client.matchMessageFromAttachmentName(fakePath);
        assert.strictEqual(result, 'messageValue');
        assert(
          (client.pathTemplates.attachmentPathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchAttachmentFromAttachmentName', () => {
        const result = client.matchAttachmentFromAttachmentName(fakePath);
        assert.strictEqual(result, 'attachmentValue');
        assert(
          (client.pathTemplates.attachmentPathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('membership', () => {
      const fakePath = '/rendered/path/membership';
      const expectedParameters = {
        space: 'spaceValue',
        member: 'memberValue',
      };
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.membershipPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.membershipPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('membershipPath', () => {
        const result = client.membershipPath('spaceValue', 'memberValue');
        assert.strictEqual(result, fakePath);
        assert(
          (client.pathTemplates.membershipPathTemplate.render as SinonStub)
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchSpaceFromMembershipName', () => {
        const result = client.matchSpaceFromMembershipName(fakePath);
        assert.strictEqual(result, 'spaceValue');
        assert(
          (client.pathTemplates.membershipPathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchMemberFromMembershipName', () => {
        const result = client.matchMemberFromMembershipName(fakePath);
        assert.strictEqual(result, 'memberValue');
        assert(
          (client.pathTemplates.membershipPathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('message', () => {
      const fakePath = '/rendered/path/message';
      const expectedParameters = {
        space: 'spaceValue',
        message: 'messageValue',
      };
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.messagePathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.messagePathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('messagePath', () => {
        const result = client.messagePath('spaceValue', 'messageValue');
        assert.strictEqual(result, fakePath);
        assert(
          (client.pathTemplates.messagePathTemplate.render as SinonStub)
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchSpaceFromMessageName', () => {
        const result = client.matchSpaceFromMessageName(fakePath);
        assert.strictEqual(result, 'spaceValue');
        assert(
          (client.pathTemplates.messagePathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchMessageFromMessageName', () => {
        const result = client.matchMessageFromMessageName(fakePath);
        assert.strictEqual(result, 'messageValue');
        assert(
          (client.pathTemplates.messagePathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('quotedMessageMetadata', () => {
      const fakePath = '/rendered/path/quotedMessageMetadata';
      const expectedParameters = {
        space: 'spaceValue',
        message: 'messageValue',
        quoted_message_metadata: 'quotedMessageMetadataValue',
      };
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.quotedMessageMetadataPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.quotedMessageMetadataPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('quotedMessageMetadataPath', () => {
        const result = client.quotedMessageMetadataPath(
          'spaceValue',
          'messageValue',
          'quotedMessageMetadataValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (
            client.pathTemplates.quotedMessageMetadataPathTemplate
              .render as SinonStub
          )
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchSpaceFromQuotedMessageMetadataName', () => {
        const result = client.matchSpaceFromQuotedMessageMetadataName(fakePath);
        assert.strictEqual(result, 'spaceValue');
        assert(
          (
            client.pathTemplates.quotedMessageMetadataPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchMessageFromQuotedMessageMetadataName', () => {
        const result =
          client.matchMessageFromQuotedMessageMetadataName(fakePath);
        assert.strictEqual(result, 'messageValue');
        assert(
          (
            client.pathTemplates.quotedMessageMetadataPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchQuotedMessageMetadataFromQuotedMessageMetadataName', () => {
        const result =
          client.matchQuotedMessageMetadataFromQuotedMessageMetadataName(
            fakePath
          );
        assert.strictEqual(result, 'quotedMessageMetadataValue');
        assert(
          (
            client.pathTemplates.quotedMessageMetadataPathTemplate
              .match as SinonStub
          )
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('reaction', () => {
      const fakePath = '/rendered/path/reaction';
      const expectedParameters = {
        space: 'spaceValue',
        message: 'messageValue',
        reaction: 'reactionValue',
      };
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.reactionPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.reactionPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('reactionPath', () => {
        const result = client.reactionPath(
          'spaceValue',
          'messageValue',
          'reactionValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (client.pathTemplates.reactionPathTemplate.render as SinonStub)
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchSpaceFromReactionName', () => {
        const result = client.matchSpaceFromReactionName(fakePath);
        assert.strictEqual(result, 'spaceValue');
        assert(
          (client.pathTemplates.reactionPathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchMessageFromReactionName', () => {
        const result = client.matchMessageFromReactionName(fakePath);
        assert.strictEqual(result, 'messageValue');
        assert(
          (client.pathTemplates.reactionPathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchReactionFromReactionName', () => {
        const result = client.matchReactionFromReactionName(fakePath);
        assert.strictEqual(result, 'reactionValue');
        assert(
          (client.pathTemplates.reactionPathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('space', () => {
      const fakePath = '/rendered/path/space';
      const expectedParameters = {
        space: 'spaceValue',
      };
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.spacePathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.spacePathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('spacePath', () => {
        const result = client.spacePath('spaceValue');
        assert.strictEqual(result, fakePath);
        assert(
          (client.pathTemplates.spacePathTemplate.render as SinonStub)
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchSpaceFromSpaceName', () => {
        const result = client.matchSpaceFromSpaceName(fakePath);
        assert.strictEqual(result, 'spaceValue');
        assert(
          (client.pathTemplates.spacePathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('spaceReadState', () => {
      const fakePath = '/rendered/path/spaceReadState';
      const expectedParameters = {
        user: 'userValue',
        space: 'spaceValue',
      };
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.spaceReadStatePathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.spaceReadStatePathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('spaceReadStatePath', () => {
        const result = client.spaceReadStatePath('userValue', 'spaceValue');
        assert.strictEqual(result, fakePath);
        assert(
          (client.pathTemplates.spaceReadStatePathTemplate.render as SinonStub)
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchUserFromSpaceReadStateName', () => {
        const result = client.matchUserFromSpaceReadStateName(fakePath);
        assert.strictEqual(result, 'userValue');
        assert(
          (client.pathTemplates.spaceReadStatePathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchSpaceFromSpaceReadStateName', () => {
        const result = client.matchSpaceFromSpaceReadStateName(fakePath);
        assert.strictEqual(result, 'spaceValue');
        assert(
          (client.pathTemplates.spaceReadStatePathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('thread', () => {
      const fakePath = '/rendered/path/thread';
      const expectedParameters = {
        space: 'spaceValue',
        thread: 'threadValue',
      };
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.threadPathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.threadPathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('threadPath', () => {
        const result = client.threadPath('spaceValue', 'threadValue');
        assert.strictEqual(result, fakePath);
        assert(
          (client.pathTemplates.threadPathTemplate.render as SinonStub)
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchSpaceFromThreadName', () => {
        const result = client.matchSpaceFromThreadName(fakePath);
        assert.strictEqual(result, 'spaceValue');
        assert(
          (client.pathTemplates.threadPathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchThreadFromThreadName', () => {
        const result = client.matchThreadFromThreadName(fakePath);
        assert.strictEqual(result, 'threadValue');
        assert(
          (client.pathTemplates.threadPathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });

    describe('threadReadState', () => {
      const fakePath = '/rendered/path/threadReadState';
      const expectedParameters = {
        user: 'userValue',
        space: 'spaceValue',
        thread: 'threadValue',
      };
      const client = new chatserviceModule.v1.ChatServiceClient({
        credentials: {client_email: 'bogus', private_key: 'bogus'},
        projectId: 'bogus',
      });
      client.initialize();
      client.pathTemplates.threadReadStatePathTemplate.render = sinon
        .stub()
        .returns(fakePath);
      client.pathTemplates.threadReadStatePathTemplate.match = sinon
        .stub()
        .returns(expectedParameters);

      it('threadReadStatePath', () => {
        const result = client.threadReadStatePath(
          'userValue',
          'spaceValue',
          'threadValue'
        );
        assert.strictEqual(result, fakePath);
        assert(
          (client.pathTemplates.threadReadStatePathTemplate.render as SinonStub)
            .getCall(-1)
            .calledWith(expectedParameters)
        );
      });

      it('matchUserFromThreadReadStateName', () => {
        const result = client.matchUserFromThreadReadStateName(fakePath);
        assert.strictEqual(result, 'userValue');
        assert(
          (client.pathTemplates.threadReadStatePathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchSpaceFromThreadReadStateName', () => {
        const result = client.matchSpaceFromThreadReadStateName(fakePath);
        assert.strictEqual(result, 'spaceValue');
        assert(
          (client.pathTemplates.threadReadStatePathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });

      it('matchThreadFromThreadReadStateName', () => {
        const result = client.matchThreadFromThreadReadStateName(fakePath);
        assert.strictEqual(result, 'threadValue');
        assert(
          (client.pathTemplates.threadReadStatePathTemplate.match as SinonStub)
            .getCall(-1)
            .calledWith(fakePath)
        );
      });
    });
  });
});
